// +build generate

package main

import (
	"io/ioutil"
	"os"
	"strconv"
	"text/template"
)

// Emit the Envoy binary named by os.Args[1] as a Go string
// ("const envoyBytes = ...").  Have the string be split across
// multiple short-ish (<1024 bytes) lines, because tools tend to have
// problems with files with really long lines.
//
// The massive file is still problematic for `golangci-lint`.  My
// threshold for "good enough" is that if I open the file in Emacs,
// then Emacs is at least responsive enough for me to realize that was
// a mistake, and close the file; and that I don't have to resort to
// `killall emacs`.

const tmplStr = `// Code generated by Make DO NOT EDIT.

// +build linux,amd64
// +build !lint

package main

const envoyBytes = ""{{ range $line := chunked 1000 .envoyBytes -}}
	{{- " +\n\t" -}}
	{{- $line -}}
{{- end }}
`

// Returns 'str' as a sequence of quoted strings, each of which have
// max-length 'n'.
func chunked(n int, str []byte) <-chan string {
	ret := make(chan string)
	go func() {
		for len(str) > 0 {
			m := min(len(str), n-2)
			quoted := strconv.QuoteToASCII(string(str[:m]))
			for len(quoted) > n {
				m -= max(1, (len(quoted)-n)/4)
				quoted = strconv.QuoteToASCII(string(str[:m]))
			}
			ret <- quoted
			str = str[m:]
		}
		close(ret)
	}()
	return ret
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

func main() {
	envoyBytes, err := ioutil.ReadFile(os.Args[1])
	if err != nil {
		panic(err)
	}

	tmpl := template.Must(template.
		New("envoyBytes").
		Funcs(template.FuncMap{
			"chunked": chunked,
		}).
		Parse(tmplStr))

	err = tmpl.Execute(os.Stdout, map[string]interface{}{
		"envoyBytes": envoyBytes,
	})
	if err != nil {
		panic(err)
	}
}
