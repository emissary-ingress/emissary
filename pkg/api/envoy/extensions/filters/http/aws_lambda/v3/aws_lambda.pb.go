// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: envoy/extensions/filters/http/aws_lambda/v3/aws_lambda.proto

package envoy_extensions_filters_http_aws_lambda_v3

import (
	fmt "fmt"
	_ "github.com/cncf/udpa/go/udpa/annotations"
	_ "github.com/envoyproxy/protoc-gen-validate/validate"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Config_InvocationMode int32

const (
	// This is the more common mode of invocation, in which Lambda responds after it has completed the function. In
	// this mode the output of the Lambda function becomes the response of the HTTP request.
	Config_SYNCHRONOUS Config_InvocationMode = 0
	// In this mode Lambda responds immediately but continues to process the function asynchronously. This mode can be
	// used to signal events for example. In this mode, Lambda responds with an acknowledgment that it received the
	// call which is translated to an HTTP 200 OK by the filter.
	Config_ASYNCHRONOUS Config_InvocationMode = 1
)

var Config_InvocationMode_name = map[int32]string{
	0: "SYNCHRONOUS",
	1: "ASYNCHRONOUS",
}

var Config_InvocationMode_value = map[string]int32{
	"SYNCHRONOUS":  0,
	"ASYNCHRONOUS": 1,
}

func (x Config_InvocationMode) String() string {
	return proto.EnumName(Config_InvocationMode_name, int32(x))
}

func (Config_InvocationMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a22f80ea45c04127, []int{0, 0}
}

// AWS Lambda filter config
type Config struct {
	// The ARN of the AWS Lambda to invoke when the filter is engaged
	// Must be in the following format:
	// arn:<partition>:lambda:<region>:<account-number>:function:<function-name>
	Arn string `protobuf:"bytes,1,opt,name=arn,proto3" json:"arn,omitempty"`
	// Whether to transform the request (headers and body) to a JSON payload or pass it as is.
	PayloadPassthrough bool `protobuf:"varint,2,opt,name=payload_passthrough,json=payloadPassthrough,proto3" json:"payload_passthrough,omitempty"`
	// Determines the way to invoke the Lambda function.
	InvocationMode       Config_InvocationMode `protobuf:"varint,3,opt,name=invocation_mode,json=invocationMode,proto3,enum=envoy.extensions.filters.http.aws_lambda.v3.Config_InvocationMode" json:"invocation_mode,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *Config) Reset()         { *m = Config{} }
func (m *Config) String() string { return proto.CompactTextString(m) }
func (*Config) ProtoMessage()    {}
func (*Config) Descriptor() ([]byte, []int) {
	return fileDescriptor_a22f80ea45c04127, []int{0}
}
func (m *Config) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Config) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Config.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Config) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Config.Merge(m, src)
}
func (m *Config) XXX_Size() int {
	return m.Size()
}
func (m *Config) XXX_DiscardUnknown() {
	xxx_messageInfo_Config.DiscardUnknown(m)
}

var xxx_messageInfo_Config proto.InternalMessageInfo

func (m *Config) GetArn() string {
	if m != nil {
		return m.Arn
	}
	return ""
}

func (m *Config) GetPayloadPassthrough() bool {
	if m != nil {
		return m.PayloadPassthrough
	}
	return false
}

func (m *Config) GetInvocationMode() Config_InvocationMode {
	if m != nil {
		return m.InvocationMode
	}
	return Config_SYNCHRONOUS
}

// Per-route configuration for AWS Lambda. This can be useful when invoking a different Lambda function or a different
// version of the same Lambda depending on the route.
type PerRouteConfig struct {
	InvokeConfig         *Config  `protobuf:"bytes,1,opt,name=invoke_config,json=invokeConfig,proto3" json:"invoke_config,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PerRouteConfig) Reset()         { *m = PerRouteConfig{} }
func (m *PerRouteConfig) String() string { return proto.CompactTextString(m) }
func (*PerRouteConfig) ProtoMessage()    {}
func (*PerRouteConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_a22f80ea45c04127, []int{1}
}
func (m *PerRouteConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PerRouteConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PerRouteConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PerRouteConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PerRouteConfig.Merge(m, src)
}
func (m *PerRouteConfig) XXX_Size() int {
	return m.Size()
}
func (m *PerRouteConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_PerRouteConfig.DiscardUnknown(m)
}

var xxx_messageInfo_PerRouteConfig proto.InternalMessageInfo

func (m *PerRouteConfig) GetInvokeConfig() *Config {
	if m != nil {
		return m.InvokeConfig
	}
	return nil
}

func init() {
	proto.RegisterEnum("envoy.extensions.filters.http.aws_lambda.v3.Config_InvocationMode", Config_InvocationMode_name, Config_InvocationMode_value)
	proto.RegisterType((*Config)(nil), "envoy.extensions.filters.http.aws_lambda.v3.Config")
	proto.RegisterType((*PerRouteConfig)(nil), "envoy.extensions.filters.http.aws_lambda.v3.PerRouteConfig")
}

func init() {
	proto.RegisterFile("envoy/extensions/filters/http/aws_lambda/v3/aws_lambda.proto", fileDescriptor_a22f80ea45c04127)
}

var fileDescriptor_a22f80ea45c04127 = []byte{
	// 432 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x92, 0xc1, 0x6e, 0xd3, 0x30,
	0x18, 0xc7, 0x71, 0x07, 0x65, 0x78, 0x23, 0x8b, 0xc2, 0x81, 0x32, 0x89, 0xa8, 0xf4, 0x54, 0x09,
	0xc9, 0x96, 0x12, 0x2e, 0xab, 0x76, 0x69, 0x76, 0x01, 0x09, 0xb6, 0x28, 0x13, 0x12, 0x9c, 0xa2,
	0x6f, 0x8b, 0xd7, 0x58, 0x64, 0x76, 0x64, 0x3b, 0xd9, 0x7a, 0x43, 0x9c, 0x78, 0x06, 0xde, 0x81,
	0x17, 0x80, 0x33, 0xd2, 0x8e, 0xf0, 0x06, 0xa8, 0x8f, 0xb1, 0x13, 0x4a, 0x1c, 0x58, 0xab, 0x9d,
	0xca, 0xcd, 0x9f, 0xff, 0xdf, 0xff, 0xef, 0x9f, 0x3f, 0x7d, 0x78, 0x9f, 0x89, 0x5a, 0xce, 0x29,
	0xbb, 0x34, 0x4c, 0x68, 0x2e, 0x85, 0xa6, 0x67, 0xbc, 0x30, 0x4c, 0x69, 0x9a, 0x1b, 0x53, 0x52,
	0xb8, 0xd0, 0x69, 0x01, 0xe7, 0x27, 0x19, 0xd0, 0x3a, 0x5c, 0xaa, 0x48, 0xa9, 0xa4, 0x91, 0xde,
	0xf3, 0xd6, 0x4d, 0x6e, 0xdc, 0xa4, 0x73, 0x93, 0xc6, 0x4d, 0x96, 0xfa, 0xeb, 0x70, 0xf7, 0x69,
	0x95, 0x95, 0x40, 0x41, 0x08, 0x69, 0xc0, 0xb4, 0x4f, 0x69, 0x03, 0xa6, 0xd2, 0x36, 0x6b, 0xf7,
	0xd9, 0x2d, 0xb9, 0x66, 0xaa, 0x09, 0xe5, 0x62, 0xd6, 0xb5, 0x3c, 0xae, 0xa1, 0xe0, 0x19, 0x18,
	0x46, 0xff, 0x1e, 0xac, 0x30, 0xfa, 0xde, 0xc3, 0xfd, 0x03, 0x29, 0xce, 0xf8, 0xcc, 0x7b, 0x82,
	0x37, 0x40, 0x89, 0x01, 0x1a, 0xa2, 0xf1, 0x83, 0xe8, 0xfe, 0x75, 0x74, 0x57, 0xf5, 0x5c, 0x94,
	0x34, 0x77, 0x1e, 0xc5, 0x8f, 0x4a, 0x98, 0x17, 0x12, 0xb2, 0xb4, 0x04, 0xad, 0x4d, 0xae, 0x64,
	0x35, 0xcb, 0x07, 0xbd, 0x21, 0x1a, 0x6f, 0x26, 0x5e, 0x27, 0xc5, 0x37, 0x8a, 0x57, 0xe1, 0x1d,
	0x2e, 0x6a, 0x79, 0xda, 0xf2, 0xa4, 0xe7, 0x32, 0x63, 0x83, 0x8d, 0x21, 0x1a, 0x3b, 0x41, 0x44,
	0xd6, 0xf8, 0x38, 0xb1, 0x64, 0xe4, 0xd5, 0xbf, 0xa8, 0x37, 0x32, 0x63, 0xd1, 0xe6, 0x75, 0x74,
	0xef, 0x13, 0x6a, 0xe0, 0x1c, 0xbe, 0xa2, 0x8c, 0x42, 0xec, 0xac, 0xf6, 0x7a, 0x3b, 0x78, 0xeb,
	0xf8, 0xfd, 0xe1, 0xc1, 0xcb, 0xe4, 0xe8, 0xf0, 0xe8, 0xed, 0xb1, 0x7b, 0xc7, 0x73, 0xf1, 0xf6,
	0x74, 0xf9, 0x06, 0x4d, 0xf6, 0xbe, 0xfc, 0xf8, 0xec, 0xbf, 0xc0, 0x81, 0x05, 0x3b, 0xb5, 0x4f,
	0x5a, 0xa8, 0xdb, 0x4c, 0x01, 0x14, 0x65, 0x0e, 0x1d, 0xd8, 0xe8, 0x2b, 0xc2, 0x4e, 0xcc, 0x54,
	0x22, 0x2b, 0xc3, 0xba, 0x29, 0xbe, 0xc3, 0x0f, 0x1b, 0xa8, 0x0f, 0x2c, 0xb5, 0x49, 0xed, 0x3c,
	0xb7, 0x82, 0xf0, 0x3f, 0xfe, 0x9d, 0x6c, 0xdb, 0x24, 0x5b, 0x4d, 0xa6, 0x0d, 0xe7, 0x3e, 0x9e,
	0xac, 0xc3, 0xb9, 0x0a, 0x17, 0xc1, 0xd5, 0xc2, 0x47, 0x3f, 0x17, 0x3e, 0xfa, 0xbd, 0xf0, 0xd1,
	0xb7, 0x8f, 0x57, 0xbf, 0xfa, 0x3d, 0x17, 0xe1, 0x3d, 0x2e, 0x2d, 0x5d, 0xa9, 0xe4, 0xe5, 0x7c,
	0x1d, 0xd0, 0xc8, 0x99, 0x5e, 0xe8, 0xd7, 0x6d, 0x15, 0x37, 0xeb, 0x14, 0xa3, 0x93, 0x7e, 0xbb,
	0x57, 0xe1, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x1b, 0xa0, 0x40, 0xfb, 0x1f, 0x03, 0x00, 0x00,
}

func (m *Config) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Config) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Config) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.InvocationMode != 0 {
		i = encodeVarintAwsLambda(dAtA, i, uint64(m.InvocationMode))
		i--
		dAtA[i] = 0x18
	}
	if m.PayloadPassthrough {
		i--
		if m.PayloadPassthrough {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Arn) > 0 {
		i -= len(m.Arn)
		copy(dAtA[i:], m.Arn)
		i = encodeVarintAwsLambda(dAtA, i, uint64(len(m.Arn)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PerRouteConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PerRouteConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PerRouteConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.InvokeConfig != nil {
		{
			size, err := m.InvokeConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAwsLambda(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintAwsLambda(dAtA []byte, offset int, v uint64) int {
	offset -= sovAwsLambda(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Config) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Arn)
	if l > 0 {
		n += 1 + l + sovAwsLambda(uint64(l))
	}
	if m.PayloadPassthrough {
		n += 2
	}
	if m.InvocationMode != 0 {
		n += 1 + sovAwsLambda(uint64(m.InvocationMode))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PerRouteConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InvokeConfig != nil {
		l = m.InvokeConfig.Size()
		n += 1 + l + sovAwsLambda(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovAwsLambda(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAwsLambda(x uint64) (n int) {
	return sovAwsLambda(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Config) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAwsLambda
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Config: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Config: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsLambda
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAwsLambda
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAwsLambda
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Arn = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayloadPassthrough", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsLambda
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PayloadPassthrough = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvocationMode", wireType)
			}
			m.InvocationMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsLambda
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InvocationMode |= Config_InvocationMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAwsLambda(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAwsLambda
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAwsLambda
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PerRouteConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAwsLambda
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PerRouteConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PerRouteConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvokeConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsLambda
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsLambda
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAwsLambda
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InvokeConfig == nil {
				m.InvokeConfig = &Config{}
			}
			if err := m.InvokeConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAwsLambda(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAwsLambda
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAwsLambda
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAwsLambda(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAwsLambda
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAwsLambda
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAwsLambda
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAwsLambda
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupAwsLambda
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthAwsLambda
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthAwsLambda        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAwsLambda          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupAwsLambda = fmt.Errorf("proto: unexpected end of group")
)
