// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: envoy/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto

package envoy_extensions_filters_network_http_connection_manager_v3

import (
	fmt "fmt"
	_ "github.com/cncf/udpa/go/udpa/annotations"
	_ "github.com/datawire/ambassador/pkg/api/envoy/annotations"
	v32 "github.com/datawire/ambassador/pkg/api/envoy/config/accesslog/v3"
	v31 "github.com/datawire/ambassador/pkg/api/envoy/config/core/v3"
	v3 "github.com/datawire/ambassador/pkg/api/envoy/config/route/v3"
	v34 "github.com/datawire/ambassador/pkg/api/envoy/type/tracing/v3"
	v33 "github.com/datawire/ambassador/pkg/api/envoy/type/v3"
	_ "github.com/envoyproxy/protoc-gen-validate/validate"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type HttpConnectionManager_CodecType int32

const (
	// For every new connection, the connection manager will determine which
	// codec to use. This mode supports both ALPN for TLS listeners as well as
	// protocol inference for plaintext listeners. If ALPN data is available, it
	// is preferred, otherwise protocol inference is used. In almost all cases,
	// this is the right option to choose for this setting.
	HttpConnectionManager_AUTO HttpConnectionManager_CodecType = 0
	// The connection manager will assume that the client is speaking HTTP/1.1.
	HttpConnectionManager_HTTP1 HttpConnectionManager_CodecType = 1
	// The connection manager will assume that the client is speaking HTTP/2
	// (Envoy does not require HTTP/2 to take place over TLS or to use ALPN.
	// Prior knowledge is allowed).
	HttpConnectionManager_HTTP2 HttpConnectionManager_CodecType = 2
	// [#not-implemented-hide:] QUIC implementation is not production ready yet. Use this enum with
	// caution to prevent accidental execution of QUIC code. I.e. `!= HTTP2` is no longer sufficient
	// to distinguish HTTP1 and HTTP2 traffic.
	HttpConnectionManager_HTTP3 HttpConnectionManager_CodecType = 3
)

var HttpConnectionManager_CodecType_name = map[int32]string{
	0: "AUTO",
	1: "HTTP1",
	2: "HTTP2",
	3: "HTTP3",
}

var HttpConnectionManager_CodecType_value = map[string]int32{
	"AUTO":  0,
	"HTTP1": 1,
	"HTTP2": 2,
	"HTTP3": 3,
}

func (x HttpConnectionManager_CodecType) String() string {
	return proto.EnumName(HttpConnectionManager_CodecType_name, int32(x))
}

func (HttpConnectionManager_CodecType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7f8b1b876d9c097a, []int{0, 0}
}

type HttpConnectionManager_ServerHeaderTransformation int32

const (
	// Overwrite any Server header with the contents of server_name.
	HttpConnectionManager_OVERWRITE HttpConnectionManager_ServerHeaderTransformation = 0
	// If no Server header is present, append Server server_name
	// If a Server header is present, pass it through.
	HttpConnectionManager_APPEND_IF_ABSENT HttpConnectionManager_ServerHeaderTransformation = 1
	// Pass through the value of the server header, and do not append a header
	// if none is present.
	HttpConnectionManager_PASS_THROUGH HttpConnectionManager_ServerHeaderTransformation = 2
)

var HttpConnectionManager_ServerHeaderTransformation_name = map[int32]string{
	0: "OVERWRITE",
	1: "APPEND_IF_ABSENT",
	2: "PASS_THROUGH",
}

var HttpConnectionManager_ServerHeaderTransformation_value = map[string]int32{
	"OVERWRITE":        0,
	"APPEND_IF_ABSENT": 1,
	"PASS_THROUGH":     2,
}

func (x HttpConnectionManager_ServerHeaderTransformation) String() string {
	return proto.EnumName(HttpConnectionManager_ServerHeaderTransformation_name, int32(x))
}

func (HttpConnectionManager_ServerHeaderTransformation) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7f8b1b876d9c097a, []int{0, 1}
}

// How to handle the :ref:`config_http_conn_man_headers_x-forwarded-client-cert` (XFCC) HTTP
// header.
type HttpConnectionManager_ForwardClientCertDetails int32

const (
	// Do not send the XFCC header to the next hop. This is the default value.
	HttpConnectionManager_SANITIZE HttpConnectionManager_ForwardClientCertDetails = 0
	// When the client connection is mTLS (Mutual TLS), forward the XFCC header
	// in the request.
	HttpConnectionManager_FORWARD_ONLY HttpConnectionManager_ForwardClientCertDetails = 1
	// When the client connection is mTLS, append the client certificate
	// information to the request’s XFCC header and forward it.
	HttpConnectionManager_APPEND_FORWARD HttpConnectionManager_ForwardClientCertDetails = 2
	// When the client connection is mTLS, reset the XFCC header with the client
	// certificate information and send it to the next hop.
	HttpConnectionManager_SANITIZE_SET HttpConnectionManager_ForwardClientCertDetails = 3
	// Always forward the XFCC header in the request, regardless of whether the
	// client connection is mTLS.
	HttpConnectionManager_ALWAYS_FORWARD_ONLY HttpConnectionManager_ForwardClientCertDetails = 4
)

var HttpConnectionManager_ForwardClientCertDetails_name = map[int32]string{
	0: "SANITIZE",
	1: "FORWARD_ONLY",
	2: "APPEND_FORWARD",
	3: "SANITIZE_SET",
	4: "ALWAYS_FORWARD_ONLY",
}

var HttpConnectionManager_ForwardClientCertDetails_value = map[string]int32{
	"SANITIZE":            0,
	"FORWARD_ONLY":        1,
	"APPEND_FORWARD":      2,
	"SANITIZE_SET":        3,
	"ALWAYS_FORWARD_ONLY": 4,
}

func (x HttpConnectionManager_ForwardClientCertDetails) String() string {
	return proto.EnumName(HttpConnectionManager_ForwardClientCertDetails_name, int32(x))
}

func (HttpConnectionManager_ForwardClientCertDetails) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7f8b1b876d9c097a, []int{0, 2}
}

type HttpConnectionManager_Tracing_OperationName int32

const (
	// The HTTP listener is used for ingress/incoming requests.
	HttpConnectionManager_Tracing_INGRESS HttpConnectionManager_Tracing_OperationName = 0
	// The HTTP listener is used for egress/outgoing requests.
	HttpConnectionManager_Tracing_EGRESS HttpConnectionManager_Tracing_OperationName = 1
)

var HttpConnectionManager_Tracing_OperationName_name = map[int32]string{
	0: "INGRESS",
	1: "EGRESS",
}

var HttpConnectionManager_Tracing_OperationName_value = map[string]int32{
	"INGRESS": 0,
	"EGRESS":  1,
}

func (x HttpConnectionManager_Tracing_OperationName) String() string {
	return proto.EnumName(HttpConnectionManager_Tracing_OperationName_name, int32(x))
}

func (HttpConnectionManager_Tracing_OperationName) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7f8b1b876d9c097a, []int{0, 0, 0}
}

// [#next-free-field: 36]
type HttpConnectionManager struct {
	// Supplies the type of codec that the connection manager should use.
	CodecType HttpConnectionManager_CodecType `protobuf:"varint,1,opt,name=codec_type,json=codecType,proto3,enum=envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager_CodecType" json:"codec_type,omitempty"`
	// The human readable prefix to use when emitting statistics for the
	// connection manager. See the :ref:`statistics documentation <config_http_conn_man_stats>` for
	// more information.
	StatPrefix string `protobuf:"bytes,2,opt,name=stat_prefix,json=statPrefix,proto3" json:"stat_prefix,omitempty"`
	// Types that are valid to be assigned to RouteSpecifier:
	//	*HttpConnectionManager_Rds
	//	*HttpConnectionManager_RouteConfig
	//	*HttpConnectionManager_ScopedRoutes
	RouteSpecifier isHttpConnectionManager_RouteSpecifier `protobuf_oneof:"route_specifier"`
	// A list of individual HTTP filters that make up the filter chain for
	// requests made to the connection manager. Order matters as the filters are
	// processed sequentially as request events happen.
	HttpFilters []*HttpFilter `protobuf:"bytes,5,rep,name=http_filters,json=httpFilters,proto3" json:"http_filters,omitempty"`
	// Whether the connection manager manipulates the :ref:`config_http_conn_man_headers_user-agent`
	// and :ref:`config_http_conn_man_headers_downstream-service-cluster` headers. See the linked
	// documentation for more information. Defaults to false.
	AddUserAgent *types.BoolValue `protobuf:"bytes,6,opt,name=add_user_agent,json=addUserAgent,proto3" json:"add_user_agent,omitempty"`
	// Presence of the object defines whether the connection manager
	// emits :ref:`tracing <arch_overview_tracing>` data to the :ref:`configured tracing provider
	// <envoy_api_msg_config.trace.v3.Tracing>`.
	Tracing *HttpConnectionManager_Tracing `protobuf:"bytes,7,opt,name=tracing,proto3" json:"tracing,omitempty"`
	// Additional settings for HTTP requests handled by the connection manager. These will be
	// applicable to both HTTP1 and HTTP2 requests.
	CommonHttpProtocolOptions *v31.HttpProtocolOptions `protobuf:"bytes,35,opt,name=common_http_protocol_options,json=commonHttpProtocolOptions,proto3" json:"common_http_protocol_options,omitempty"`
	// Additional HTTP/1 settings that are passed to the HTTP/1 codec.
	HttpProtocolOptions *v31.Http1ProtocolOptions `protobuf:"bytes,8,opt,name=http_protocol_options,json=httpProtocolOptions,proto3" json:"http_protocol_options,omitempty"`
	// Additional HTTP/2 settings that are passed directly to the HTTP/2 codec.
	Http2ProtocolOptions *v31.Http2ProtocolOptions `protobuf:"bytes,9,opt,name=http2_protocol_options,json=http2ProtocolOptions,proto3" json:"http2_protocol_options,omitempty"`
	// An optional override that the connection manager will write to the server
	// header in responses. If not set, the default is *envoy*.
	ServerName string `protobuf:"bytes,10,opt,name=server_name,json=serverName,proto3" json:"server_name,omitempty"`
	// Defines the action to be applied to the Server header on the response path.
	// By default, Envoy will overwrite the header with the value specified in
	// server_name.
	ServerHeaderTransformation HttpConnectionManager_ServerHeaderTransformation `protobuf:"varint,34,opt,name=server_header_transformation,json=serverHeaderTransformation,proto3,enum=envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager_ServerHeaderTransformation" json:"server_header_transformation,omitempty"`
	// The maximum request headers size for incoming connections.
	// If unconfigured, the default max request headers allowed is 60 KiB.
	// Requests that exceed this limit will receive a 431 response.
	// The max configurable limit is 96 KiB, based on current implementation
	// constraints.
	MaxRequestHeadersKb *types.UInt32Value `protobuf:"bytes,29,opt,name=max_request_headers_kb,json=maxRequestHeadersKb,proto3" json:"max_request_headers_kb,omitempty"`
	// The stream idle timeout for connections managed by the connection manager.
	// If not specified, this defaults to 5 minutes. The default value was selected
	// so as not to interfere with any smaller configured timeouts that may have
	// existed in configurations prior to the introduction of this feature, while
	// introducing robustness to TCP connections that terminate without a FIN.
	//
	// This idle timeout applies to new streams and is overridable by the
	// :ref:`route-level idle_timeout
	// <envoy_api_field_config.route.v3.RouteAction.idle_timeout>`. Even on a stream in
	// which the override applies, prior to receipt of the initial request
	// headers, the :ref:`stream_idle_timeout
	// <envoy_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_idle_timeout>`
	// applies. Each time an encode/decode event for headers or data is processed
	// for the stream, the timer will be reset. If the timeout fires, the stream
	// is terminated with a 408 Request Timeout error code if no upstream response
	// header has been received, otherwise a stream reset occurs.
	//
	// Note that it is possible to idle timeout even if the wire traffic for a stream is non-idle, due
	// to the granularity of events presented to the connection manager. For example, while receiving
	// very large request headers, it may be the case that there is traffic regularly arriving on the
	// wire while the connection manage is only able to observe the end-of-headers event, hence the
	// stream may still idle timeout.
	//
	// A value of 0 will completely disable the connection manager stream idle
	// timeout, although per-route idle timeout overrides will continue to apply.
	StreamIdleTimeout *types.Duration `protobuf:"bytes,24,opt,name=stream_idle_timeout,json=streamIdleTimeout,proto3" json:"stream_idle_timeout,omitempty"`
	// A timeout for idle requests managed by the connection manager.
	// The timer is activated when the request is initiated, and is disarmed when the last byte of the
	// request is sent upstream (i.e. all decoding filters have processed the request), OR when the
	// response is initiated. If not specified or set to 0, this timeout is disabled.
	RequestTimeout *types.Duration `protobuf:"bytes,28,opt,name=request_timeout,json=requestTimeout,proto3" json:"request_timeout,omitempty"`
	// The time that Envoy will wait between sending an HTTP/2 “shutdown
	// notification” (GOAWAY frame with max stream ID) and a final GOAWAY frame.
	// This is used so that Envoy provides a grace period for new streams that
	// race with the final GOAWAY frame. During this grace period, Envoy will
	// continue to accept new streams. After the grace period, a final GOAWAY
	// frame is sent and Envoy will start refusing new streams. Draining occurs
	// both when a connection hits the idle timeout or during general server
	// draining. The default grace period is 5000 milliseconds (5 seconds) if this
	// option is not specified.
	DrainTimeout *types.Duration `protobuf:"bytes,12,opt,name=drain_timeout,json=drainTimeout,proto3" json:"drain_timeout,omitempty"`
	// The delayed close timeout is for downstream connections managed by the HTTP connection manager.
	// It is defined as a grace period after connection close processing has been locally initiated
	// during which Envoy will wait for the peer to close (i.e., a TCP FIN/RST is received by Envoy
	// from the downstream connection) prior to Envoy closing the socket associated with that
	// connection.
	// NOTE: This timeout is enforced even when the socket associated with the downstream connection
	// is pending a flush of the write buffer. However, any progress made writing data to the socket
	// will restart the timer associated with this timeout. This means that the total grace period for
	// a socket in this state will be
	// <total_time_waiting_for_write_buffer_flushes>+<delayed_close_timeout>.
	//
	// Delaying Envoy's connection close and giving the peer the opportunity to initiate the close
	// sequence mitigates a race condition that exists when downstream clients do not drain/process
	// data in a connection's receive buffer after a remote close has been detected via a socket
	// write(). This race leads to such clients failing to process the response code sent by Envoy,
	// which could result in erroneous downstream processing.
	//
	// If the timeout triggers, Envoy will close the connection's socket.
	//
	// The default timeout is 1000 ms if this option is not specified.
	//
	// .. NOTE::
	//    To be useful in avoiding the race condition described above, this timeout must be set
	//    to *at least* <max round trip time expected between clients and Envoy>+<100ms to account for
	//    a reasonable "worst" case processing time for a full iteration of Envoy's event loop>.
	//
	// .. WARNING::
	//    A value of 0 will completely disable delayed close processing. When disabled, the downstream
	//    connection's socket will be closed immediately after the write flush is completed or will
	//    never close if the write flush does not complete.
	DelayedCloseTimeout *types.Duration `protobuf:"bytes,26,opt,name=delayed_close_timeout,json=delayedCloseTimeout,proto3" json:"delayed_close_timeout,omitempty"`
	// Configuration for :ref:`HTTP access logs <arch_overview_access_logs>`
	// emitted by the connection manager.
	AccessLog []*v32.AccessLog `protobuf:"bytes,13,rep,name=access_log,json=accessLog,proto3" json:"access_log,omitempty"`
	// If set to true, the connection manager will use the real remote address
	// of the client connection when determining internal versus external origin and manipulating
	// various headers. If set to false or absent, the connection manager will use the
	// :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header. See the documentation for
	// :ref:`config_http_conn_man_headers_x-forwarded-for`,
	// :ref:`config_http_conn_man_headers_x-envoy-internal`, and
	// :ref:`config_http_conn_man_headers_x-envoy-external-address` for more information.
	UseRemoteAddress *types.BoolValue `protobuf:"bytes,14,opt,name=use_remote_address,json=useRemoteAddress,proto3" json:"use_remote_address,omitempty"`
	// The number of additional ingress proxy hops from the right side of the
	// :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header to trust when
	// determining the origin client's IP address. The default is zero if this option
	// is not specified. See the documentation for
	// :ref:`config_http_conn_man_headers_x-forwarded-for` for more information.
	XffNumTrustedHops uint32 `protobuf:"varint,19,opt,name=xff_num_trusted_hops,json=xffNumTrustedHops,proto3" json:"xff_num_trusted_hops,omitempty"`
	// Configures what network addresses are considered internal for stats and header sanitation
	// purposes. If unspecified, only RFC1918 IP addresses will be considered internal.
	// See the documentation for :ref:`config_http_conn_man_headers_x-envoy-internal` for more
	// information about internal/external addresses.
	InternalAddressConfig *HttpConnectionManager_InternalAddressConfig `protobuf:"bytes,25,opt,name=internal_address_config,json=internalAddressConfig,proto3" json:"internal_address_config,omitempty"`
	// If set, Envoy will not append the remote address to the
	// :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header. This may be used in
	// conjunction with HTTP filters that explicitly manipulate XFF after the HTTP connection manager
	// has mutated the request headers. While :ref:`use_remote_address
	// <envoy_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address>`
	// will also suppress XFF addition, it has consequences for logging and other
	// Envoy uses of the remote address, so *skip_xff_append* should be used
	// when only an elision of XFF addition is intended.
	SkipXffAppend bool `protobuf:"varint,21,opt,name=skip_xff_append,json=skipXffAppend,proto3" json:"skip_xff_append,omitempty"`
	// Via header value to append to request and response headers. If this is
	// empty, no via header will be appended.
	Via string `protobuf:"bytes,22,opt,name=via,proto3" json:"via,omitempty"`
	// Whether the connection manager will generate the :ref:`x-request-id
	// <config_http_conn_man_headers_x-request-id>` header if it does not exist. This defaults to
	// true. Generating a random UUID4 is expensive so in high throughput scenarios where this feature
	// is not desired it can be disabled.
	GenerateRequestId *types.BoolValue `protobuf:"bytes,15,opt,name=generate_request_id,json=generateRequestId,proto3" json:"generate_request_id,omitempty"`
	// Whether the connection manager will keep the :ref:`x-request-id
	// <config_http_conn_man_headers_x-request-id>` header if passed for a request that is edge
	// (Edge request is the request from external clients to front Envoy) and not reset it, which
	// is the current Envoy behaviour. This defaults to false.
	PreserveExternalRequestId bool `protobuf:"varint,32,opt,name=preserve_external_request_id,json=preserveExternalRequestId,proto3" json:"preserve_external_request_id,omitempty"`
	// How to handle the :ref:`config_http_conn_man_headers_x-forwarded-client-cert` (XFCC) HTTP
	// header.
	ForwardClientCertDetails HttpConnectionManager_ForwardClientCertDetails `protobuf:"varint,16,opt,name=forward_client_cert_details,json=forwardClientCertDetails,proto3,enum=envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager_ForwardClientCertDetails" json:"forward_client_cert_details,omitempty"`
	// This field is valid only when :ref:`forward_client_cert_details
	// <envoy_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.forward_client_cert_details>`
	// is APPEND_FORWARD or SANITIZE_SET and the client connection is mTLS. It specifies the fields in
	// the client certificate to be forwarded. Note that in the
	// :ref:`config_http_conn_man_headers_x-forwarded-client-cert` header, *Hash* is always set, and
	// *By* is always set when the client certificate presents the URI type Subject Alternative Name
	// value.
	SetCurrentClientCertDetails *HttpConnectionManager_SetCurrentClientCertDetails `protobuf:"bytes,17,opt,name=set_current_client_cert_details,json=setCurrentClientCertDetails,proto3" json:"set_current_client_cert_details,omitempty"`
	// If proxy_100_continue is true, Envoy will proxy incoming "Expect:
	// 100-continue" headers upstream, and forward "100 Continue" responses
	// downstream. If this is false or not set, Envoy will instead strip the
	// "Expect: 100-continue" header, and send a "100 Continue" response itself.
	Proxy_100Continue bool `protobuf:"varint,18,opt,name=proxy_100_continue,json=proxy100Continue,proto3" json:"proxy_100_continue,omitempty"`
	// If
	// :ref:`use_remote_address
	// <envoy_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address>`
	// is true and represent_ipv4_remote_address_as_ipv4_mapped_ipv6 is true and the remote address is
	// an IPv4 address, the address will be mapped to IPv6 before it is appended to *x-forwarded-for*.
	// This is useful for testing compatibility of upstream services that parse the header value. For
	// example, 50.0.0.1 is represented as ::FFFF:50.0.0.1. See `IPv4-Mapped IPv6 Addresses
	// <https://tools.ietf.org/html/rfc4291#section-2.5.5.2>`_ for details. This will also affect the
	// :ref:`config_http_conn_man_headers_x-envoy-external-address` header. See
	// :ref:`http_connection_manager.represent_ipv4_remote_address_as_ipv4_mapped_ipv6
	// <config_http_conn_man_runtime_represent_ipv4_remote_address_as_ipv4_mapped_ipv6>` for runtime
	// control.
	// [#not-implemented-hide:]
	RepresentIpv4RemoteAddressAsIpv4MappedIpv6 bool                                   `protobuf:"varint,20,opt,name=represent_ipv4_remote_address_as_ipv4_mapped_ipv6,json=representIpv4RemoteAddressAsIpv4MappedIpv6,proto3" json:"represent_ipv4_remote_address_as_ipv4_mapped_ipv6,omitempty"`
	UpgradeConfigs                             []*HttpConnectionManager_UpgradeConfig `protobuf:"bytes,23,rep,name=upgrade_configs,json=upgradeConfigs,proto3" json:"upgrade_configs,omitempty"`
	// Should paths be normalized according to RFC 3986 before any processing of
	// requests by HTTP filters or routing? This affects the upstream *:path* header
	// as well. For paths that fail this check, Envoy will respond with 400 to
	// paths that are malformed. This defaults to false currently but will default
	// true in the future. When not specified, this value may be overridden by the
	// runtime variable
	// :ref:`http_connection_manager.normalize_path<config_http_conn_man_runtime_normalize_path>`.
	// See `Normalization and Comparison <https://tools.ietf.org/html/rfc3986#section-6>`
	// for details of normalization.
	// Note that Envoy does not perform
	// `case normalization <https://tools.ietf.org/html/rfc3986#section-6.2.2.1>`
	NormalizePath *types.BoolValue `protobuf:"bytes,30,opt,name=normalize_path,json=normalizePath,proto3" json:"normalize_path,omitempty"`
	// Determines if adjacent slashes in the path are merged into one before any processing of
	// requests by HTTP filters or routing. This affects the upstream *:path* header as well. Without
	// setting this option, incoming requests with path `//dir///file` will not match against route
	// with `prefix` match set to `/dir`. Defaults to `false`. Note that slash merging is not part of
	// `HTTP spec <https://tools.ietf.org/html/rfc3986>` and is provided for convenience.
	MergeSlashes         bool     `protobuf:"varint,33,opt,name=merge_slashes,json=mergeSlashes,proto3" json:"merge_slashes,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HttpConnectionManager) Reset()         { *m = HttpConnectionManager{} }
func (m *HttpConnectionManager) String() string { return proto.CompactTextString(m) }
func (*HttpConnectionManager) ProtoMessage()    {}
func (*HttpConnectionManager) Descriptor() ([]byte, []int) {
	return fileDescriptor_7f8b1b876d9c097a, []int{0}
}
func (m *HttpConnectionManager) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HttpConnectionManager) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HttpConnectionManager.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HttpConnectionManager) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HttpConnectionManager.Merge(m, src)
}
func (m *HttpConnectionManager) XXX_Size() int {
	return m.Size()
}
func (m *HttpConnectionManager) XXX_DiscardUnknown() {
	xxx_messageInfo_HttpConnectionManager.DiscardUnknown(m)
}

var xxx_messageInfo_HttpConnectionManager proto.InternalMessageInfo

type isHttpConnectionManager_RouteSpecifier interface {
	isHttpConnectionManager_RouteSpecifier()
	MarshalTo([]byte) (int, error)
	Size() int
}

type HttpConnectionManager_Rds struct {
	Rds *Rds `protobuf:"bytes,3,opt,name=rds,proto3,oneof" json:"rds,omitempty"`
}
type HttpConnectionManager_RouteConfig struct {
	RouteConfig *v3.RouteConfiguration `protobuf:"bytes,4,opt,name=route_config,json=routeConfig,proto3,oneof" json:"route_config,omitempty"`
}
type HttpConnectionManager_ScopedRoutes struct {
	ScopedRoutes *ScopedRoutes `protobuf:"bytes,31,opt,name=scoped_routes,json=scopedRoutes,proto3,oneof" json:"scoped_routes,omitempty"`
}

func (*HttpConnectionManager_Rds) isHttpConnectionManager_RouteSpecifier()          {}
func (*HttpConnectionManager_RouteConfig) isHttpConnectionManager_RouteSpecifier()  {}
func (*HttpConnectionManager_ScopedRoutes) isHttpConnectionManager_RouteSpecifier() {}

func (m *HttpConnectionManager) GetRouteSpecifier() isHttpConnectionManager_RouteSpecifier {
	if m != nil {
		return m.RouteSpecifier
	}
	return nil
}

func (m *HttpConnectionManager) GetCodecType() HttpConnectionManager_CodecType {
	if m != nil {
		return m.CodecType
	}
	return HttpConnectionManager_AUTO
}

func (m *HttpConnectionManager) GetStatPrefix() string {
	if m != nil {
		return m.StatPrefix
	}
	return ""
}

func (m *HttpConnectionManager) GetRds() *Rds {
	if x, ok := m.GetRouteSpecifier().(*HttpConnectionManager_Rds); ok {
		return x.Rds
	}
	return nil
}

func (m *HttpConnectionManager) GetRouteConfig() *v3.RouteConfiguration {
	if x, ok := m.GetRouteSpecifier().(*HttpConnectionManager_RouteConfig); ok {
		return x.RouteConfig
	}
	return nil
}

func (m *HttpConnectionManager) GetScopedRoutes() *ScopedRoutes {
	if x, ok := m.GetRouteSpecifier().(*HttpConnectionManager_ScopedRoutes); ok {
		return x.ScopedRoutes
	}
	return nil
}

func (m *HttpConnectionManager) GetHttpFilters() []*HttpFilter {
	if m != nil {
		return m.HttpFilters
	}
	return nil
}

func (m *HttpConnectionManager) GetAddUserAgent() *types.BoolValue {
	if m != nil {
		return m.AddUserAgent
	}
	return nil
}

func (m *HttpConnectionManager) GetTracing() *HttpConnectionManager_Tracing {
	if m != nil {
		return m.Tracing
	}
	return nil
}

func (m *HttpConnectionManager) GetCommonHttpProtocolOptions() *v31.HttpProtocolOptions {
	if m != nil {
		return m.CommonHttpProtocolOptions
	}
	return nil
}

func (m *HttpConnectionManager) GetHttpProtocolOptions() *v31.Http1ProtocolOptions {
	if m != nil {
		return m.HttpProtocolOptions
	}
	return nil
}

func (m *HttpConnectionManager) GetHttp2ProtocolOptions() *v31.Http2ProtocolOptions {
	if m != nil {
		return m.Http2ProtocolOptions
	}
	return nil
}

func (m *HttpConnectionManager) GetServerName() string {
	if m != nil {
		return m.ServerName
	}
	return ""
}

func (m *HttpConnectionManager) GetServerHeaderTransformation() HttpConnectionManager_ServerHeaderTransformation {
	if m != nil {
		return m.ServerHeaderTransformation
	}
	return HttpConnectionManager_OVERWRITE
}

func (m *HttpConnectionManager) GetMaxRequestHeadersKb() *types.UInt32Value {
	if m != nil {
		return m.MaxRequestHeadersKb
	}
	return nil
}

func (m *HttpConnectionManager) GetStreamIdleTimeout() *types.Duration {
	if m != nil {
		return m.StreamIdleTimeout
	}
	return nil
}

func (m *HttpConnectionManager) GetRequestTimeout() *types.Duration {
	if m != nil {
		return m.RequestTimeout
	}
	return nil
}

func (m *HttpConnectionManager) GetDrainTimeout() *types.Duration {
	if m != nil {
		return m.DrainTimeout
	}
	return nil
}

func (m *HttpConnectionManager) GetDelayedCloseTimeout() *types.Duration {
	if m != nil {
		return m.DelayedCloseTimeout
	}
	return nil
}

func (m *HttpConnectionManager) GetAccessLog() []*v32.AccessLog {
	if m != nil {
		return m.AccessLog
	}
	return nil
}

func (m *HttpConnectionManager) GetUseRemoteAddress() *types.BoolValue {
	if m != nil {
		return m.UseRemoteAddress
	}
	return nil
}

func (m *HttpConnectionManager) GetXffNumTrustedHops() uint32 {
	if m != nil {
		return m.XffNumTrustedHops
	}
	return 0
}

func (m *HttpConnectionManager) GetInternalAddressConfig() *HttpConnectionManager_InternalAddressConfig {
	if m != nil {
		return m.InternalAddressConfig
	}
	return nil
}

func (m *HttpConnectionManager) GetSkipXffAppend() bool {
	if m != nil {
		return m.SkipXffAppend
	}
	return false
}

func (m *HttpConnectionManager) GetVia() string {
	if m != nil {
		return m.Via
	}
	return ""
}

func (m *HttpConnectionManager) GetGenerateRequestId() *types.BoolValue {
	if m != nil {
		return m.GenerateRequestId
	}
	return nil
}

func (m *HttpConnectionManager) GetPreserveExternalRequestId() bool {
	if m != nil {
		return m.PreserveExternalRequestId
	}
	return false
}

func (m *HttpConnectionManager) GetForwardClientCertDetails() HttpConnectionManager_ForwardClientCertDetails {
	if m != nil {
		return m.ForwardClientCertDetails
	}
	return HttpConnectionManager_SANITIZE
}

func (m *HttpConnectionManager) GetSetCurrentClientCertDetails() *HttpConnectionManager_SetCurrentClientCertDetails {
	if m != nil {
		return m.SetCurrentClientCertDetails
	}
	return nil
}

func (m *HttpConnectionManager) GetProxy_100Continue() bool {
	if m != nil {
		return m.Proxy_100Continue
	}
	return false
}

func (m *HttpConnectionManager) GetRepresentIpv4RemoteAddressAsIpv4MappedIpv6() bool {
	if m != nil {
		return m.RepresentIpv4RemoteAddressAsIpv4MappedIpv6
	}
	return false
}

func (m *HttpConnectionManager) GetUpgradeConfigs() []*HttpConnectionManager_UpgradeConfig {
	if m != nil {
		return m.UpgradeConfigs
	}
	return nil
}

func (m *HttpConnectionManager) GetNormalizePath() *types.BoolValue {
	if m != nil {
		return m.NormalizePath
	}
	return nil
}

func (m *HttpConnectionManager) GetMergeSlashes() bool {
	if m != nil {
		return m.MergeSlashes
	}
	return false
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*HttpConnectionManager) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*HttpConnectionManager_Rds)(nil),
		(*HttpConnectionManager_RouteConfig)(nil),
		(*HttpConnectionManager_ScopedRoutes)(nil),
	}
}

// [#next-free-field: 9]
type HttpConnectionManager_Tracing struct {
	// Target percentage of requests managed by this HTTP connection manager that will be force
	// traced if the :ref:`x-client-trace-id <config_http_conn_man_headers_x-client-trace-id>`
	// header is set. This field is a direct analog for the runtime variable
	// 'tracing.client_sampling' in the :ref:`HTTP Connection Manager
	// <config_http_conn_man_runtime>`.
	// Default: 100%
	ClientSampling *v33.Percent `protobuf:"bytes,3,opt,name=client_sampling,json=clientSampling,proto3" json:"client_sampling,omitempty"`
	// Target percentage of requests managed by this HTTP connection manager that will be randomly
	// selected for trace generation, if not requested by the client or not forced. This field is
	// a direct analog for the runtime variable 'tracing.random_sampling' in the
	// :ref:`HTTP Connection Manager <config_http_conn_man_runtime>`.
	// Default: 100%
	RandomSampling *v33.Percent `protobuf:"bytes,4,opt,name=random_sampling,json=randomSampling,proto3" json:"random_sampling,omitempty"`
	// Target percentage of requests managed by this HTTP connection manager that will be traced
	// after all other sampling checks have been applied (client-directed, force tracing, random
	// sampling). This field functions as an upper limit on the total configured sampling rate. For
	// instance, setting client_sampling to 100% but overall_sampling to 1% will result in only 1%
	// of client requests with the appropriate headers to be force traced. This field is a direct
	// analog for the runtime variable 'tracing.global_enabled' in the
	// :ref:`HTTP Connection Manager <config_http_conn_man_runtime>`.
	// Default: 100%
	OverallSampling *v33.Percent `protobuf:"bytes,5,opt,name=overall_sampling,json=overallSampling,proto3" json:"overall_sampling,omitempty"`
	// Whether to annotate spans with additional data. If true, spans will include logs for stream
	// events.
	Verbose bool `protobuf:"varint,6,opt,name=verbose,proto3" json:"verbose,omitempty"`
	// Maximum length of the request path to extract and include in the HttpUrl tag. Used to
	// truncate lengthy request paths to meet the needs of a tracing backend.
	// Default: 256
	MaxPathTagLength *types.UInt32Value `protobuf:"bytes,7,opt,name=max_path_tag_length,json=maxPathTagLength,proto3" json:"max_path_tag_length,omitempty"`
	// A list of custom tags with unique tag name to create tags for the active span.
	CustomTags           []*v34.CustomTag `protobuf:"bytes,8,rep,name=custom_tags,json=customTags,proto3" json:"custom_tags,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *HttpConnectionManager_Tracing) Reset()         { *m = HttpConnectionManager_Tracing{} }
func (m *HttpConnectionManager_Tracing) String() string { return proto.CompactTextString(m) }
func (*HttpConnectionManager_Tracing) ProtoMessage()    {}
func (*HttpConnectionManager_Tracing) Descriptor() ([]byte, []int) {
	return fileDescriptor_7f8b1b876d9c097a, []int{0, 0}
}
func (m *HttpConnectionManager_Tracing) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HttpConnectionManager_Tracing) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HttpConnectionManager_Tracing.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HttpConnectionManager_Tracing) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HttpConnectionManager_Tracing.Merge(m, src)
}
func (m *HttpConnectionManager_Tracing) XXX_Size() int {
	return m.Size()
}
func (m *HttpConnectionManager_Tracing) XXX_DiscardUnknown() {
	xxx_messageInfo_HttpConnectionManager_Tracing.DiscardUnknown(m)
}

var xxx_messageInfo_HttpConnectionManager_Tracing proto.InternalMessageInfo

func (m *HttpConnectionManager_Tracing) GetClientSampling() *v33.Percent {
	if m != nil {
		return m.ClientSampling
	}
	return nil
}

func (m *HttpConnectionManager_Tracing) GetRandomSampling() *v33.Percent {
	if m != nil {
		return m.RandomSampling
	}
	return nil
}

func (m *HttpConnectionManager_Tracing) GetOverallSampling() *v33.Percent {
	if m != nil {
		return m.OverallSampling
	}
	return nil
}

func (m *HttpConnectionManager_Tracing) GetVerbose() bool {
	if m != nil {
		return m.Verbose
	}
	return false
}

func (m *HttpConnectionManager_Tracing) GetMaxPathTagLength() *types.UInt32Value {
	if m != nil {
		return m.MaxPathTagLength
	}
	return nil
}

func (m *HttpConnectionManager_Tracing) GetCustomTags() []*v34.CustomTag {
	if m != nil {
		return m.CustomTags
	}
	return nil
}

type HttpConnectionManager_InternalAddressConfig struct {
	// Whether unix socket addresses should be considered internal.
	UnixSockets          bool     `protobuf:"varint,1,opt,name=unix_sockets,json=unixSockets,proto3" json:"unix_sockets,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HttpConnectionManager_InternalAddressConfig) Reset() {
	*m = HttpConnectionManager_InternalAddressConfig{}
}
func (m *HttpConnectionManager_InternalAddressConfig) String() string {
	return proto.CompactTextString(m)
}
func (*HttpConnectionManager_InternalAddressConfig) ProtoMessage() {}
func (*HttpConnectionManager_InternalAddressConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_7f8b1b876d9c097a, []int{0, 1}
}
func (m *HttpConnectionManager_InternalAddressConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HttpConnectionManager_InternalAddressConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HttpConnectionManager_InternalAddressConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HttpConnectionManager_InternalAddressConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HttpConnectionManager_InternalAddressConfig.Merge(m, src)
}
func (m *HttpConnectionManager_InternalAddressConfig) XXX_Size() int {
	return m.Size()
}
func (m *HttpConnectionManager_InternalAddressConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_HttpConnectionManager_InternalAddressConfig.DiscardUnknown(m)
}

var xxx_messageInfo_HttpConnectionManager_InternalAddressConfig proto.InternalMessageInfo

func (m *HttpConnectionManager_InternalAddressConfig) GetUnixSockets() bool {
	if m != nil {
		return m.UnixSockets
	}
	return false
}

// [#next-free-field: 7]
type HttpConnectionManager_SetCurrentClientCertDetails struct {
	// Whether to forward the subject of the client cert. Defaults to false.
	Subject *types.BoolValue `protobuf:"bytes,1,opt,name=subject,proto3" json:"subject,omitempty"`
	// Whether to forward the entire client cert in URL encoded PEM format. This will appear in the
	// XFCC header comma separated from other values with the value Cert="PEM".
	// Defaults to false.
	Cert bool `protobuf:"varint,3,opt,name=cert,proto3" json:"cert,omitempty"`
	// Whether to forward the entire client cert chain (including the leaf cert) in URL encoded PEM
	// format. This will appear in the XFCC header comma separated from other values with the value
	// Chain="PEM".
	// Defaults to false.
	Chain bool `protobuf:"varint,6,opt,name=chain,proto3" json:"chain,omitempty"`
	// Whether to forward the DNS type Subject Alternative Names of the client cert.
	// Defaults to false.
	Dns bool `protobuf:"varint,4,opt,name=dns,proto3" json:"dns,omitempty"`
	// Whether to forward the URI type Subject Alternative Name of the client cert. Defaults to
	// false.
	Uri                  bool     `protobuf:"varint,5,opt,name=uri,proto3" json:"uri,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HttpConnectionManager_SetCurrentClientCertDetails) Reset() {
	*m = HttpConnectionManager_SetCurrentClientCertDetails{}
}
func (m *HttpConnectionManager_SetCurrentClientCertDetails) String() string {
	return proto.CompactTextString(m)
}
func (*HttpConnectionManager_SetCurrentClientCertDetails) ProtoMessage() {}
func (*HttpConnectionManager_SetCurrentClientCertDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_7f8b1b876d9c097a, []int{0, 2}
}
func (m *HttpConnectionManager_SetCurrentClientCertDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HttpConnectionManager_SetCurrentClientCertDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HttpConnectionManager_SetCurrentClientCertDetails.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HttpConnectionManager_SetCurrentClientCertDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HttpConnectionManager_SetCurrentClientCertDetails.Merge(m, src)
}
func (m *HttpConnectionManager_SetCurrentClientCertDetails) XXX_Size() int {
	return m.Size()
}
func (m *HttpConnectionManager_SetCurrentClientCertDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_HttpConnectionManager_SetCurrentClientCertDetails.DiscardUnknown(m)
}

var xxx_messageInfo_HttpConnectionManager_SetCurrentClientCertDetails proto.InternalMessageInfo

func (m *HttpConnectionManager_SetCurrentClientCertDetails) GetSubject() *types.BoolValue {
	if m != nil {
		return m.Subject
	}
	return nil
}

func (m *HttpConnectionManager_SetCurrentClientCertDetails) GetCert() bool {
	if m != nil {
		return m.Cert
	}
	return false
}

func (m *HttpConnectionManager_SetCurrentClientCertDetails) GetChain() bool {
	if m != nil {
		return m.Chain
	}
	return false
}

func (m *HttpConnectionManager_SetCurrentClientCertDetails) GetDns() bool {
	if m != nil {
		return m.Dns
	}
	return false
}

func (m *HttpConnectionManager_SetCurrentClientCertDetails) GetUri() bool {
	if m != nil {
		return m.Uri
	}
	return false
}

// The configuration for HTTP upgrades.
// For each upgrade type desired, an UpgradeConfig must be added.
//
// .. warning::
//
//    The current implementation of upgrade headers does not handle
//    multi-valued upgrade headers. Support for multi-valued headers may be
//    added in the future if needed.
//
// .. warning::
//    The current implementation of upgrade headers does not work with HTTP/2
//    upstreams.
type HttpConnectionManager_UpgradeConfig struct {
	// The case-insensitive name of this upgrade, e.g. "websocket".
	// For each upgrade type present in upgrade_configs, requests with
	// Upgrade: [upgrade_type]
	// will be proxied upstream.
	UpgradeType string `protobuf:"bytes,1,opt,name=upgrade_type,json=upgradeType,proto3" json:"upgrade_type,omitempty"`
	// If present, this represents the filter chain which will be created for
	// this type of upgrade. If no filters are present, the filter chain for
	// HTTP connections will be used for this upgrade type.
	Filters []*HttpFilter `protobuf:"bytes,2,rep,name=filters,proto3" json:"filters,omitempty"`
	// Determines if upgrades are enabled or disabled by default. Defaults to true.
	// This can be overridden on a per-route basis with :ref:`cluster
	// <envoy_api_field_config.route.v3.RouteAction.upgrade_configs>` as documented in the
	// :ref:`upgrade documentation <arch_overview_websocket>`.
	Enabled              *types.BoolValue `protobuf:"bytes,3,opt,name=enabled,proto3" json:"enabled,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *HttpConnectionManager_UpgradeConfig) Reset()         { *m = HttpConnectionManager_UpgradeConfig{} }
func (m *HttpConnectionManager_UpgradeConfig) String() string { return proto.CompactTextString(m) }
func (*HttpConnectionManager_UpgradeConfig) ProtoMessage()    {}
func (*HttpConnectionManager_UpgradeConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_7f8b1b876d9c097a, []int{0, 3}
}
func (m *HttpConnectionManager_UpgradeConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HttpConnectionManager_UpgradeConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HttpConnectionManager_UpgradeConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HttpConnectionManager_UpgradeConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HttpConnectionManager_UpgradeConfig.Merge(m, src)
}
func (m *HttpConnectionManager_UpgradeConfig) XXX_Size() int {
	return m.Size()
}
func (m *HttpConnectionManager_UpgradeConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_HttpConnectionManager_UpgradeConfig.DiscardUnknown(m)
}

var xxx_messageInfo_HttpConnectionManager_UpgradeConfig proto.InternalMessageInfo

func (m *HttpConnectionManager_UpgradeConfig) GetUpgradeType() string {
	if m != nil {
		return m.UpgradeType
	}
	return ""
}

func (m *HttpConnectionManager_UpgradeConfig) GetFilters() []*HttpFilter {
	if m != nil {
		return m.Filters
	}
	return nil
}

func (m *HttpConnectionManager_UpgradeConfig) GetEnabled() *types.BoolValue {
	if m != nil {
		return m.Enabled
	}
	return nil
}

type Rds struct {
	// Configuration source specifier for RDS.
	ConfigSource *v31.ConfigSource `protobuf:"bytes,1,opt,name=config_source,json=configSource,proto3" json:"config_source,omitempty"`
	// The name of the route configuration. This name will be passed to the RDS
	// API. This allows an Envoy configuration with multiple HTTP listeners (and
	// associated HTTP connection manager filters) to use different route
	// configurations.
	RouteConfigName      string   `protobuf:"bytes,2,opt,name=route_config_name,json=routeConfigName,proto3" json:"route_config_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Rds) Reset()         { *m = Rds{} }
func (m *Rds) String() string { return proto.CompactTextString(m) }
func (*Rds) ProtoMessage()    {}
func (*Rds) Descriptor() ([]byte, []int) {
	return fileDescriptor_7f8b1b876d9c097a, []int{1}
}
func (m *Rds) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Rds) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Rds.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Rds) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Rds.Merge(m, src)
}
func (m *Rds) XXX_Size() int {
	return m.Size()
}
func (m *Rds) XXX_DiscardUnknown() {
	xxx_messageInfo_Rds.DiscardUnknown(m)
}

var xxx_messageInfo_Rds proto.InternalMessageInfo

func (m *Rds) GetConfigSource() *v31.ConfigSource {
	if m != nil {
		return m.ConfigSource
	}
	return nil
}

func (m *Rds) GetRouteConfigName() string {
	if m != nil {
		return m.RouteConfigName
	}
	return ""
}

// This message is used to work around the limitations with 'oneof' and repeated fields.
type ScopedRouteConfigurationsList struct {
	ScopedRouteConfigurations []*v3.ScopedRouteConfiguration `protobuf:"bytes,1,rep,name=scoped_route_configurations,json=scopedRouteConfigurations,proto3" json:"scoped_route_configurations,omitempty"`
	XXX_NoUnkeyedLiteral      struct{}                       `json:"-"`
	XXX_unrecognized          []byte                         `json:"-"`
	XXX_sizecache             int32                          `json:"-"`
}

func (m *ScopedRouteConfigurationsList) Reset()         { *m = ScopedRouteConfigurationsList{} }
func (m *ScopedRouteConfigurationsList) String() string { return proto.CompactTextString(m) }
func (*ScopedRouteConfigurationsList) ProtoMessage()    {}
func (*ScopedRouteConfigurationsList) Descriptor() ([]byte, []int) {
	return fileDescriptor_7f8b1b876d9c097a, []int{2}
}
func (m *ScopedRouteConfigurationsList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScopedRouteConfigurationsList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScopedRouteConfigurationsList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScopedRouteConfigurationsList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScopedRouteConfigurationsList.Merge(m, src)
}
func (m *ScopedRouteConfigurationsList) XXX_Size() int {
	return m.Size()
}
func (m *ScopedRouteConfigurationsList) XXX_DiscardUnknown() {
	xxx_messageInfo_ScopedRouteConfigurationsList.DiscardUnknown(m)
}

var xxx_messageInfo_ScopedRouteConfigurationsList proto.InternalMessageInfo

func (m *ScopedRouteConfigurationsList) GetScopedRouteConfigurations() []*v3.ScopedRouteConfiguration {
	if m != nil {
		return m.ScopedRouteConfigurations
	}
	return nil
}

// [#next-free-field: 6]
type ScopedRoutes struct {
	// The name assigned to the scoped routing configuration.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The algorithm to use for constructing a scope key for each request.
	ScopeKeyBuilder *ScopedRoutes_ScopeKeyBuilder `protobuf:"bytes,2,opt,name=scope_key_builder,json=scopeKeyBuilder,proto3" json:"scope_key_builder,omitempty"`
	// Configuration source specifier for RDS.
	// This config source is used to subscribe to RouteConfiguration resources specified in
	// ScopedRouteConfiguration messages.
	RdsConfigSource *v31.ConfigSource `protobuf:"bytes,3,opt,name=rds_config_source,json=rdsConfigSource,proto3" json:"rds_config_source,omitempty"`
	// Types that are valid to be assigned to ConfigSpecifier:
	//	*ScopedRoutes_ScopedRouteConfigurationsList
	//	*ScopedRoutes_ScopedRds
	ConfigSpecifier      isScopedRoutes_ConfigSpecifier `protobuf_oneof:"config_specifier"`
	XXX_NoUnkeyedLiteral struct{}                       `json:"-"`
	XXX_unrecognized     []byte                         `json:"-"`
	XXX_sizecache        int32                          `json:"-"`
}

func (m *ScopedRoutes) Reset()         { *m = ScopedRoutes{} }
func (m *ScopedRoutes) String() string { return proto.CompactTextString(m) }
func (*ScopedRoutes) ProtoMessage()    {}
func (*ScopedRoutes) Descriptor() ([]byte, []int) {
	return fileDescriptor_7f8b1b876d9c097a, []int{3}
}
func (m *ScopedRoutes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScopedRoutes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScopedRoutes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScopedRoutes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScopedRoutes.Merge(m, src)
}
func (m *ScopedRoutes) XXX_Size() int {
	return m.Size()
}
func (m *ScopedRoutes) XXX_DiscardUnknown() {
	xxx_messageInfo_ScopedRoutes.DiscardUnknown(m)
}

var xxx_messageInfo_ScopedRoutes proto.InternalMessageInfo

type isScopedRoutes_ConfigSpecifier interface {
	isScopedRoutes_ConfigSpecifier()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ScopedRoutes_ScopedRouteConfigurationsList struct {
	ScopedRouteConfigurationsList *ScopedRouteConfigurationsList `protobuf:"bytes,4,opt,name=scoped_route_configurations_list,json=scopedRouteConfigurationsList,proto3,oneof" json:"scoped_route_configurations_list,omitempty"`
}
type ScopedRoutes_ScopedRds struct {
	ScopedRds *ScopedRds `protobuf:"bytes,5,opt,name=scoped_rds,json=scopedRds,proto3,oneof" json:"scoped_rds,omitempty"`
}

func (*ScopedRoutes_ScopedRouteConfigurationsList) isScopedRoutes_ConfigSpecifier() {}
func (*ScopedRoutes_ScopedRds) isScopedRoutes_ConfigSpecifier()                     {}

func (m *ScopedRoutes) GetConfigSpecifier() isScopedRoutes_ConfigSpecifier {
	if m != nil {
		return m.ConfigSpecifier
	}
	return nil
}

func (m *ScopedRoutes) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ScopedRoutes) GetScopeKeyBuilder() *ScopedRoutes_ScopeKeyBuilder {
	if m != nil {
		return m.ScopeKeyBuilder
	}
	return nil
}

func (m *ScopedRoutes) GetRdsConfigSource() *v31.ConfigSource {
	if m != nil {
		return m.RdsConfigSource
	}
	return nil
}

func (m *ScopedRoutes) GetScopedRouteConfigurationsList() *ScopedRouteConfigurationsList {
	if x, ok := m.GetConfigSpecifier().(*ScopedRoutes_ScopedRouteConfigurationsList); ok {
		return x.ScopedRouteConfigurationsList
	}
	return nil
}

func (m *ScopedRoutes) GetScopedRds() *ScopedRds {
	if x, ok := m.GetConfigSpecifier().(*ScopedRoutes_ScopedRds); ok {
		return x.ScopedRds
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ScopedRoutes) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ScopedRoutes_ScopedRouteConfigurationsList)(nil),
		(*ScopedRoutes_ScopedRds)(nil),
	}
}

// Specifies the mechanism for constructing "scope keys" based on HTTP request attributes. These
// keys are matched against a set of :ref:`Key<envoy_api_msg_config.route.v3.ScopedRouteConfiguration.Key>`
// objects assembled from :ref:`ScopedRouteConfiguration<envoy_api_msg_config.route.v3.ScopedRouteConfiguration>`
// messages distributed via SRDS (the Scoped Route Discovery Service) or assigned statically via
// :ref:`scoped_route_configurations_list<envoy_api_field_extensions.filters.network.http_connection_manager.v3.ScopedRoutes.scoped_route_configurations_list>`.
//
// Upon receiving a request's headers, the Router will build a key using the algorithm specified
// by this message. This key will be used to look up the routing table (i.e., the
// :ref:`RouteConfiguration<envoy_api_msg_config.route.v3.RouteConfiguration>`) to use for the request.
type ScopedRoutes_ScopeKeyBuilder struct {
	// The final scope key consists of the ordered union of these fragments.
	Fragments            []*ScopedRoutes_ScopeKeyBuilder_FragmentBuilder `protobuf:"bytes,1,rep,name=fragments,proto3" json:"fragments,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                        `json:"-"`
	XXX_unrecognized     []byte                                          `json:"-"`
	XXX_sizecache        int32                                           `json:"-"`
}

func (m *ScopedRoutes_ScopeKeyBuilder) Reset()         { *m = ScopedRoutes_ScopeKeyBuilder{} }
func (m *ScopedRoutes_ScopeKeyBuilder) String() string { return proto.CompactTextString(m) }
func (*ScopedRoutes_ScopeKeyBuilder) ProtoMessage()    {}
func (*ScopedRoutes_ScopeKeyBuilder) Descriptor() ([]byte, []int) {
	return fileDescriptor_7f8b1b876d9c097a, []int{3, 0}
}
func (m *ScopedRoutes_ScopeKeyBuilder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScopedRoutes_ScopeKeyBuilder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScopedRoutes_ScopeKeyBuilder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScopedRoutes_ScopeKeyBuilder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScopedRoutes_ScopeKeyBuilder.Merge(m, src)
}
func (m *ScopedRoutes_ScopeKeyBuilder) XXX_Size() int {
	return m.Size()
}
func (m *ScopedRoutes_ScopeKeyBuilder) XXX_DiscardUnknown() {
	xxx_messageInfo_ScopedRoutes_ScopeKeyBuilder.DiscardUnknown(m)
}

var xxx_messageInfo_ScopedRoutes_ScopeKeyBuilder proto.InternalMessageInfo

func (m *ScopedRoutes_ScopeKeyBuilder) GetFragments() []*ScopedRoutes_ScopeKeyBuilder_FragmentBuilder {
	if m != nil {
		return m.Fragments
	}
	return nil
}

// Specifies the mechanism for constructing key fragments which are composed into scope keys.
type ScopedRoutes_ScopeKeyBuilder_FragmentBuilder struct {
	// Types that are valid to be assigned to Type:
	//	*ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_
	Type                 isScopedRoutes_ScopeKeyBuilder_FragmentBuilder_Type `protobuf_oneof:"type"`
	XXX_NoUnkeyedLiteral struct{}                                            `json:"-"`
	XXX_unrecognized     []byte                                              `json:"-"`
	XXX_sizecache        int32                                               `json:"-"`
}

func (m *ScopedRoutes_ScopeKeyBuilder_FragmentBuilder) Reset() {
	*m = ScopedRoutes_ScopeKeyBuilder_FragmentBuilder{}
}
func (m *ScopedRoutes_ScopeKeyBuilder_FragmentBuilder) String() string {
	return proto.CompactTextString(m)
}
func (*ScopedRoutes_ScopeKeyBuilder_FragmentBuilder) ProtoMessage() {}
func (*ScopedRoutes_ScopeKeyBuilder_FragmentBuilder) Descriptor() ([]byte, []int) {
	return fileDescriptor_7f8b1b876d9c097a, []int{3, 0, 0}
}
func (m *ScopedRoutes_ScopeKeyBuilder_FragmentBuilder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScopedRoutes_ScopeKeyBuilder_FragmentBuilder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScopedRoutes_ScopeKeyBuilder_FragmentBuilder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScopedRoutes_ScopeKeyBuilder_FragmentBuilder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScopedRoutes_ScopeKeyBuilder_FragmentBuilder.Merge(m, src)
}
func (m *ScopedRoutes_ScopeKeyBuilder_FragmentBuilder) XXX_Size() int {
	return m.Size()
}
func (m *ScopedRoutes_ScopeKeyBuilder_FragmentBuilder) XXX_DiscardUnknown() {
	xxx_messageInfo_ScopedRoutes_ScopeKeyBuilder_FragmentBuilder.DiscardUnknown(m)
}

var xxx_messageInfo_ScopedRoutes_ScopeKeyBuilder_FragmentBuilder proto.InternalMessageInfo

type isScopedRoutes_ScopeKeyBuilder_FragmentBuilder_Type interface {
	isScopedRoutes_ScopeKeyBuilder_FragmentBuilder_Type()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_ struct {
	HeaderValueExtractor *ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor `protobuf:"bytes,1,opt,name=header_value_extractor,json=headerValueExtractor,proto3,oneof" json:"header_value_extractor,omitempty"`
}

func (*ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_) isScopedRoutes_ScopeKeyBuilder_FragmentBuilder_Type() {
}

func (m *ScopedRoutes_ScopeKeyBuilder_FragmentBuilder) GetType() isScopedRoutes_ScopeKeyBuilder_FragmentBuilder_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *ScopedRoutes_ScopeKeyBuilder_FragmentBuilder) GetHeaderValueExtractor() *ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor {
	if x, ok := m.GetType().(*ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_); ok {
		return x.HeaderValueExtractor
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ScopedRoutes_ScopeKeyBuilder_FragmentBuilder) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_)(nil),
	}
}

// Specifies how the value of a header should be extracted.
// The following example maps the structure of a header to the fields in this message.
//
// .. code::
//
//              <0> <1>   <-- index
//    X-Header: a=b;c=d
//    |         || |
//    |         || \----> <element_separator>
//    |         ||
//    |         |\----> <element.separator>
//    |         |
//    |         \----> <element.key>
//    |
//    \----> <name>
//
//    Each 'a=b' key-value pair constitutes an 'element' of the header field.
type ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor struct {
	// The name of the header field to extract the value from.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The element separator (e.g., ';' separates 'a;b;c;d').
	// Default: empty string. This causes the entirety of the header field to be extracted.
	// If this field is set to an empty string and 'index' is used in the oneof below, 'index'
	// must be set to 0.
	ElementSeparator string `protobuf:"bytes,2,opt,name=element_separator,json=elementSeparator,proto3" json:"element_separator,omitempty"`
	// Types that are valid to be assigned to ExtractType:
	//	*ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_Index
	//	*ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_Element
	ExtractType          isScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_ExtractType `protobuf_oneof:"extract_type"`
	XXX_NoUnkeyedLiteral struct{}                                                                        `json:"-"`
	XXX_unrecognized     []byte                                                                          `json:"-"`
	XXX_sizecache        int32                                                                           `json:"-"`
}

func (m *ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor) Reset() {
	*m = ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor{}
}
func (m *ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor) String() string {
	return proto.CompactTextString(m)
}
func (*ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor) ProtoMessage() {}
func (*ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor) Descriptor() ([]byte, []int) {
	return fileDescriptor_7f8b1b876d9c097a, []int{3, 0, 0, 0}
}
func (m *ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor.Merge(m, src)
}
func (m *ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor) XXX_Size() int {
	return m.Size()
}
func (m *ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor) XXX_DiscardUnknown() {
	xxx_messageInfo_ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor.DiscardUnknown(m)
}

var xxx_messageInfo_ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor proto.InternalMessageInfo

type isScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_ExtractType interface {
	isScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_ExtractType()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_Index struct {
	Index uint32 `protobuf:"varint,3,opt,name=index,proto3,oneof" json:"index,omitempty"`
}
type ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_Element struct {
	Element *ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement `protobuf:"bytes,4,opt,name=element,proto3,oneof" json:"element,omitempty"`
}

func (*ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_Index) isScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_ExtractType() {
}
func (*ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_Element) isScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_ExtractType() {
}

func (m *ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor) GetExtractType() isScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_ExtractType {
	if m != nil {
		return m.ExtractType
	}
	return nil
}

func (m *ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor) GetElementSeparator() string {
	if m != nil {
		return m.ElementSeparator
	}
	return ""
}

func (m *ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor) GetIndex() uint32 {
	if x, ok := m.GetExtractType().(*ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_Index); ok {
		return x.Index
	}
	return 0
}

func (m *ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor) GetElement() *ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement {
	if x, ok := m.GetExtractType().(*ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_Element); ok {
		return x.Element
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_Index)(nil),
		(*ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_Element)(nil),
	}
}

// Specifies a header field's key value pair to match on.
type ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement struct {
	// The separator between key and value (e.g., '=' separates 'k=v;...').
	// If an element is an empty string, the element is ignored.
	// If an element contains no separator, the whole element is parsed as key and the
	// fragment value is an empty string.
	// If there are multiple values for a matched key, the first value is returned.
	Separator string `protobuf:"bytes,1,opt,name=separator,proto3" json:"separator,omitempty"`
	// The key to match on.
	Key                  string   `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement) Reset() {
	*m = ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement{}
}
func (m *ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement) String() string {
	return proto.CompactTextString(m)
}
func (*ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement) ProtoMessage() {}
func (*ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement) Descriptor() ([]byte, []int) {
	return fileDescriptor_7f8b1b876d9c097a, []int{3, 0, 0, 0, 0}
}
func (m *ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement.Merge(m, src)
}
func (m *ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement) XXX_Size() int {
	return m.Size()
}
func (m *ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement) XXX_DiscardUnknown() {
	xxx_messageInfo_ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement.DiscardUnknown(m)
}

var xxx_messageInfo_ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement proto.InternalMessageInfo

func (m *ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement) GetSeparator() string {
	if m != nil {
		return m.Separator
	}
	return ""
}

func (m *ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

type ScopedRds struct {
	// Configuration source specifier for scoped RDS.
	ScopedRdsConfigSource *v31.ConfigSource `protobuf:"bytes,1,opt,name=scoped_rds_config_source,json=scopedRdsConfigSource,proto3" json:"scoped_rds_config_source,omitempty"`
	XXX_NoUnkeyedLiteral  struct{}          `json:"-"`
	XXX_unrecognized      []byte            `json:"-"`
	XXX_sizecache         int32             `json:"-"`
}

func (m *ScopedRds) Reset()         { *m = ScopedRds{} }
func (m *ScopedRds) String() string { return proto.CompactTextString(m) }
func (*ScopedRds) ProtoMessage()    {}
func (*ScopedRds) Descriptor() ([]byte, []int) {
	return fileDescriptor_7f8b1b876d9c097a, []int{4}
}
func (m *ScopedRds) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScopedRds) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScopedRds.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScopedRds) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScopedRds.Merge(m, src)
}
func (m *ScopedRds) XXX_Size() int {
	return m.Size()
}
func (m *ScopedRds) XXX_DiscardUnknown() {
	xxx_messageInfo_ScopedRds.DiscardUnknown(m)
}

var xxx_messageInfo_ScopedRds proto.InternalMessageInfo

func (m *ScopedRds) GetScopedRdsConfigSource() *v31.ConfigSource {
	if m != nil {
		return m.ScopedRdsConfigSource
	}
	return nil
}

type HttpFilter struct {
	// The name of the filter to instantiate. The name must match a
	// :ref:`supported filter <config_http_filters>`.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Filter specific configuration which depends on the filter being instantiated. See the supported
	// filters for further documentation.
	//
	// Types that are valid to be assigned to ConfigType:
	//	*HttpFilter_TypedConfig
	ConfigType           isHttpFilter_ConfigType `protobuf_oneof:"config_type"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *HttpFilter) Reset()         { *m = HttpFilter{} }
func (m *HttpFilter) String() string { return proto.CompactTextString(m) }
func (*HttpFilter) ProtoMessage()    {}
func (*HttpFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_7f8b1b876d9c097a, []int{5}
}
func (m *HttpFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HttpFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HttpFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HttpFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HttpFilter.Merge(m, src)
}
func (m *HttpFilter) XXX_Size() int {
	return m.Size()
}
func (m *HttpFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_HttpFilter.DiscardUnknown(m)
}

var xxx_messageInfo_HttpFilter proto.InternalMessageInfo

type isHttpFilter_ConfigType interface {
	isHttpFilter_ConfigType()
	MarshalTo([]byte) (int, error)
	Size() int
}

type HttpFilter_TypedConfig struct {
	TypedConfig *types.Any `protobuf:"bytes,4,opt,name=typed_config,json=typedConfig,proto3,oneof" json:"typed_config,omitempty"`
}

func (*HttpFilter_TypedConfig) isHttpFilter_ConfigType() {}

func (m *HttpFilter) GetConfigType() isHttpFilter_ConfigType {
	if m != nil {
		return m.ConfigType
	}
	return nil
}

func (m *HttpFilter) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *HttpFilter) GetTypedConfig() *types.Any {
	if x, ok := m.GetConfigType().(*HttpFilter_TypedConfig); ok {
		return x.TypedConfig
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*HttpFilter) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*HttpFilter_TypedConfig)(nil),
	}
}

func init() {
	proto.RegisterEnum("envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager_CodecType", HttpConnectionManager_CodecType_name, HttpConnectionManager_CodecType_value)
	proto.RegisterEnum("envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager_ServerHeaderTransformation", HttpConnectionManager_ServerHeaderTransformation_name, HttpConnectionManager_ServerHeaderTransformation_value)
	proto.RegisterEnum("envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager_ForwardClientCertDetails", HttpConnectionManager_ForwardClientCertDetails_name, HttpConnectionManager_ForwardClientCertDetails_value)
	proto.RegisterEnum("envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager_Tracing_OperationName", HttpConnectionManager_Tracing_OperationName_name, HttpConnectionManager_Tracing_OperationName_value)
	proto.RegisterType((*HttpConnectionManager)(nil), "envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager")
	proto.RegisterType((*HttpConnectionManager_Tracing)(nil), "envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing")
	proto.RegisterType((*HttpConnectionManager_InternalAddressConfig)(nil), "envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig")
	proto.RegisterType((*HttpConnectionManager_SetCurrentClientCertDetails)(nil), "envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails")
	proto.RegisterType((*HttpConnectionManager_UpgradeConfig)(nil), "envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig")
	proto.RegisterType((*Rds)(nil), "envoy.extensions.filters.network.http_connection_manager.v3.Rds")
	proto.RegisterType((*ScopedRouteConfigurationsList)(nil), "envoy.extensions.filters.network.http_connection_manager.v3.ScopedRouteConfigurationsList")
	proto.RegisterType((*ScopedRoutes)(nil), "envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes")
	proto.RegisterType((*ScopedRoutes_ScopeKeyBuilder)(nil), "envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.ScopeKeyBuilder")
	proto.RegisterType((*ScopedRoutes_ScopeKeyBuilder_FragmentBuilder)(nil), "envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.ScopeKeyBuilder.FragmentBuilder")
	proto.RegisterType((*ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor)(nil), "envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.ScopeKeyBuilder.FragmentBuilder.HeaderValueExtractor")
	proto.RegisterType((*ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement)(nil), "envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.ScopeKeyBuilder.FragmentBuilder.HeaderValueExtractor.KvElement")
	proto.RegisterType((*ScopedRds)(nil), "envoy.extensions.filters.network.http_connection_manager.v3.ScopedRds")
	proto.RegisterType((*HttpFilter)(nil), "envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter")
}

func init() {
	proto.RegisterFile("envoy/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto", fileDescriptor_7f8b1b876d9c097a)
}

var fileDescriptor_7f8b1b876d9c097a = []byte{
	// 2549 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x59, 0xcb, 0x6f, 0x23, 0xc7,
	0xd1, 0xd7, 0x48, 0xd4, 0x8a, 0x2c, 0x52, 0xd2, 0xa8, 0xf5, 0xd8, 0x11, 0x25, 0xaf, 0x65, 0xd9,
	0x9f, 0x21, 0xfb, 0x0b, 0xa8, 0x5d, 0xc9, 0x30, 0x10, 0x26, 0x88, 0x4d, 0x6a, 0xb5, 0x4b, 0x6a,
	0xd7, 0x92, 0x32, 0xe4, 0xda, 0xde, 0x8d, 0x91, 0x71, 0x6b, 0xa6, 0x49, 0xce, 0x8a, 0x9c, 0x99,
	0x74, 0x37, 0x69, 0xc9, 0x87, 0x04, 0x30, 0x60, 0xc0, 0x49, 0x0e, 0x46, 0x72, 0x0a, 0x72, 0xca,
	0xc5, 0xd7, 0x9c, 0x92, 0x00, 0x41, 0xce, 0x01, 0x72, 0x74, 0x0e, 0x39, 0x04, 0xb9, 0x04, 0x3e,
	0x25, 0x7f, 0x41, 0x02, 0x9f, 0x82, 0x7e, 0x0c, 0x1f, 0x5a, 0x8a, 0x02, 0x2c, 0xc9, 0xbe, 0xf5,
	0x54, 0x57, 0xfd, 0xaa, 0xba, 0xba, 0xaa, 0xba, 0xba, 0x07, 0x1e, 0x93, 0xa0, 0x13, 0x9e, 0x6e,
	0x92, 0x13, 0x4e, 0x02, 0xe6, 0x87, 0x01, 0xdb, 0xac, 0xf9, 0x4d, 0x4e, 0x28, 0xdb, 0x0c, 0x08,
	0xff, 0x20, 0xa4, 0xc7, 0x9b, 0x0d, 0xce, 0x23, 0xc7, 0x0d, 0x83, 0x80, 0xb8, 0xdc, 0x0f, 0x03,
	0xa7, 0x85, 0x03, 0x5c, 0x27, 0x74, 0xb3, 0xb3, 0x7d, 0xde, 0x54, 0x2e, 0xa2, 0x21, 0x0f, 0xd1,
	0x77, 0x24, 0x74, 0xae, 0x07, 0x9d, 0xd3, 0xd0, 0x39, 0x0d, 0x9d, 0x3b, 0x4f, 0xbe, 0xb3, 0x9d,
	0x7d, 0x45, 0xd9, 0xe5, 0x86, 0x41, 0xcd, 0xaf, 0x6f, 0x62, 0xd7, 0x25, 0x8c, 0x35, 0xc3, 0xba,
	0xd0, 0xda, 0xfd, 0x50, 0x7a, 0xb2, 0x1b, 0x03, 0xac, 0x6e, 0x48, 0x89, 0xe0, 0x52, 0x9f, 0x0e,
	0x0b, 0xdb, 0xd4, 0x25, 0x9a, 0xf3, 0xc5, 0xa1, 0x9c, 0x72, 0xce, 0x0d, 0x9b, 0x9a, 0xe9, 0x85,
	0x01, 0x26, 0x1a, 0xb6, 0xb9, 0xe4, 0x92, 0x83, 0xa1, 0x1a, 0xbb, 0x2c, 0xcc, 0x0d, 0x23, 0xe2,
	0x39, 0xfd, 0x9c, 0x2f, 0x2b, 0x4e, 0x7e, 0x1a, 0x91, 0x4d, 0x4e, 0xb1, 0xeb, 0x07, 0x72, 0x09,
	0x6e, 0x9b, 0xf1, 0xb0, 0xe5, 0x70, 0x1c, 0xaf, 0x61, 0xa5, 0x8f, 0x4f, 0x98, 0x44, 0xa8, 0x4b,
	0x02, 0xae, 0x27, 0x97, 0xeb, 0x61, 0x58, 0x6f, 0x12, 0x65, 0xe8, 0x51, 0xbb, 0xb6, 0x89, 0x83,
	0x53, 0x3d, 0x75, 0xeb, 0xec, 0x94, 0xd7, 0xa6, 0x58, 0xf8, 0x52, 0xcf, 0xaf, 0x9e, 0x9d, 0x67,
	0x9c, 0xb6, 0x5d, 0x7e, 0x9e, 0xf4, 0x07, 0x14, 0x47, 0x91, 0xd8, 0x21, 0xed, 0x8a, 0xb6, 0x17,
	0xe1, 0x4d, 0x1c, 0x04, 0x21, 0x97, 0xa0, 0x6c, 0xb3, 0x43, 0xa8, 0xd8, 0x4a, 0x3f, 0xa8, 0x0f,
	0xba, 0xb4, 0x9f, 0xc7, 0x23, 0x11, 0x25, 0x6e, 0xbf, 0x15, 0x37, 0x3b, 0xb8, 0xe9, 0x7b, 0x58,
	0x78, 0x49, 0x0f, 0xd4, 0xc4, 0xfa, 0xbf, 0x5e, 0x82, 0xc5, 0x12, 0xe7, 0xd1, 0x4e, 0x37, 0x06,
	0xde, 0x52, 0x21, 0x80, 0x3e, 0x36, 0x00, 0xdc, 0xd0, 0x23, 0xae, 0x23, 0x7c, 0x62, 0x19, 0x6b,
	0xc6, 0xc6, 0xcc, 0xd6, 0x7b, 0xb9, 0x4b, 0x84, 0x54, 0x6e, 0xa8, 0xa2, 0xdc, 0x8e, 0x50, 0x52,
	0x3d, 0x8d, 0x48, 0x31, 0xf9, 0x65, 0x71, 0xf2, 0x23, 0x63, 0xdc, 0x34, 0xec, 0x94, 0x1b, 0x13,
	0xd1, 0x06, 0xa4, 0x19, 0xc7, 0xdc, 0x89, 0x28, 0xa9, 0xf9, 0x27, 0xd6, 0xf8, 0x9a, 0xb1, 0x91,
	0x2a, 0x4e, 0x7d, 0x59, 0x4c, 0xd0, 0xf1, 0x35, 0xc3, 0x06, 0x31, 0x77, 0x28, 0xa7, 0x50, 0x15,
	0x26, 0xa8, 0xc7, 0xac, 0x89, 0x35, 0x63, 0x23, 0xbd, 0xf5, 0xe6, 0xa5, 0x2c, 0xb5, 0x3d, 0x56,
	0x1a, 0xb3, 0x05, 0x1c, 0xda, 0x87, 0x8c, 0x8c, 0x27, 0x47, 0x05, 0x9b, 0x95, 0x90, 0xf0, 0xaf,
	0x68, 0x78, 0x45, 0xcc, 0xa9, 0x88, 0x13, 0x82, 0x62, 0xb0, 0x23, 0x89, 0x3a, 0x0e, 0x4a, 0x63,
	0x76, 0x9a, 0xf6, 0xa8, 0x28, 0x82, 0xe9, 0xfe, 0x30, 0x65, 0xd6, 0xf3, 0x12, 0xb0, 0x7c, 0x29,
	0x7b, 0x2b, 0x12, 0x51, 0x2a, 0x17, 0x86, 0x67, 0x58, 0xdf, 0x37, 0x7a, 0x0a, 0x19, 0x29, 0xaa,
	0xf1, 0xac, 0xc9, 0xb5, 0x89, 0x8d, 0xf4, 0xd6, 0xfd, 0x4b, 0x6f, 0xe5, 0x3d, 0xc9, 0x6e, 0xa7,
	0x1b, 0xdd, 0x31, 0x43, 0x6f, 0xc2, 0x0c, 0xf6, 0x3c, 0xa7, 0xcd, 0x08, 0x75, 0x70, 0x9d, 0x04,
	0xdc, 0xba, 0x21, 0x97, 0x97, 0xcd, 0xa9, 0x48, 0xcf, 0xc5, 0x91, 0x9e, 0x2b, 0x86, 0x61, 0xf3,
	0x6d, 0xdc, 0x6c, 0x13, 0x3b, 0x83, 0x3d, 0xef, 0x11, 0x23, 0xb4, 0x20, 0xf8, 0x11, 0x87, 0x29,
	0x9d, 0xa7, 0xd6, 0x94, 0x14, 0x7d, 0x72, 0x0d, 0x31, 0x57, 0x55, 0x1a, 0xec, 0x58, 0x15, 0x7a,
	0x0a, 0xab, 0x6e, 0xd8, 0x6a, 0x85, 0x81, 0x23, 0xb1, 0xe2, 0x8a, 0xe4, 0x84, 0x91, 0x4c, 0x29,
	0xeb, 0xc5, 0x61, 0xbb, 0x2e, 0xea, 0x57, 0xac, 0xe3, 0x50, 0x4b, 0x1c, 0x28, 0x01, 0x7b, 0x59,
	0xc1, 0x0d, 0x99, 0x42, 0x3f, 0x84, 0xc5, 0xe1, 0x4a, 0x92, 0x52, 0xc9, 0xab, 0xe7, 0x2b, 0xb9,
	0x73, 0x56, 0xcb, 0x7c, 0x63, 0x08, 0xfe, 0xfb, 0xb0, 0x24, 0xc8, 0x5b, 0xcf, 0x2a, 0x48, 0x5d,
	0xa4, 0x60, 0xeb, 0xac, 0x82, 0x85, 0xc6, 0x10, 0x2a, 0x7a, 0x1e, 0xd2, 0x8c, 0xd0, 0x0e, 0xa1,
	0x4e, 0x80, 0x5b, 0xc4, 0x02, 0x91, 0x93, 0x36, 0x28, 0xd2, 0x3e, 0x6e, 0x11, 0xf4, 0x47, 0x03,
	0x56, 0x35, 0x47, 0x83, 0x60, 0x8f, 0x50, 0x87, 0x53, 0x1c, 0xb0, 0x5a, 0x48, 0x5b, 0x32, 0x29,
	0xac, 0x75, 0x59, 0x4e, 0x5a, 0xd7, 0xb0, 0xb5, 0x15, 0xa9, 0xb6, 0x24, 0xb5, 0x56, 0x07, 0x94,
	0xf6, 0xd5, 0x97, 0x2c, 0x3b, 0x97, 0x0b, 0xbd, 0x07, 0x4b, 0x2d, 0x7c, 0xe2, 0x50, 0xf2, 0xa3,
	0x36, 0x61, 0x5c, 0xdb, 0xcf, 0x9c, 0xe3, 0x23, 0xeb, 0x39, 0xe9, 0xbe, 0xd5, 0x67, 0x42, 0xf9,
	0x51, 0x39, 0xe0, 0xdb, 0x5b, 0x32, 0x98, 0x8b, 0xa9, 0x2f, 0x8b, 0x37, 0x5e, 0x4d, 0x58, 0xef,
	0xaf, 0x8d, 0xd9, 0xf3, 0x2d, 0x7c, 0x62, 0x2b, 0x14, 0xa5, 0x88, 0x3d, 0x38, 0x42, 0x65, 0x98,
	0x67, 0x9c, 0x12, 0xdc, 0x72, 0x7c, 0xaf, 0x49, 0x1c, 0xee, 0xb7, 0x48, 0xd8, 0xe6, 0x96, 0x25,
	0xa1, 0x97, 0x9f, 0x81, 0xbe, 0xab, 0xab, 0x88, 0x3d, 0xa7, 0xa4, 0xca, 0x5e, 0x93, 0x54, 0x95,
	0x0c, 0x2a, 0xc2, 0x6c, 0x6c, 0x64, 0x0c, 0xb3, 0x7a, 0x11, 0xcc, 0x8c, 0x96, 0x88, 0x31, 0xbe,
	0x07, 0xd3, 0x1e, 0xc5, 0x7e, 0xd0, 0x45, 0xc8, 0x5c, 0x84, 0x90, 0x91, 0xfc, 0xb1, 0xfc, 0x5b,
	0xb0, 0xe8, 0x91, 0x26, 0x3e, 0x25, 0x9e, 0xe3, 0x36, 0x43, 0xd6, 0x5b, 0x50, 0xf6, 0x22, 0x9c,
	0x79, 0x2d, 0xb7, 0x23, 0xc4, 0x62, 0xb8, 0x1d, 0x00, 0xd5, 0x5c, 0x38, 0xcd, 0xb0, 0x6e, 0x4d,
	0xcb, 0x42, 0xf5, 0xd2, 0x60, 0xb8, 0xf6, 0x9a, 0x8f, 0xce, 0x76, 0xae, 0x20, 0x3f, 0x1e, 0x86,
	0x75, 0x3b, 0x85, 0xe3, 0x21, 0x2a, 0x01, 0x6a, 0x33, 0xe2, 0x50, 0xd2, 0x0a, 0x39, 0x71, 0xb0,
	0xe7, 0x51, 0xc2, 0x98, 0x35, 0x73, 0x61, 0x1d, 0x32, 0xdb, 0x8c, 0xd8, 0x52, 0xa8, 0xa0, 0x64,
	0xd0, 0x26, 0x2c, 0x9c, 0xd4, 0x6a, 0x4e, 0xd0, 0x6e, 0x39, 0x9c, 0xb6, 0x19, 0x27, 0x9e, 0xd3,
	0x08, 0x23, 0x66, 0xcd, 0xaf, 0x19, 0x1b, 0xd3, 0xf6, 0xdc, 0x49, 0xad, 0xb6, 0xdf, 0x6e, 0x55,
	0xd5, 0x4c, 0x29, 0x8c, 0x18, 0xfa, 0x8d, 0x01, 0x37, 0xfd, 0x80, 0x13, 0x1a, 0xe0, 0x66, 0xac,
	0x39, 0x3e, 0x38, 0x96, 0xa5, 0x01, 0x8d, 0x6b, 0x08, 0xf9, 0xb2, 0xd6, 0xa8, 0xcd, 0x56, 0x07,
	0x8d, 0xbd, 0xe8, 0x0f, 0x23, 0xa3, 0x97, 0x61, 0x96, 0x1d, 0xfb, 0x91, 0x23, 0x16, 0x26, 0x7a,
	0x8d, 0xc0, 0xb3, 0x16, 0xd7, 0x8c, 0x8d, 0xa4, 0x3d, 0x2d, 0xc8, 0xef, 0xd6, 0x6a, 0x05, 0x49,
	0x44, 0x26, 0x4c, 0x74, 0x7c, 0x6c, 0x2d, 0xc9, 0xdc, 0x16, 0x43, 0xb4, 0x07, 0xf3, 0x75, 0x12,
	0x10, 0x8a, 0x39, 0xe9, 0x66, 0x87, 0xef, 0x59, 0xb3, 0x17, 0x3a, 0x76, 0x2e, 0x16, 0xd3, 0xd9,
	0x50, 0xf6, 0xd0, 0x1b, 0xb0, 0x1a, 0x51, 0x22, 0xb3, 0xd0, 0x11, 0xae, 0x90, 0x0e, 0xeb, 0x03,
	0x5d, 0x93, 0x26, 0x2d, 0xc7, 0x3c, 0xbb, 0x9a, 0xa5, 0x07, 0xf0, 0x3b, 0x03, 0x56, 0x6a, 0x21,
	0xfd, 0x00, 0x53, 0x11, 0x79, 0x3e, 0x09, 0xb8, 0xe3, 0x12, 0xca, 0x1d, 0x8f, 0x70, 0xec, 0x37,
	0x99, 0x65, 0xca, 0x02, 0x73, 0x7c, 0x0d, 0xde, 0xbe, 0xa7, 0xb4, 0xee, 0x48, 0xa5, 0x3b, 0x84,
	0xf2, 0xbb, 0x4a, 0x65, 0x5f, 0x79, 0xb1, 0x6a, 0xe7, 0xf0, 0x08, 0xb3, 0x9f, 0x67, 0x84, 0x3b,
	0x6e, 0x9b, 0x52, 0x69, 0xf3, 0x10, 0xd3, 0xe7, 0xa4, 0x43, 0x83, 0x6b, 0xa9, 0x8d, 0x7c, 0x47,
	0x29, 0x7e, 0xc6, 0x32, 0x7b, 0x85, 0x9d, 0x3f, 0x89, 0xbe, 0x05, 0x28, 0xa2, 0xe1, 0xc9, 0xa9,
	0x73, 0xe7, 0xf6, 0x6d, 0xa1, 0x91, 0xfb, 0x41, 0x9b, 0x58, 0x48, 0x6e, 0x92, 0x29, 0x67, 0xee,
	0xdc, 0xbe, 0xbd, 0xa3, 0xe9, 0x88, 0xc0, 0x1d, 0x4a, 0xe4, 0xd6, 0x05, 0xdc, 0xf1, 0xa3, 0xce,
	0x6b, 0x67, 0x72, 0xd1, 0xc1, 0x4c, 0x91, 0x5b, 0x22, 0x00, 0x3d, 0x31, 0x7e, 0xdd, 0x5a, 0x90,
	0x60, 0xaf, 0x76, 0x05, 0xcb, 0x51, 0xe7, 0xb5, 0x81, 0x6c, 0x2c, 0x30, 0x41, 0x7a, 0x4b, 0x8a,
	0x94, 0xa3, 0xce, 0xeb, 0xe8, 0xa7, 0x06, 0xcc, 0xb6, 0xa3, 0x3a, 0xc5, 0x5e, 0xdc, 0x9c, 0x31,
	0xeb, 0xa6, 0x2c, 0x19, 0xef, 0x5f, 0x83, 0xef, 0x1e, 0x29, 0x4d, 0x3a, 0xb9, 0x66, 0xda, 0xfd,
	0x9f, 0x0c, 0x15, 0x60, 0x26, 0x10, 0x27, 0x48, 0xd3, 0xff, 0x90, 0x38, 0x11, 0xe6, 0x0d, 0xeb,
	0xd6, 0x85, 0x69, 0x31, 0xdd, 0x95, 0x38, 0xc4, 0xbc, 0x81, 0x5e, 0x84, 0xe9, 0x16, 0xa1, 0x75,
	0xe2, 0xb0, 0x26, 0x66, 0x0d, 0xc2, 0xac, 0x17, 0xa4, 0x47, 0x32, 0x92, 0x58, 0x51, 0xb4, 0xec,
	0xef, 0x13, 0x30, 0xa5, 0x9b, 0x17, 0xf4, 0x06, 0xcc, 0xea, 0xf0, 0x61, 0xb8, 0x15, 0x35, 0x45,
	0xc7, 0xa4, 0x7a, 0xdf, 0x25, 0xbd, 0x7c, 0xd1, 0xb8, 0x8b, 0x05, 0x1d, 0xaa, 0xcb, 0x8c, 0x3d,
	0xa3, 0xd8, 0x2b, 0x9a, 0x5b, 0x00, 0x50, 0x1c, 0x78, 0x61, 0xab, 0x07, 0x90, 0x18, 0x0d, 0xa0,
	0xd8, 0xbb, 0x00, 0x05, 0x30, 0xc3, 0x0e, 0xa1, 0xb8, 0xd9, 0xec, 0x21, 0x4c, 0x8e, 0x44, 0x98,
	0xd5, 0xfc, 0x5d, 0x08, 0x0b, 0xa6, 0x3a, 0x84, 0x1e, 0x85, 0x8c, 0xc8, 0x4e, 0x31, 0x69, 0xc7,
	0x9f, 0xe8, 0x01, 0x88, 0x03, 0x54, 0x3a, 0x53, 0xdc, 0xd3, 0x9c, 0x26, 0x09, 0xea, 0xbc, 0xa1,
	0x9b, 0xc2, 0x91, 0x87, 0xb0, 0x6d, 0xb6, 0xf0, 0x89, 0xf0, 0x69, 0x15, 0xd7, 0x1f, 0x4a, 0x29,
	0x54, 0x80, 0x74, 0xef, 0xca, 0x27, 0x3a, 0x2d, 0x11, 0x26, 0x6b, 0xfd, 0x46, 0xea, 0x4e, 0x50,
	0x18, 0xbb, 0x23, 0x39, 0xab, 0xb8, 0x6e, 0x83, 0x1b, 0x0f, 0xd9, 0xfa, 0x06, 0x4c, 0x1f, 0x44,
	0x44, 0x9d, 0x5e, 0xb2, 0xc9, 0x49, 0xc3, 0x54, 0x79, 0xff, 0xbe, 0xbd, 0x5b, 0xa9, 0x98, 0x63,
	0x08, 0xe0, 0xc6, 0xae, 0x1a, 0x1b, 0xf9, 0x1f, 0xfc, 0xfa, 0xcf, 0x9f, 0xdc, 0x7a, 0x1b, 0xaa,
	0x03, 0xe7, 0x96, 0x0a, 0xc0, 0x8b, 0xe3, 0x6f, 0x6b, 0x74, 0xcb, 0xba, 0x97, 0x48, 0x1a, 0xe6,
	0xf8, 0x5e, 0x22, 0x39, 0x6e, 0x4e, 0xd8, 0x33, 0x61, 0x6c, 0x90, 0x6c, 0xc4, 0x6c, 0xeb, 0x6c,
	0xd3, 0x52, 0x0b, 0xa9, 0x5c, 0x70, 0xf6, 0x33, 0x03, 0x16, 0x87, 0x1e, 0x13, 0xe8, 0x05, 0xc8,
	0xb4, 0x03, 0xff, 0xc4, 0x61, 0xa1, 0x7b, 0x4c, 0x38, 0x93, 0x17, 0xbd, 0xa4, 0x9d, 0x16, 0xb4,
	0x8a, 0x22, 0xe5, 0x7d, 0xb1, 0x1e, 0x0f, 0x8e, 0xae, 0x74, 0x3d, 0x43, 0xad, 0xc9, 0xfe, 0x6a,
	0x1c, 0x56, 0x46, 0x54, 0x29, 0xf4, 0x1a, 0x4c, 0xb1, 0xf6, 0xd1, 0x53, 0xe2, 0x72, 0x69, 0xe8,
	0xe8, 0x04, 0x8b, 0x59, 0x11, 0x82, 0x84, 0xa8, 0xb0, 0x32, 0x3d, 0x92, 0xb6, 0x1c, 0xa3, 0x05,
	0x98, 0x74, 0x1b, 0xd8, 0x0f, 0x74, 0xd8, 0xa9, 0x0f, 0x71, 0xea, 0x79, 0x01, 0x93, 0x69, 0x90,
	0xb4, 0xc5, 0x50, 0x50, 0xda, 0xd4, 0x97, 0x61, 0x9d, 0xb4, 0xc5, 0x30, 0x1f, 0x0a, 0x77, 0x3c,
	0x85, 0xc6, 0x95, 0xba, 0x63, 0xc4, 0xa2, 0xd5, 0x66, 0x67, 0x7f, 0x3b, 0x0e, 0xd3, 0x03, 0x45,
	0x48, 0x6e, 0x9d, 0xae, 0x7f, 0xdd, 0x3b, 0x7a, 0xca, 0x4e, 0x6b, 0x9a, 0xbc, 0x3d, 0x63, 0x98,
	0x8a, 0xaf, 0x7d, 0xe3, 0x57, 0x7b, 0xed, 0x8b, 0x71, 0xc5, 0x96, 0x90, 0x00, 0x1f, 0x35, 0x89,
	0xa7, 0xcb, 0xcf, 0xc8, 0x2d, 0xd1, 0xac, 0x79, 0x2c, 0x9c, 0xf8, 0x1e, 0x3c, 0xb9, 0x52, 0x27,
	0x0e, 0xb8, 0x67, 0xfd, 0x75, 0x48, 0x75, 0xdf, 0x16, 0x50, 0x12, 0x12, 0x85, 0x47, 0xd5, 0x03,
	0x73, 0x0c, 0xa5, 0x60, 0xb2, 0x54, 0xad, 0x1e, 0xde, 0x31, 0x8d, 0x78, 0xb8, 0x65, 0x8e, 0xc7,
	0xc3, 0x6d, 0x73, 0x62, 0xbd, 0x02, 0xd9, 0xf3, 0x2f, 0x11, 0x68, 0x1a, 0x52, 0x07, 0x6f, 0xef,
	0xda, 0xef, 0xd8, 0xe5, 0xea, 0xae, 0x39, 0x86, 0x16, 0xc0, 0x2c, 0x1c, 0x1e, 0xee, 0xee, 0xdf,
	0x75, 0xca, 0xf7, 0x9c, 0x42, 0xb1, 0xb2, 0xbb, 0x5f, 0x35, 0x0d, 0x64, 0x42, 0xe6, 0xb0, 0x50,
	0xa9, 0x38, 0xd5, 0x92, 0x7d, 0xf0, 0xe8, 0x7e, 0xc9, 0x1c, 0x5f, 0x3f, 0x05, 0xeb, 0xbc, 0xc6,
	0x01, 0x65, 0x20, 0x59, 0x29, 0xec, 0x97, 0xab, 0xe5, 0x27, 0x02, 0xd1, 0x84, 0xcc, 0xbd, 0x03,
	0xfb, 0x9d, 0x82, 0x7d, 0xd7, 0x39, 0xd8, 0x7f, 0xf8, 0xd8, 0x34, 0x10, 0x82, 0x19, 0xad, 0x43,
	0x4f, 0x98, 0xe3, 0x82, 0x2b, 0x96, 0x71, 0x2a, 0xbb, 0x55, 0x73, 0x02, 0xdd, 0x84, 0xf9, 0xc2,
	0xc3, 0x77, 0x0a, 0x8f, 0x2b, 0xce, 0x80, 0x78, 0x22, 0x5f, 0x11, 0xae, 0xde, 0x87, 0x87, 0x57,
	0xe9, 0xea, 0xe2, 0x12, 0xcc, 0xaa, 0x67, 0x11, 0x16, 0x11, 0xd7, 0xaf, 0xf9, 0x84, 0xa2, 0x89,
	0xff, 0x16, 0x8d, 0xbd, 0x44, 0x72, 0xc5, 0x5c, 0xdd, 0x4b, 0x24, 0xd3, 0x66, 0xc6, 0xce, 0xf4,
	0x5f, 0x71, 0xd6, 0x3f, 0x37, 0x60, 0xc2, 0xf6, 0x18, 0xfa, 0x3e, 0x4c, 0x0f, 0x3c, 0x0d, 0xea,
	0x44, 0x5e, 0x1f, 0x7e, 0x2b, 0x55, 0x7b, 0x59, 0x91, 0x9c, 0xb2, 0xc3, 0xfa, 0x99, 0xec, 0xb0,
	0x32, 0x6e, 0x1f, 0x1d, 0x6d, 0xc3, 0x5c, 0xff, 0x1b, 0x8d, 0xba, 0x95, 0x9e, 0x79, 0x29, 0x9a,
	0xed, 0x7b, 0x84, 0x11, 0xe5, 0x3b, 0x5f, 0x10, 0x6e, 0xf9, 0x2e, 0xe4, 0xbf, 0xa2, 0x5b, 0x6c,
	0x8f, 0xad, 0xff, 0xc7, 0x80, 0xe7, 0xfa, 0x9e, 0x5e, 0x06, 0xde, 0x7d, 0xd8, 0x43, 0x9f, 0x71,
	0x74, 0x0a, 0x2b, 0xfd, 0xaf, 0x3d, 0xda, 0xc0, 0x98, 0xc5, 0x32, 0x64, 0x4e, 0x6e, 0x9e, 0xf3,
	0x98, 0x74, 0x1e, 0xb4, 0xf4, 0xc3, 0x2f, 0x8d, 0xf1, 0xa4, 0x61, 0x2f, 0xb3, 0xf3, 0xd4, 0x5f,
	0xf6, 0x14, 0x1a, 0xb9, 0xae, 0xf5, 0x7f, 0xcf, 0x40, 0xa6, 0xff, 0xd1, 0x09, 0xad, 0x40, 0x42,
	0x7a, 0xdd, 0x18, 0xf4, 0xba, 0x24, 0xa2, 0x4f, 0x0d, 0x98, 0x93, 0x86, 0x3a, 0xc7, 0xe4, 0xd4,
	0x39, 0x6a, 0xfb, 0x4d, 0x8f, 0x50, 0xb9, 0x41, 0xe9, 0xad, 0xc7, 0x57, 0xf6, 0xf0, 0xa5, 0x3e,
	0x1e, 0x90, 0xd3, 0xa2, 0x52, 0xd0, 0x17, 0x2e, 0xb3, 0x6c, 0x70, 0x0a, 0xbd, 0x0b, 0x73, 0xd4,
	0x8b, 0xaf, 0x66, 0x71, 0x20, 0x4e, 0x7c, 0x85, 0x40, 0x9c, 0xa5, 0x1e, 0xeb, 0x9f, 0x42, 0x9f,
	0x19, 0xb0, 0x36, 0x62, 0xcb, 0x9d, 0xa6, 0xcf, 0xb8, 0x6e, 0xb3, 0x9e, 0x5c, 0xd5, 0xd2, 0x9f,
	0xdd, 0xa0, 0xd2, 0x98, 0xfd, 0x1c, 0x1b, 0x19, 0x99, 0x75, 0x80, 0xd8, 0x4c, 0x8f, 0xe9, 0xae,
	0xed, 0xde, 0x55, 0x18, 0x24, 0x9f, 0x4e, 0x53, 0x2c, 0xfe, 0xc8, 0xfe, 0x3d, 0x05, 0xb3, 0x67,
	0x76, 0x06, 0xfd, 0xc2, 0x80, 0x54, 0x8d, 0xe2, 0x7a, 0x8b, 0x04, 0x3c, 0xce, 0x02, 0xff, 0xda,
	0x02, 0x21, 0x77, 0x4f, 0xab, 0xea, 0x0f, 0x0c, 0x95, 0x3f, 0x3d, 0x2b, 0xb2, 0x7f, 0x9b, 0x82,
	0xd9, 0x33, 0x8c, 0xe8, 0x0f, 0x06, 0x2c, 0xe9, 0x07, 0xac, 0x8e, 0x38, 0xbf, 0xc4, 0x5d, 0x95,
	0x62, 0x97, 0x87, 0x54, 0x57, 0xad, 0x1f, 0x7f, 0x6d, 0x46, 0xe7, 0xd4, 0x69, 0x24, 0x8f, 0xd1,
	0xdd, 0xd8, 0x8a, 0xd2, 0x98, 0xbd, 0xd0, 0x18, 0x42, 0xcf, 0x7e, 0x3a, 0x09, 0x0b, 0xc3, 0x04,
	0x46, 0xe7, 0xe9, 0xff, 0xc3, 0x1c, 0x69, 0x92, 0x96, 0xbc, 0x52, 0x90, 0x08, 0x53, 0x2c, 0x16,
	0x2a, 0xeb, 0xa8, 0x6d, 0xea, 0x89, 0x4a, 0x4c, 0x47, 0x4b, 0x30, 0xe9, 0x07, 0x1e, 0x39, 0x91,
	0x69, 0x33, 0x5d, 0x1a, 0xb3, 0xd5, 0xa7, 0x48, 0x80, 0x29, 0xcd, 0xac, 0xe3, 0xfc, 0x13, 0xe3,
	0x9b, 0xf5, 0x52, 0xee, 0x41, 0x67, 0x57, 0x19, 0x54, 0x1a, 0xb3, 0x63, 0xdb, 0xb2, 0xff, 0x30,
	0x20, 0xd5, 0x9d, 0x40, 0xff, 0x07, 0xa9, 0xde, 0x92, 0xcf, 0x38, 0xa7, 0x37, 0x83, 0x96, 0x61,
	0xe2, 0x98, 0x9c, 0x9e, 0x3d, 0x5b, 0x04, 0x2d, 0xff, 0x73, 0x43, 0x14, 0xdc, 0x8f, 0x0d, 0xf8,
	0xc8, 0xb8, 0x7c, 0xc9, 0xbd, 0xec, 0x42, 0xf3, 0x3f, 0x11, 0xc6, 0x7c, 0x08, 0x27, 0xdf, 0x94,
	0x29, 0xc5, 0x19, 0xc8, 0xe8, 0x64, 0x91, 0xcd, 0x69, 0xfe, 0xa9, 0x30, 0x88, 0x80, 0xfb, 0x35,
	0x18, 0x54, 0x4c, 0x43, 0x42, 0xe8, 0x94, 0x1d, 0x49, 0xfe, 0x89, 0x50, 0xfc, 0x08, 0x2a, 0xd7,
	0xa0, 0x38, 0xbf, 0x27, 0xb0, 0x77, 0x61, 0xe7, 0x0a, 0xb0, 0x8b, 0x37, 0xc1, 0x8c, 0x8f, 0xa3,
	0x81, 0x96, 0x6a, 0xfd, 0x4f, 0x06, 0xa4, 0xba, 0xb5, 0x15, 0x11, 0xb0, 0x7a, 0x75, 0xdb, 0xb9,
	0x7c, 0x27, 0xb5, 0xd8, 0xad, 0xd4, 0xfd, 0x0c, 0xf9, 0xfb, 0x62, 0x65, 0x45, 0x78, 0xf3, 0x72,
	0x2b, 0xf3, 0xd8, 0xfa, 0x5f, 0x0d, 0x80, 0xde, 0xb5, 0x61, 0x74, 0xfd, 0xf9, 0x36, 0x64, 0xc4,
	0xbe, 0x79, 0x83, 0xff, 0xda, 0x16, 0x9e, 0xb9, 0x4f, 0x14, 0x82, 0xd3, 0xd2, 0x98, 0x9d, 0x96,
	0xbc, 0xca, 0xea, 0x7c, 0x49, 0xd8, 0xbb, 0x03, 0x85, 0x4b, 0x34, 0xb9, 0xca, 0xc2, 0xe2, 0x34,
	0xa4, 0xb5, 0x57, 0x05, 0xfe, 0x5e, 0x22, 0x39, 0x61, 0x26, 0xf4, 0x7d, 0xfb, 0x86, 0x9a, 0x28,
	0xb6, 0xff, 0xf2, 0xc5, 0x2d, 0xe3, 0xf3, 0x2f, 0x6e, 0x19, 0xff, 0xfc, 0xe2, 0x96, 0x01, 0x65,
	0x3f, 0x54, 0x1e, 0x97, 0x0f, 0x61, 0x97, 0x29, 0x75, 0xc5, 0xec, 0xd0, 0x66, 0x5b, 0xfe, 0x7e,
	0x39, 0x34, 0x8e, 0x6e, 0x48, 0x07, 0x6c, 0xff, 0x2f, 0x00, 0x00, 0xff, 0xff, 0x18, 0xf0, 0xea,
	0xca, 0x33, 0x20, 0x00, 0x00,
}

func (m *HttpConnectionManager) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HttpConnectionManager) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HttpConnectionManager) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CommonHttpProtocolOptions != nil {
		{
			size, err := m.CommonHttpProtocolOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintHttpConnectionManager(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x9a
	}
	if m.ServerHeaderTransformation != 0 {
		i = encodeVarintHttpConnectionManager(dAtA, i, uint64(m.ServerHeaderTransformation))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x90
	}
	if m.MergeSlashes {
		i--
		if m.MergeSlashes {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	if m.PreserveExternalRequestId {
		i--
		if m.PreserveExternalRequestId {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x80
	}
	if m.RouteSpecifier != nil {
		{
			size := m.RouteSpecifier.Size()
			i -= size
			if _, err := m.RouteSpecifier.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.NormalizePath != nil {
		{
			size, err := m.NormalizePath.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintHttpConnectionManager(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if m.MaxRequestHeadersKb != nil {
		{
			size, err := m.MaxRequestHeadersKb.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintHttpConnectionManager(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xea
	}
	if m.RequestTimeout != nil {
		{
			size, err := m.RequestTimeout.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintHttpConnectionManager(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	if m.DelayedCloseTimeout != nil {
		{
			size, err := m.DelayedCloseTimeout.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintHttpConnectionManager(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	if m.InternalAddressConfig != nil {
		{
			size, err := m.InternalAddressConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintHttpConnectionManager(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if m.StreamIdleTimeout != nil {
		{
			size, err := m.StreamIdleTimeout.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintHttpConnectionManager(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if len(m.UpgradeConfigs) > 0 {
		for iNdEx := len(m.UpgradeConfigs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UpgradeConfigs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintHttpConnectionManager(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xba
		}
	}
	if len(m.Via) > 0 {
		i -= len(m.Via)
		copy(dAtA[i:], m.Via)
		i = encodeVarintHttpConnectionManager(dAtA, i, uint64(len(m.Via)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.SkipXffAppend {
		i--
		if m.SkipXffAppend {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.RepresentIpv4RemoteAddressAsIpv4MappedIpv6 {
		i--
		if m.RepresentIpv4RemoteAddressAsIpv4MappedIpv6 {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.XffNumTrustedHops != 0 {
		i = encodeVarintHttpConnectionManager(dAtA, i, uint64(m.XffNumTrustedHops))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.Proxy_100Continue {
		i--
		if m.Proxy_100Continue {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.SetCurrentClientCertDetails != nil {
		{
			size, err := m.SetCurrentClientCertDetails.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintHttpConnectionManager(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.ForwardClientCertDetails != 0 {
		i = encodeVarintHttpConnectionManager(dAtA, i, uint64(m.ForwardClientCertDetails))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.GenerateRequestId != nil {
		{
			size, err := m.GenerateRequestId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintHttpConnectionManager(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.UseRemoteAddress != nil {
		{
			size, err := m.UseRemoteAddress.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintHttpConnectionManager(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if len(m.AccessLog) > 0 {
		for iNdEx := len(m.AccessLog) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AccessLog[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintHttpConnectionManager(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	if m.DrainTimeout != nil {
		{
			size, err := m.DrainTimeout.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintHttpConnectionManager(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if len(m.ServerName) > 0 {
		i -= len(m.ServerName)
		copy(dAtA[i:], m.ServerName)
		i = encodeVarintHttpConnectionManager(dAtA, i, uint64(len(m.ServerName)))
		i--
		dAtA[i] = 0x52
	}
	if m.Http2ProtocolOptions != nil {
		{
			size, err := m.Http2ProtocolOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintHttpConnectionManager(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.HttpProtocolOptions != nil {
		{
			size, err := m.HttpProtocolOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintHttpConnectionManager(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Tracing != nil {
		{
			size, err := m.Tracing.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintHttpConnectionManager(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.AddUserAgent != nil {
		{
			size, err := m.AddUserAgent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintHttpConnectionManager(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.HttpFilters) > 0 {
		for iNdEx := len(m.HttpFilters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.HttpFilters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintHttpConnectionManager(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.StatPrefix) > 0 {
		i -= len(m.StatPrefix)
		copy(dAtA[i:], m.StatPrefix)
		i = encodeVarintHttpConnectionManager(dAtA, i, uint64(len(m.StatPrefix)))
		i--
		dAtA[i] = 0x12
	}
	if m.CodecType != 0 {
		i = encodeVarintHttpConnectionManager(dAtA, i, uint64(m.CodecType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HttpConnectionManager_Rds) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HttpConnectionManager_Rds) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Rds != nil {
		{
			size, err := m.Rds.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintHttpConnectionManager(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *HttpConnectionManager_RouteConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HttpConnectionManager_RouteConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RouteConfig != nil {
		{
			size, err := m.RouteConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintHttpConnectionManager(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *HttpConnectionManager_ScopedRoutes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HttpConnectionManager_ScopedRoutes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ScopedRoutes != nil {
		{
			size, err := m.ScopedRoutes.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintHttpConnectionManager(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	return len(dAtA) - i, nil
}
func (m *HttpConnectionManager_Tracing) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HttpConnectionManager_Tracing) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HttpConnectionManager_Tracing) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.CustomTags) > 0 {
		for iNdEx := len(m.CustomTags) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CustomTags[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintHttpConnectionManager(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.MaxPathTagLength != nil {
		{
			size, err := m.MaxPathTagLength.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintHttpConnectionManager(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Verbose {
		i--
		if m.Verbose {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.OverallSampling != nil {
		{
			size, err := m.OverallSampling.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintHttpConnectionManager(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.RandomSampling != nil {
		{
			size, err := m.RandomSampling.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintHttpConnectionManager(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.ClientSampling != nil {
		{
			size, err := m.ClientSampling.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintHttpConnectionManager(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}

func (m *HttpConnectionManager_InternalAddressConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HttpConnectionManager_InternalAddressConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HttpConnectionManager_InternalAddressConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UnixSockets {
		i--
		if m.UnixSockets {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HttpConnectionManager_SetCurrentClientCertDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HttpConnectionManager_SetCurrentClientCertDetails) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HttpConnectionManager_SetCurrentClientCertDetails) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Chain {
		i--
		if m.Chain {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Uri {
		i--
		if m.Uri {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Dns {
		i--
		if m.Dns {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Cert {
		i--
		if m.Cert {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Subject != nil {
		{
			size, err := m.Subject.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintHttpConnectionManager(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HttpConnectionManager_UpgradeConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HttpConnectionManager_UpgradeConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HttpConnectionManager_UpgradeConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Enabled != nil {
		{
			size, err := m.Enabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintHttpConnectionManager(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Filters) > 0 {
		for iNdEx := len(m.Filters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Filters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintHttpConnectionManager(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.UpgradeType) > 0 {
		i -= len(m.UpgradeType)
		copy(dAtA[i:], m.UpgradeType)
		i = encodeVarintHttpConnectionManager(dAtA, i, uint64(len(m.UpgradeType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Rds) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Rds) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Rds) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RouteConfigName) > 0 {
		i -= len(m.RouteConfigName)
		copy(dAtA[i:], m.RouteConfigName)
		i = encodeVarintHttpConnectionManager(dAtA, i, uint64(len(m.RouteConfigName)))
		i--
		dAtA[i] = 0x12
	}
	if m.ConfigSource != nil {
		{
			size, err := m.ConfigSource.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintHttpConnectionManager(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ScopedRouteConfigurationsList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScopedRouteConfigurationsList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScopedRouteConfigurationsList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ScopedRouteConfigurations) > 0 {
		for iNdEx := len(m.ScopedRouteConfigurations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ScopedRouteConfigurations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintHttpConnectionManager(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ScopedRoutes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScopedRoutes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScopedRoutes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ConfigSpecifier != nil {
		{
			size := m.ConfigSpecifier.Size()
			i -= size
			if _, err := m.ConfigSpecifier.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.RdsConfigSource != nil {
		{
			size, err := m.RdsConfigSource.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintHttpConnectionManager(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ScopeKeyBuilder != nil {
		{
			size, err := m.ScopeKeyBuilder.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintHttpConnectionManager(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintHttpConnectionManager(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ScopedRoutes_ScopedRouteConfigurationsList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScopedRoutes_ScopedRouteConfigurationsList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ScopedRouteConfigurationsList != nil {
		{
			size, err := m.ScopedRouteConfigurationsList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintHttpConnectionManager(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *ScopedRoutes_ScopedRds) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScopedRoutes_ScopedRds) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ScopedRds != nil {
		{
			size, err := m.ScopedRds.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintHttpConnectionManager(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *ScopedRoutes_ScopeKeyBuilder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScopedRoutes_ScopeKeyBuilder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScopedRoutes_ScopeKeyBuilder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Fragments) > 0 {
		for iNdEx := len(m.Fragments) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Fragments[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintHttpConnectionManager(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ScopedRoutes_ScopeKeyBuilder_FragmentBuilder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScopedRoutes_ScopeKeyBuilder_FragmentBuilder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScopedRoutes_ScopeKeyBuilder_FragmentBuilder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Type != nil {
		{
			size := m.Type.Size()
			i -= size
			if _, err := m.Type.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.HeaderValueExtractor != nil {
		{
			size, err := m.HeaderValueExtractor.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintHttpConnectionManager(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ExtractType != nil {
		{
			size := m.ExtractType.Size()
			i -= size
			if _, err := m.ExtractType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.ElementSeparator) > 0 {
		i -= len(m.ElementSeparator)
		copy(dAtA[i:], m.ElementSeparator)
		i = encodeVarintHttpConnectionManager(dAtA, i, uint64(len(m.ElementSeparator)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintHttpConnectionManager(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_Index) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_Index) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintHttpConnectionManager(dAtA, i, uint64(m.Index))
	i--
	dAtA[i] = 0x18
	return len(dAtA) - i, nil
}
func (m *ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_Element) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_Element) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Element != nil {
		{
			size, err := m.Element.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintHttpConnectionManager(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintHttpConnectionManager(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Separator) > 0 {
		i -= len(m.Separator)
		copy(dAtA[i:], m.Separator)
		i = encodeVarintHttpConnectionManager(dAtA, i, uint64(len(m.Separator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ScopedRds) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScopedRds) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScopedRds) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ScopedRdsConfigSource != nil {
		{
			size, err := m.ScopedRdsConfigSource.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintHttpConnectionManager(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HttpFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HttpFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HttpFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ConfigType != nil {
		{
			size := m.ConfigType.Size()
			i -= size
			if _, err := m.ConfigType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintHttpConnectionManager(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HttpFilter_TypedConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HttpFilter_TypedConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TypedConfig != nil {
		{
			size, err := m.TypedConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintHttpConnectionManager(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func encodeVarintHttpConnectionManager(dAtA []byte, offset int, v uint64) int {
	offset -= sovHttpConnectionManager(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *HttpConnectionManager) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CodecType != 0 {
		n += 1 + sovHttpConnectionManager(uint64(m.CodecType))
	}
	l = len(m.StatPrefix)
	if l > 0 {
		n += 1 + l + sovHttpConnectionManager(uint64(l))
	}
	if m.RouteSpecifier != nil {
		n += m.RouteSpecifier.Size()
	}
	if len(m.HttpFilters) > 0 {
		for _, e := range m.HttpFilters {
			l = e.Size()
			n += 1 + l + sovHttpConnectionManager(uint64(l))
		}
	}
	if m.AddUserAgent != nil {
		l = m.AddUserAgent.Size()
		n += 1 + l + sovHttpConnectionManager(uint64(l))
	}
	if m.Tracing != nil {
		l = m.Tracing.Size()
		n += 1 + l + sovHttpConnectionManager(uint64(l))
	}
	if m.HttpProtocolOptions != nil {
		l = m.HttpProtocolOptions.Size()
		n += 1 + l + sovHttpConnectionManager(uint64(l))
	}
	if m.Http2ProtocolOptions != nil {
		l = m.Http2ProtocolOptions.Size()
		n += 1 + l + sovHttpConnectionManager(uint64(l))
	}
	l = len(m.ServerName)
	if l > 0 {
		n += 1 + l + sovHttpConnectionManager(uint64(l))
	}
	if m.DrainTimeout != nil {
		l = m.DrainTimeout.Size()
		n += 1 + l + sovHttpConnectionManager(uint64(l))
	}
	if len(m.AccessLog) > 0 {
		for _, e := range m.AccessLog {
			l = e.Size()
			n += 1 + l + sovHttpConnectionManager(uint64(l))
		}
	}
	if m.UseRemoteAddress != nil {
		l = m.UseRemoteAddress.Size()
		n += 1 + l + sovHttpConnectionManager(uint64(l))
	}
	if m.GenerateRequestId != nil {
		l = m.GenerateRequestId.Size()
		n += 1 + l + sovHttpConnectionManager(uint64(l))
	}
	if m.ForwardClientCertDetails != 0 {
		n += 2 + sovHttpConnectionManager(uint64(m.ForwardClientCertDetails))
	}
	if m.SetCurrentClientCertDetails != nil {
		l = m.SetCurrentClientCertDetails.Size()
		n += 2 + l + sovHttpConnectionManager(uint64(l))
	}
	if m.Proxy_100Continue {
		n += 3
	}
	if m.XffNumTrustedHops != 0 {
		n += 2 + sovHttpConnectionManager(uint64(m.XffNumTrustedHops))
	}
	if m.RepresentIpv4RemoteAddressAsIpv4MappedIpv6 {
		n += 3
	}
	if m.SkipXffAppend {
		n += 3
	}
	l = len(m.Via)
	if l > 0 {
		n += 2 + l + sovHttpConnectionManager(uint64(l))
	}
	if len(m.UpgradeConfigs) > 0 {
		for _, e := range m.UpgradeConfigs {
			l = e.Size()
			n += 2 + l + sovHttpConnectionManager(uint64(l))
		}
	}
	if m.StreamIdleTimeout != nil {
		l = m.StreamIdleTimeout.Size()
		n += 2 + l + sovHttpConnectionManager(uint64(l))
	}
	if m.InternalAddressConfig != nil {
		l = m.InternalAddressConfig.Size()
		n += 2 + l + sovHttpConnectionManager(uint64(l))
	}
	if m.DelayedCloseTimeout != nil {
		l = m.DelayedCloseTimeout.Size()
		n += 2 + l + sovHttpConnectionManager(uint64(l))
	}
	if m.RequestTimeout != nil {
		l = m.RequestTimeout.Size()
		n += 2 + l + sovHttpConnectionManager(uint64(l))
	}
	if m.MaxRequestHeadersKb != nil {
		l = m.MaxRequestHeadersKb.Size()
		n += 2 + l + sovHttpConnectionManager(uint64(l))
	}
	if m.NormalizePath != nil {
		l = m.NormalizePath.Size()
		n += 2 + l + sovHttpConnectionManager(uint64(l))
	}
	if m.PreserveExternalRequestId {
		n += 3
	}
	if m.MergeSlashes {
		n += 3
	}
	if m.ServerHeaderTransformation != 0 {
		n += 2 + sovHttpConnectionManager(uint64(m.ServerHeaderTransformation))
	}
	if m.CommonHttpProtocolOptions != nil {
		l = m.CommonHttpProtocolOptions.Size()
		n += 2 + l + sovHttpConnectionManager(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HttpConnectionManager_Rds) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Rds != nil {
		l = m.Rds.Size()
		n += 1 + l + sovHttpConnectionManager(uint64(l))
	}
	return n
}
func (m *HttpConnectionManager_RouteConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RouteConfig != nil {
		l = m.RouteConfig.Size()
		n += 1 + l + sovHttpConnectionManager(uint64(l))
	}
	return n
}
func (m *HttpConnectionManager_ScopedRoutes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ScopedRoutes != nil {
		l = m.ScopedRoutes.Size()
		n += 2 + l + sovHttpConnectionManager(uint64(l))
	}
	return n
}
func (m *HttpConnectionManager_Tracing) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClientSampling != nil {
		l = m.ClientSampling.Size()
		n += 1 + l + sovHttpConnectionManager(uint64(l))
	}
	if m.RandomSampling != nil {
		l = m.RandomSampling.Size()
		n += 1 + l + sovHttpConnectionManager(uint64(l))
	}
	if m.OverallSampling != nil {
		l = m.OverallSampling.Size()
		n += 1 + l + sovHttpConnectionManager(uint64(l))
	}
	if m.Verbose {
		n += 2
	}
	if m.MaxPathTagLength != nil {
		l = m.MaxPathTagLength.Size()
		n += 1 + l + sovHttpConnectionManager(uint64(l))
	}
	if len(m.CustomTags) > 0 {
		for _, e := range m.CustomTags {
			l = e.Size()
			n += 1 + l + sovHttpConnectionManager(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HttpConnectionManager_InternalAddressConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UnixSockets {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HttpConnectionManager_SetCurrentClientCertDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Subject != nil {
		l = m.Subject.Size()
		n += 1 + l + sovHttpConnectionManager(uint64(l))
	}
	if m.Cert {
		n += 2
	}
	if m.Dns {
		n += 2
	}
	if m.Uri {
		n += 2
	}
	if m.Chain {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HttpConnectionManager_UpgradeConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UpgradeType)
	if l > 0 {
		n += 1 + l + sovHttpConnectionManager(uint64(l))
	}
	if len(m.Filters) > 0 {
		for _, e := range m.Filters {
			l = e.Size()
			n += 1 + l + sovHttpConnectionManager(uint64(l))
		}
	}
	if m.Enabled != nil {
		l = m.Enabled.Size()
		n += 1 + l + sovHttpConnectionManager(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Rds) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConfigSource != nil {
		l = m.ConfigSource.Size()
		n += 1 + l + sovHttpConnectionManager(uint64(l))
	}
	l = len(m.RouteConfigName)
	if l > 0 {
		n += 1 + l + sovHttpConnectionManager(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ScopedRouteConfigurationsList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ScopedRouteConfigurations) > 0 {
		for _, e := range m.ScopedRouteConfigurations {
			l = e.Size()
			n += 1 + l + sovHttpConnectionManager(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ScopedRoutes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovHttpConnectionManager(uint64(l))
	}
	if m.ScopeKeyBuilder != nil {
		l = m.ScopeKeyBuilder.Size()
		n += 1 + l + sovHttpConnectionManager(uint64(l))
	}
	if m.RdsConfigSource != nil {
		l = m.RdsConfigSource.Size()
		n += 1 + l + sovHttpConnectionManager(uint64(l))
	}
	if m.ConfigSpecifier != nil {
		n += m.ConfigSpecifier.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ScopedRoutes_ScopedRouteConfigurationsList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ScopedRouteConfigurationsList != nil {
		l = m.ScopedRouteConfigurationsList.Size()
		n += 1 + l + sovHttpConnectionManager(uint64(l))
	}
	return n
}
func (m *ScopedRoutes_ScopedRds) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ScopedRds != nil {
		l = m.ScopedRds.Size()
		n += 1 + l + sovHttpConnectionManager(uint64(l))
	}
	return n
}
func (m *ScopedRoutes_ScopeKeyBuilder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Fragments) > 0 {
		for _, e := range m.Fragments {
			l = e.Size()
			n += 1 + l + sovHttpConnectionManager(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ScopedRoutes_ScopeKeyBuilder_FragmentBuilder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		n += m.Type.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HeaderValueExtractor != nil {
		l = m.HeaderValueExtractor.Size()
		n += 1 + l + sovHttpConnectionManager(uint64(l))
	}
	return n
}
func (m *ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovHttpConnectionManager(uint64(l))
	}
	l = len(m.ElementSeparator)
	if l > 0 {
		n += 1 + l + sovHttpConnectionManager(uint64(l))
	}
	if m.ExtractType != nil {
		n += m.ExtractType.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_Index) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovHttpConnectionManager(uint64(m.Index))
	return n
}
func (m *ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_Element) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Element != nil {
		l = m.Element.Size()
		n += 1 + l + sovHttpConnectionManager(uint64(l))
	}
	return n
}
func (m *ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Separator)
	if l > 0 {
		n += 1 + l + sovHttpConnectionManager(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovHttpConnectionManager(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ScopedRds) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ScopedRdsConfigSource != nil {
		l = m.ScopedRdsConfigSource.Size()
		n += 1 + l + sovHttpConnectionManager(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HttpFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovHttpConnectionManager(uint64(l))
	}
	if m.ConfigType != nil {
		n += m.ConfigType.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HttpFilter_TypedConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypedConfig != nil {
		l = m.TypedConfig.Size()
		n += 1 + l + sovHttpConnectionManager(uint64(l))
	}
	return n
}

func sovHttpConnectionManager(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozHttpConnectionManager(x uint64) (n int) {
	return sovHttpConnectionManager(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *HttpConnectionManager) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHttpConnectionManager
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HttpConnectionManager: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HttpConnectionManager: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CodecType", wireType)
			}
			m.CodecType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CodecType |= HttpConnectionManager_CodecType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatPrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Rds{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RouteSpecifier = &HttpConnectionManager_Rds{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v3.RouteConfiguration{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RouteSpecifier = &HttpConnectionManager_RouteConfig{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpFilters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HttpFilters = append(m.HttpFilters, &HttpFilter{})
			if err := m.HttpFilters[len(m.HttpFilters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddUserAgent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AddUserAgent == nil {
				m.AddUserAgent = &types.BoolValue{}
			}
			if err := m.AddUserAgent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tracing", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tracing == nil {
				m.Tracing = &HttpConnectionManager_Tracing{}
			}
			if err := m.Tracing.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpProtocolOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HttpProtocolOptions == nil {
				m.HttpProtocolOptions = &v31.Http1ProtocolOptions{}
			}
			if err := m.HttpProtocolOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Http2ProtocolOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Http2ProtocolOptions == nil {
				m.Http2ProtocolOptions = &v31.Http2ProtocolOptions{}
			}
			if err := m.Http2ProtocolOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DrainTimeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DrainTimeout == nil {
				m.DrainTimeout = &types.Duration{}
			}
			if err := m.DrainTimeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessLog", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessLog = append(m.AccessLog, &v32.AccessLog{})
			if err := m.AccessLog[len(m.AccessLog)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseRemoteAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UseRemoteAddress == nil {
				m.UseRemoteAddress = &types.BoolValue{}
			}
			if err := m.UseRemoteAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenerateRequestId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GenerateRequestId == nil {
				m.GenerateRequestId = &types.BoolValue{}
			}
			if err := m.GenerateRequestId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwardClientCertDetails", wireType)
			}
			m.ForwardClientCertDetails = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForwardClientCertDetails |= HttpConnectionManager_ForwardClientCertDetails(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetCurrentClientCertDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SetCurrentClientCertDetails == nil {
				m.SetCurrentClientCertDetails = &HttpConnectionManager_SetCurrentClientCertDetails{}
			}
			if err := m.SetCurrentClientCertDetails.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proxy_100Continue", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Proxy_100Continue = bool(v != 0)
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field XffNumTrustedHops", wireType)
			}
			m.XffNumTrustedHops = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.XffNumTrustedHops |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepresentIpv4RemoteAddressAsIpv4MappedIpv6", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RepresentIpv4RemoteAddressAsIpv4MappedIpv6 = bool(v != 0)
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipXffAppend", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SkipXffAppend = bool(v != 0)
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Via", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Via = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpgradeConfigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpgradeConfigs = append(m.UpgradeConfigs, &HttpConnectionManager_UpgradeConfig{})
			if err := m.UpgradeConfigs[len(m.UpgradeConfigs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamIdleTimeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StreamIdleTimeout == nil {
				m.StreamIdleTimeout = &types.Duration{}
			}
			if err := m.StreamIdleTimeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalAddressConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InternalAddressConfig == nil {
				m.InternalAddressConfig = &HttpConnectionManager_InternalAddressConfig{}
			}
			if err := m.InternalAddressConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelayedCloseTimeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DelayedCloseTimeout == nil {
				m.DelayedCloseTimeout = &types.Duration{}
			}
			if err := m.DelayedCloseTimeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestTimeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RequestTimeout == nil {
				m.RequestTimeout = &types.Duration{}
			}
			if err := m.RequestTimeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRequestHeadersKb", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxRequestHeadersKb == nil {
				m.MaxRequestHeadersKb = &types.UInt32Value{}
			}
			if err := m.MaxRequestHeadersKb.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NormalizePath", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NormalizePath == nil {
				m.NormalizePath = &types.BoolValue{}
			}
			if err := m.NormalizePath.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScopedRoutes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ScopedRoutes{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RouteSpecifier = &HttpConnectionManager_ScopedRoutes{v}
			iNdEx = postIndex
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreserveExternalRequestId", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PreserveExternalRequestId = bool(v != 0)
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MergeSlashes", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MergeSlashes = bool(v != 0)
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerHeaderTransformation", wireType)
			}
			m.ServerHeaderTransformation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerHeaderTransformation |= HttpConnectionManager_ServerHeaderTransformation(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommonHttpProtocolOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CommonHttpProtocolOptions == nil {
				m.CommonHttpProtocolOptions = &v31.HttpProtocolOptions{}
			}
			if err := m.CommonHttpProtocolOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHttpConnectionManager(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HttpConnectionManager_Tracing) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHttpConnectionManager
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tracing: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tracing: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientSampling", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClientSampling == nil {
				m.ClientSampling = &v33.Percent{}
			}
			if err := m.ClientSampling.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RandomSampling", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RandomSampling == nil {
				m.RandomSampling = &v33.Percent{}
			}
			if err := m.RandomSampling.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverallSampling", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OverallSampling == nil {
				m.OverallSampling = &v33.Percent{}
			}
			if err := m.OverallSampling.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Verbose", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Verbose = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxPathTagLength", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxPathTagLength == nil {
				m.MaxPathTagLength = &types.UInt32Value{}
			}
			if err := m.MaxPathTagLength.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomTags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomTags = append(m.CustomTags, &v34.CustomTag{})
			if err := m.CustomTags[len(m.CustomTags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHttpConnectionManager(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HttpConnectionManager_InternalAddressConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHttpConnectionManager
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InternalAddressConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InternalAddressConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnixSockets", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UnixSockets = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipHttpConnectionManager(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HttpConnectionManager_SetCurrentClientCertDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHttpConnectionManager
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetCurrentClientCertDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetCurrentClientCertDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subject", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Subject == nil {
				m.Subject = &types.BoolValue{}
			}
			if err := m.Subject.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cert", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Cert = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dns", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Dns = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Uri = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chain", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Chain = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipHttpConnectionManager(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HttpConnectionManager_UpgradeConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHttpConnectionManager
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpgradeConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpgradeConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpgradeType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpgradeType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filters = append(m.Filters, &HttpFilter{})
			if err := m.Filters[len(m.Filters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Enabled == nil {
				m.Enabled = &types.BoolValue{}
			}
			if err := m.Enabled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHttpConnectionManager(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Rds) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHttpConnectionManager
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Rds: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Rds: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigSource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConfigSource == nil {
				m.ConfigSource = &v31.ConfigSource{}
			}
			if err := m.ConfigSource.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteConfigName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouteConfigName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHttpConnectionManager(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScopedRouteConfigurationsList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHttpConnectionManager
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScopedRouteConfigurationsList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScopedRouteConfigurationsList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScopedRouteConfigurations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScopedRouteConfigurations = append(m.ScopedRouteConfigurations, &v3.ScopedRouteConfiguration{})
			if err := m.ScopedRouteConfigurations[len(m.ScopedRouteConfigurations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHttpConnectionManager(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScopedRoutes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHttpConnectionManager
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScopedRoutes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScopedRoutes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScopeKeyBuilder", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ScopeKeyBuilder == nil {
				m.ScopeKeyBuilder = &ScopedRoutes_ScopeKeyBuilder{}
			}
			if err := m.ScopeKeyBuilder.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RdsConfigSource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RdsConfigSource == nil {
				m.RdsConfigSource = &v31.ConfigSource{}
			}
			if err := m.RdsConfigSource.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScopedRouteConfigurationsList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ScopedRouteConfigurationsList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ConfigSpecifier = &ScopedRoutes_ScopedRouteConfigurationsList{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScopedRds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ScopedRds{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ConfigSpecifier = &ScopedRoutes_ScopedRds{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHttpConnectionManager(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScopedRoutes_ScopeKeyBuilder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHttpConnectionManager
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScopeKeyBuilder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScopeKeyBuilder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fragments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fragments = append(m.Fragments, &ScopedRoutes_ScopeKeyBuilder_FragmentBuilder{})
			if err := m.Fragments[len(m.Fragments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHttpConnectionManager(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScopedRoutes_ScopeKeyBuilder_FragmentBuilder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHttpConnectionManager
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FragmentBuilder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FragmentBuilder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeaderValueExtractor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHttpConnectionManager(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHttpConnectionManager
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeaderValueExtractor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeaderValueExtractor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ElementSeparator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ElementSeparator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExtractType = &ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_Index{v}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Element", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ExtractType = &ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_Element{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHttpConnectionManager(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHttpConnectionManager
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KvElement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KvElement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Separator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Separator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHttpConnectionManager(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScopedRds) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHttpConnectionManager
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScopedRds: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScopedRds: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScopedRdsConfigSource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ScopedRdsConfigSource == nil {
				m.ScopedRdsConfigSource = &v31.ConfigSource{}
			}
			if err := m.ScopedRdsConfigSource.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHttpConnectionManager(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HttpFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHttpConnectionManager
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HttpFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HttpFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypedConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.Any{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ConfigType = &HttpFilter_TypedConfig{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHttpConnectionManager(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipHttpConnectionManager(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowHttpConnectionManager
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthHttpConnectionManager
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupHttpConnectionManager
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthHttpConnectionManager
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthHttpConnectionManager        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowHttpConnectionManager          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupHttpConnectionManager = fmt.Errorf("proto: unexpected end of group")
)
