// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: envoy/data/dns/v2alpha/dns_table.proto

package envoy_data_dns_v2alpha

import (
	fmt "fmt"
	_ "github.com/cncf/udpa/go/udpa/annotations"
	matcher "github.com/datawire/ambassador/pkg/api/envoy/type/matcher"
	_ "github.com/envoyproxy/protoc-gen-validate/validate"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// This message contains the configuration for the DNS Filter if populated
// from the control plane
type DnsTable struct {
	// Control how many times envoy makes an attempt to forward a query to
	// an external server
	ExternalRetryCount uint32 `protobuf:"varint,1,opt,name=external_retry_count,json=externalRetryCount,proto3" json:"external_retry_count,omitempty"`
	// Fully qualified domain names for which Envoy will respond to queries
	VirtualDomains []*DnsTable_DnsVirtualDomain `protobuf:"bytes,2,rep,name=virtual_domains,json=virtualDomains,proto3" json:"virtual_domains,omitempty"`
	// This field serves to help Envoy determine whether it can authoritatively
	// answer a query for a name matching a suffix in this list. If the query
	// name does not match a suffix in this list, Envoy will forward
	// the query to an upstream DNS server
	KnownSuffixes        []*matcher.StringMatcher `protobuf:"bytes,3,rep,name=known_suffixes,json=knownSuffixes,proto3" json:"known_suffixes,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *DnsTable) Reset()         { *m = DnsTable{} }
func (m *DnsTable) String() string { return proto.CompactTextString(m) }
func (*DnsTable) ProtoMessage()    {}
func (*DnsTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_74e6eda848825994, []int{0}
}
func (m *DnsTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DnsTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DnsTable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DnsTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DnsTable.Merge(m, src)
}
func (m *DnsTable) XXX_Size() int {
	return m.Size()
}
func (m *DnsTable) XXX_DiscardUnknown() {
	xxx_messageInfo_DnsTable.DiscardUnknown(m)
}

var xxx_messageInfo_DnsTable proto.InternalMessageInfo

func (m *DnsTable) GetExternalRetryCount() uint32 {
	if m != nil {
		return m.ExternalRetryCount
	}
	return 0
}

func (m *DnsTable) GetVirtualDomains() []*DnsTable_DnsVirtualDomain {
	if m != nil {
		return m.VirtualDomains
	}
	return nil
}

func (m *DnsTable) GetKnownSuffixes() []*matcher.StringMatcher {
	if m != nil {
		return m.KnownSuffixes
	}
	return nil
}

// This message contains a list of IP addresses returned for a query for a known name
type DnsTable_AddressList struct {
	// This field contains a well formed IP address that is returned
	// in the answer for a name query. The address field can be an
	// IPv4 or IPv6 address. Address family detection is done automatically
	// when Envoy parses the string. Since this field is repeated,
	// Envoy will return one randomly chosen entry from this list in the
	// DNS response. The random index will vary per query so that we prevent
	// clients pinning on a single address for a configured domain
	Address              []string `protobuf:"bytes,1,rep,name=address,proto3" json:"address,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DnsTable_AddressList) Reset()         { *m = DnsTable_AddressList{} }
func (m *DnsTable_AddressList) String() string { return proto.CompactTextString(m) }
func (*DnsTable_AddressList) ProtoMessage()    {}
func (*DnsTable_AddressList) Descriptor() ([]byte, []int) {
	return fileDescriptor_74e6eda848825994, []int{0, 0}
}
func (m *DnsTable_AddressList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DnsTable_AddressList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DnsTable_AddressList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DnsTable_AddressList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DnsTable_AddressList.Merge(m, src)
}
func (m *DnsTable_AddressList) XXX_Size() int {
	return m.Size()
}
func (m *DnsTable_AddressList) XXX_DiscardUnknown() {
	xxx_messageInfo_DnsTable_AddressList.DiscardUnknown(m)
}

var xxx_messageInfo_DnsTable_AddressList proto.InternalMessageInfo

func (m *DnsTable_AddressList) GetAddress() []string {
	if m != nil {
		return m.Address
	}
	return nil
}

// This message type is extensible and can contain a list of addresses
// or dictate some other method for resolving the addresses for an
// endpoint
type DnsTable_DnsEndpoint struct {
	// Types that are valid to be assigned to EndpointConfig:
	//	*DnsTable_DnsEndpoint_AddressList
	EndpointConfig       isDnsTable_DnsEndpoint_EndpointConfig `protobuf_oneof:"endpoint_config"`
	XXX_NoUnkeyedLiteral struct{}                              `json:"-"`
	XXX_unrecognized     []byte                                `json:"-"`
	XXX_sizecache        int32                                 `json:"-"`
}

func (m *DnsTable_DnsEndpoint) Reset()         { *m = DnsTable_DnsEndpoint{} }
func (m *DnsTable_DnsEndpoint) String() string { return proto.CompactTextString(m) }
func (*DnsTable_DnsEndpoint) ProtoMessage()    {}
func (*DnsTable_DnsEndpoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_74e6eda848825994, []int{0, 1}
}
func (m *DnsTable_DnsEndpoint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DnsTable_DnsEndpoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DnsTable_DnsEndpoint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DnsTable_DnsEndpoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DnsTable_DnsEndpoint.Merge(m, src)
}
func (m *DnsTable_DnsEndpoint) XXX_Size() int {
	return m.Size()
}
func (m *DnsTable_DnsEndpoint) XXX_DiscardUnknown() {
	xxx_messageInfo_DnsTable_DnsEndpoint.DiscardUnknown(m)
}

var xxx_messageInfo_DnsTable_DnsEndpoint proto.InternalMessageInfo

type isDnsTable_DnsEndpoint_EndpointConfig interface {
	isDnsTable_DnsEndpoint_EndpointConfig()
	MarshalTo([]byte) (int, error)
	Size() int
}

type DnsTable_DnsEndpoint_AddressList struct {
	AddressList *DnsTable_AddressList `protobuf:"bytes,1,opt,name=address_list,json=addressList,proto3,oneof" json:"address_list,omitempty"`
}

func (*DnsTable_DnsEndpoint_AddressList) isDnsTable_DnsEndpoint_EndpointConfig() {}

func (m *DnsTable_DnsEndpoint) GetEndpointConfig() isDnsTable_DnsEndpoint_EndpointConfig {
	if m != nil {
		return m.EndpointConfig
	}
	return nil
}

func (m *DnsTable_DnsEndpoint) GetAddressList() *DnsTable_AddressList {
	if x, ok := m.GetEndpointConfig().(*DnsTable_DnsEndpoint_AddressList); ok {
		return x.AddressList
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*DnsTable_DnsEndpoint) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*DnsTable_DnsEndpoint_AddressList)(nil),
	}
}

type DnsTable_DnsVirtualDomain struct {
	// The domain name for which Envoy will respond to query requests
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The configuration containing the method to determine the address
	// of this endpoint
	Endpoint *DnsTable_DnsEndpoint `protobuf:"bytes,2,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	// Sets the TTL in dns answers from Envoy returned to the client
	AnswerTtl            *types.Duration `protobuf:"bytes,3,opt,name=answer_ttl,json=answerTtl,proto3" json:"answer_ttl,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *DnsTable_DnsVirtualDomain) Reset()         { *m = DnsTable_DnsVirtualDomain{} }
func (m *DnsTable_DnsVirtualDomain) String() string { return proto.CompactTextString(m) }
func (*DnsTable_DnsVirtualDomain) ProtoMessage()    {}
func (*DnsTable_DnsVirtualDomain) Descriptor() ([]byte, []int) {
	return fileDescriptor_74e6eda848825994, []int{0, 2}
}
func (m *DnsTable_DnsVirtualDomain) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DnsTable_DnsVirtualDomain) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DnsTable_DnsVirtualDomain.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DnsTable_DnsVirtualDomain) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DnsTable_DnsVirtualDomain.Merge(m, src)
}
func (m *DnsTable_DnsVirtualDomain) XXX_Size() int {
	return m.Size()
}
func (m *DnsTable_DnsVirtualDomain) XXX_DiscardUnknown() {
	xxx_messageInfo_DnsTable_DnsVirtualDomain.DiscardUnknown(m)
}

var xxx_messageInfo_DnsTable_DnsVirtualDomain proto.InternalMessageInfo

func (m *DnsTable_DnsVirtualDomain) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DnsTable_DnsVirtualDomain) GetEndpoint() *DnsTable_DnsEndpoint {
	if m != nil {
		return m.Endpoint
	}
	return nil
}

func (m *DnsTable_DnsVirtualDomain) GetAnswerTtl() *types.Duration {
	if m != nil {
		return m.AnswerTtl
	}
	return nil
}

func init() {
	proto.RegisterType((*DnsTable)(nil), "envoy.data.dns.v2alpha.DnsTable")
	proto.RegisterType((*DnsTable_AddressList)(nil), "envoy.data.dns.v2alpha.DnsTable.AddressList")
	proto.RegisterType((*DnsTable_DnsEndpoint)(nil), "envoy.data.dns.v2alpha.DnsTable.DnsEndpoint")
	proto.RegisterType((*DnsTable_DnsVirtualDomain)(nil), "envoy.data.dns.v2alpha.DnsTable.DnsVirtualDomain")
}

func init() {
	proto.RegisterFile("envoy/data/dns/v2alpha/dns_table.proto", fileDescriptor_74e6eda848825994)
}

var fileDescriptor_74e6eda848825994 = []byte{
	// 529 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x52, 0xcd, 0x8e, 0xd3, 0x30,
	0x10, 0x5e, 0x27, 0xfb, 0x93, 0x3a, 0xb4, 0x5b, 0x45, 0x68, 0x09, 0x95, 0x28, 0x65, 0x85, 0x50,
	0x85, 0x90, 0x03, 0xe5, 0xc0, 0x19, 0x53, 0xa4, 0x1e, 0x40, 0x5a, 0xd2, 0x15, 0xd7, 0xc8, 0xad,
	0xdd, 0xae, 0x45, 0x6a, 0x47, 0xb6, 0xd3, 0x6d, 0x6f, 0x3c, 0xc3, 0x3e, 0x06, 0x8f, 0xc0, 0x69,
	0x8f, 0x7b, 0x84, 0x37, 0x40, 0x7d, 0x0a, 0xd4, 0x13, 0x8a, 0x93, 0x40, 0x85, 0x40, 0x70, 0xca,
	0x8c, 0xbf, 0xf9, 0xe6, 0x9b, 0xf9, 0x32, 0xf0, 0x11, 0x13, 0x4b, 0xb9, 0x8e, 0x28, 0x31, 0x24,
	0xa2, 0x42, 0x47, 0xcb, 0x01, 0x49, 0xb3, 0x0b, 0x1b, 0x27, 0x86, 0x4c, 0x52, 0x86, 0x32, 0x25,
	0x8d, 0x0c, 0x4e, 0x6c, 0x1d, 0x2a, 0xea, 0x10, 0x15, 0x1a, 0x55, 0x75, 0x9d, 0xfb, 0x25, 0xdf,
	0xac, 0x33, 0x16, 0x2d, 0x88, 0x99, 0x5e, 0x30, 0x15, 0x69, 0xa3, 0xb8, 0x98, 0x97, 0xc4, 0x4e,
	0x77, 0x2e, 0xe5, 0x3c, 0x65, 0x91, 0xcd, 0x26, 0xf9, 0x2c, 0xa2, 0xb9, 0x22, 0x86, 0x4b, 0x51,
	0xe1, 0xf7, 0x72, 0x9a, 0x91, 0x88, 0x08, 0x21, 0x8d, 0x7d, 0xd6, 0x91, 0x36, 0xc4, 0xe4, 0xba,
	0x82, 0xef, 0x2c, 0x49, 0xca, 0x29, 0x31, 0x2c, 0xaa, 0x83, 0x12, 0x38, 0xdd, 0xec, 0x43, 0x6f,
	0x28, 0xf4, 0x79, 0x31, 0x63, 0xf0, 0x14, 0xde, 0x66, 0x2b, 0xc3, 0x94, 0x20, 0x69, 0xa2, 0x98,
	0x51, 0xeb, 0x64, 0x2a, 0x73, 0x61, 0x42, 0xd0, 0x03, 0xfd, 0x66, 0x1c, 0xd4, 0x58, 0x5c, 0x40,
	0xaf, 0x0a, 0x24, 0xa0, 0xf0, 0x78, 0xc9, 0x95, 0xc9, 0x49, 0x9a, 0x50, 0xb9, 0x20, 0x5c, 0xe8,
	0xd0, 0xe9, 0xb9, 0x7d, 0x7f, 0xf0, 0x0c, 0xfd, 0x79, 0x53, 0x54, 0x8b, 0x15, 0xc1, 0xfb, 0x92,
	0x3a, 0xb4, 0x4c, 0xec, 0x6d, 0xf1, 0xc1, 0x15, 0x70, 0x3c, 0x10, 0xb7, 0x96, 0xbb, 0x80, 0x0e,
	0x46, 0xb0, 0xf5, 0x41, 0xc8, 0x4b, 0x91, 0xe8, 0x7c, 0x36, 0xe3, 0x2b, 0xa6, 0x43, 0xd7, 0x8a,
	0x3c, 0xa8, 0x44, 0x0a, 0xdb, 0x50, 0x65, 0x1b, 0x1a, 0x5b, 0xdb, 0xde, 0x96, 0x59, 0xdc, 0xb4,
	0xc4, 0x71, 0xc5, 0xeb, 0xbc, 0x80, 0xfe, 0x4b, 0x4a, 0x15, 0xd3, 0xfa, 0x0d, 0xd7, 0x26, 0xe8,
	0xc3, 0x23, 0x52, 0xa6, 0x21, 0xe8, 0xb9, 0xfd, 0x06, 0x6e, 0x6d, 0xb1, 0x7f, 0x05, 0x3c, 0x0f,
	0x9c, 0xee, 0x2b, 0xa7, 0xed, 0xc6, 0x35, 0xdc, 0x59, 0x41, 0x7f, 0x28, 0xf4, 0x6b, 0x41, 0x33,
	0xc9, 0x85, 0x09, 0xde, 0xc1, 0x5b, 0x15, 0x92, 0xa4, 0x5c, 0x97, 0x0e, 0xf9, 0x83, 0x27, 0xff,
	0x5c, 0x7a, 0x47, 0x7c, 0xb4, 0x17, 0xfb, 0xe4, 0x57, 0x8a, 0x4f, 0xe0, 0x31, 0xab, 0xda, 0x27,
	0x53, 0x29, 0x66, 0x7c, 0x1e, 0xb8, 0xdf, 0x31, 0xe8, 0x5c, 0x03, 0xd8, 0xfe, 0xdd, 0xab, 0xa0,
	0x0b, 0xf7, 0x05, 0x59, 0x30, 0xab, 0xdb, 0xc0, 0x70, 0x8b, 0x8f, 0xd4, 0x41, 0xdb, 0xb9, 0x06,
	0x20, 0xb6, 0xef, 0xc1, 0x08, 0x7a, 0x75, 0xb3, 0xd0, 0xf9, 0xcf, 0xd9, 0x76, 0xf6, 0x8b, 0x7f,
	0xb2, 0x03, 0x0c, 0x21, 0x11, 0xfa, 0x92, 0xa9, 0xc4, 0x98, 0x34, 0x74, 0x6d, 0xaf, 0xbb, 0xa8,
	0xbc, 0x46, 0x54, 0x5f, 0x23, 0x1a, 0x56, 0xd7, 0x68, 0x7f, 0xe2, 0x27, 0xe0, 0x3c, 0xde, 0x8b,
	0x1b, 0x25, 0xed, 0xdc, 0xa4, 0x78, 0x7c, 0xb3, 0xe9, 0x82, 0x2f, 0x9b, 0x2e, 0xf8, 0xb6, 0xe9,
	0x82, 0xcf, 0x1f, 0x6f, 0xbe, 0x1e, 0x3a, 0x5e, 0xf5, 0x6d, 0xef, 0xc1, 0x87, 0x5c, 0x96, 0xb3,
	0x65, 0x4a, 0xae, 0xd6, 0x7f, 0x19, 0x13, 0x37, 0xeb, 0x39, 0xcf, 0x0a, 0xcd, 0x33, 0x30, 0x39,
	0xb4, 0xe2, 0xcf, 0x7f, 0x04, 0x00, 0x00, 0xff, 0xff, 0xdf, 0x70, 0xae, 0xb3, 0x7b, 0x03, 0x00,
	0x00,
}

func (m *DnsTable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DnsTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DnsTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.KnownSuffixes) > 0 {
		for iNdEx := len(m.KnownSuffixes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.KnownSuffixes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDnsTable(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.VirtualDomains) > 0 {
		for iNdEx := len(m.VirtualDomains) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VirtualDomains[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDnsTable(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ExternalRetryCount != 0 {
		i = encodeVarintDnsTable(dAtA, i, uint64(m.ExternalRetryCount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DnsTable_AddressList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DnsTable_AddressList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DnsTable_AddressList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Address) > 0 {
		for iNdEx := len(m.Address) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Address[iNdEx])
			copy(dAtA[i:], m.Address[iNdEx])
			i = encodeVarintDnsTable(dAtA, i, uint64(len(m.Address[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DnsTable_DnsEndpoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DnsTable_DnsEndpoint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DnsTable_DnsEndpoint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.EndpointConfig != nil {
		{
			size := m.EndpointConfig.Size()
			i -= size
			if _, err := m.EndpointConfig.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *DnsTable_DnsEndpoint_AddressList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DnsTable_DnsEndpoint_AddressList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AddressList != nil {
		{
			size, err := m.AddressList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDnsTable(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *DnsTable_DnsVirtualDomain) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DnsTable_DnsVirtualDomain) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DnsTable_DnsVirtualDomain) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AnswerTtl != nil {
		{
			size, err := m.AnswerTtl.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDnsTable(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Endpoint != nil {
		{
			size, err := m.Endpoint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDnsTable(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintDnsTable(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintDnsTable(dAtA []byte, offset int, v uint64) int {
	offset -= sovDnsTable(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *DnsTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExternalRetryCount != 0 {
		n += 1 + sovDnsTable(uint64(m.ExternalRetryCount))
	}
	if len(m.VirtualDomains) > 0 {
		for _, e := range m.VirtualDomains {
			l = e.Size()
			n += 1 + l + sovDnsTable(uint64(l))
		}
	}
	if len(m.KnownSuffixes) > 0 {
		for _, e := range m.KnownSuffixes {
			l = e.Size()
			n += 1 + l + sovDnsTable(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DnsTable_AddressList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Address) > 0 {
		for _, s := range m.Address {
			l = len(s)
			n += 1 + l + sovDnsTable(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DnsTable_DnsEndpoint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EndpointConfig != nil {
		n += m.EndpointConfig.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DnsTable_DnsEndpoint_AddressList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AddressList != nil {
		l = m.AddressList.Size()
		n += 1 + l + sovDnsTable(uint64(l))
	}
	return n
}
func (m *DnsTable_DnsVirtualDomain) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDnsTable(uint64(l))
	}
	if m.Endpoint != nil {
		l = m.Endpoint.Size()
		n += 1 + l + sovDnsTable(uint64(l))
	}
	if m.AnswerTtl != nil {
		l = m.AnswerTtl.Size()
		n += 1 + l + sovDnsTable(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovDnsTable(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozDnsTable(x uint64) (n int) {
	return sovDnsTable(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DnsTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDnsTable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DnsTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DnsTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalRetryCount", wireType)
			}
			m.ExternalRetryCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnsTable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExternalRetryCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualDomains", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnsTable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDnsTable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDnsTable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VirtualDomains = append(m.VirtualDomains, &DnsTable_DnsVirtualDomain{})
			if err := m.VirtualDomains[len(m.VirtualDomains)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KnownSuffixes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnsTable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDnsTable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDnsTable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KnownSuffixes = append(m.KnownSuffixes, &matcher.StringMatcher{})
			if err := m.KnownSuffixes[len(m.KnownSuffixes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDnsTable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDnsTable
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDnsTable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DnsTable_AddressList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDnsTable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddressList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddressList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnsTable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDnsTable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDnsTable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = append(m.Address, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDnsTable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDnsTable
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDnsTable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DnsTable_DnsEndpoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDnsTable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DnsEndpoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DnsEndpoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnsTable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDnsTable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDnsTable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DnsTable_AddressList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EndpointConfig = &DnsTable_DnsEndpoint_AddressList{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDnsTable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDnsTable
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDnsTable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DnsTable_DnsVirtualDomain) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDnsTable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DnsVirtualDomain: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DnsVirtualDomain: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnsTable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDnsTable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDnsTable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnsTable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDnsTable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDnsTable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Endpoint == nil {
				m.Endpoint = &DnsTable_DnsEndpoint{}
			}
			if err := m.Endpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnswerTtl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnsTable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDnsTable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDnsTable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AnswerTtl == nil {
				m.AnswerTtl = &types.Duration{}
			}
			if err := m.AnswerTtl.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDnsTable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDnsTable
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDnsTable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDnsTable(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDnsTable
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDnsTable
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDnsTable
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthDnsTable
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupDnsTable
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthDnsTable
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthDnsTable        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDnsTable          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupDnsTable = fmt.Errorf("proto: unexpected end of group")
)
