// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: envoy/config/filter/http/cache/v2alpha/cache.proto

package envoy_config_filter_http_cache_v2alpha

import (
	fmt "fmt"
	_ "github.com/cncf/udpa/go/udpa/annotations"
	route "github.com/datawire/ambassador/pkg/api/envoy/api/v2/route"
	matcher "github.com/datawire/ambassador/pkg/api/envoy/type/matcher"
	_ "github.com/envoyproxy/protoc-gen-validate/validate"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type CacheConfig struct {
	// Config specific to the cache storage implementation.
	TypedConfig *types.Any `protobuf:"bytes,1,opt,name=typed_config,json=typedConfig,proto3" json:"typed_config,omitempty"`
	// [#not-implemented-hide:]
	// <TODO(toddmgreer) implement *vary* headers>
	//
	// List of allowed *Vary* headers.
	//
	// The *vary* response header holds a list of header names that affect the
	// contents of a response, as described by
	// https://httpwg.org/specs/rfc7234.html#caching.negotiated.responses.
	//
	// During insertion, *allowed_vary_headers* acts as a whitelist: if a
	// response's *vary* header mentions any header names that aren't in
	// *allowed_vary_headers*, that response will not be cached.
	//
	// During lookup, *allowed_vary_headers* controls what request headers will be
	// sent to the cache storage implementation.
	AllowedVaryHeaders []*matcher.StringMatcher `protobuf:"bytes,2,rep,name=allowed_vary_headers,json=allowedVaryHeaders,proto3" json:"allowed_vary_headers,omitempty"`
	// [#not-implemented-hide:]
	// <TODO(toddmgreer) implement key customization>
	//
	// Modifies cache key creation by restricting which parts of the URL are included.
	KeyCreatorParams *CacheConfig_KeyCreatorParams `protobuf:"bytes,3,opt,name=key_creator_params,json=keyCreatorParams,proto3" json:"key_creator_params,omitempty"`
	// [#not-implemented-hide:]
	// <TODO(toddmgreer) implement size limit>
	//
	// Max body size the cache filter will insert into a cache. 0 means unlimited (though the cache
	// storage implementation may have its own limit beyond which it will reject insertions).
	MaxBodyBytes         uint32   `protobuf:"varint,4,opt,name=max_body_bytes,json=maxBodyBytes,proto3" json:"max_body_bytes,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CacheConfig) Reset()         { *m = CacheConfig{} }
func (m *CacheConfig) String() string { return proto.CompactTextString(m) }
func (*CacheConfig) ProtoMessage()    {}
func (*CacheConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_f8d6a0b399e44d47, []int{0}
}
func (m *CacheConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CacheConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CacheConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CacheConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CacheConfig.Merge(m, src)
}
func (m *CacheConfig) XXX_Size() int {
	return m.Size()
}
func (m *CacheConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_CacheConfig.DiscardUnknown(m)
}

var xxx_messageInfo_CacheConfig proto.InternalMessageInfo

func (m *CacheConfig) GetTypedConfig() *types.Any {
	if m != nil {
		return m.TypedConfig
	}
	return nil
}

func (m *CacheConfig) GetAllowedVaryHeaders() []*matcher.StringMatcher {
	if m != nil {
		return m.AllowedVaryHeaders
	}
	return nil
}

func (m *CacheConfig) GetKeyCreatorParams() *CacheConfig_KeyCreatorParams {
	if m != nil {
		return m.KeyCreatorParams
	}
	return nil
}

func (m *CacheConfig) GetMaxBodyBytes() uint32 {
	if m != nil {
		return m.MaxBodyBytes
	}
	return 0
}

// [#not-implemented-hide:]
// Modifies cache key creation by restricting which parts of the URL are included.
type CacheConfig_KeyCreatorParams struct {
	// If true, exclude the URL scheme from the cache key. Set to true if your origins always
	// produce the same response for http and https requests.
	ExcludeScheme bool `protobuf:"varint,1,opt,name=exclude_scheme,json=excludeScheme,proto3" json:"exclude_scheme,omitempty"`
	// If true, exclude the host from the cache key. Set to true if your origins' responses don't
	// ever depend on host.
	ExcludeHost bool `protobuf:"varint,2,opt,name=exclude_host,json=excludeHost,proto3" json:"exclude_host,omitempty"`
	// If *query_parameters_included* is nonempty, only query parameters matched
	// by one or more of its matchers are included in the cache key. Any other
	// query params will not affect cache lookup.
	QueryParametersIncluded []*route.QueryParameterMatcher `protobuf:"bytes,3,rep,name=query_parameters_included,json=queryParametersIncluded,proto3" json:"query_parameters_included,omitempty"`
	// If *query_parameters_excluded* is nonempty, query parameters matched by one
	// or more of its matchers are excluded from the cache key (even if also
	// matched by *query_parameters_included*), and will not affect cache lookup.
	QueryParametersExcluded []*route.QueryParameterMatcher `protobuf:"bytes,4,rep,name=query_parameters_excluded,json=queryParametersExcluded,proto3" json:"query_parameters_excluded,omitempty"`
	XXX_NoUnkeyedLiteral    struct{}                       `json:"-"`
	XXX_unrecognized        []byte                         `json:"-"`
	XXX_sizecache           int32                          `json:"-"`
}

func (m *CacheConfig_KeyCreatorParams) Reset()         { *m = CacheConfig_KeyCreatorParams{} }
func (m *CacheConfig_KeyCreatorParams) String() string { return proto.CompactTextString(m) }
func (*CacheConfig_KeyCreatorParams) ProtoMessage()    {}
func (*CacheConfig_KeyCreatorParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_f8d6a0b399e44d47, []int{0, 0}
}
func (m *CacheConfig_KeyCreatorParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CacheConfig_KeyCreatorParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CacheConfig_KeyCreatorParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CacheConfig_KeyCreatorParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CacheConfig_KeyCreatorParams.Merge(m, src)
}
func (m *CacheConfig_KeyCreatorParams) XXX_Size() int {
	return m.Size()
}
func (m *CacheConfig_KeyCreatorParams) XXX_DiscardUnknown() {
	xxx_messageInfo_CacheConfig_KeyCreatorParams.DiscardUnknown(m)
}

var xxx_messageInfo_CacheConfig_KeyCreatorParams proto.InternalMessageInfo

func (m *CacheConfig_KeyCreatorParams) GetExcludeScheme() bool {
	if m != nil {
		return m.ExcludeScheme
	}
	return false
}

func (m *CacheConfig_KeyCreatorParams) GetExcludeHost() bool {
	if m != nil {
		return m.ExcludeHost
	}
	return false
}

func (m *CacheConfig_KeyCreatorParams) GetQueryParametersIncluded() []*route.QueryParameterMatcher {
	if m != nil {
		return m.QueryParametersIncluded
	}
	return nil
}

func (m *CacheConfig_KeyCreatorParams) GetQueryParametersExcluded() []*route.QueryParameterMatcher {
	if m != nil {
		return m.QueryParametersExcluded
	}
	return nil
}

func init() {
	proto.RegisterType((*CacheConfig)(nil), "envoy.config.filter.http.cache.v2alpha.CacheConfig")
	proto.RegisterType((*CacheConfig_KeyCreatorParams)(nil), "envoy.config.filter.http.cache.v2alpha.CacheConfig.KeyCreatorParams")
}

func init() {
	proto.RegisterFile("envoy/config/filter/http/cache/v2alpha/cache.proto", fileDescriptor_f8d6a0b399e44d47)
}

var fileDescriptor_f8d6a0b399e44d47 = []byte{
	// 580 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x52, 0xcf, 0x6a, 0x14, 0x4f,
	0x10, 0xfe, 0xcd, 0xe6, 0x0f, 0x4b, 0x6f, 0x12, 0xc2, 0x10, 0xc8, 0x64, 0xe1, 0xb7, 0x26, 0xa2,
	0x92, 0x20, 0x76, 0xc3, 0xc4, 0x17, 0xc8, 0x44, 0x21, 0x22, 0xc2, 0xba, 0x01, 0xaf, 0x43, 0xef,
	0x4c, 0xed, 0xce, 0x90, 0x99, 0xee, 0x49, 0x77, 0xcf, 0xb8, 0x7d, 0xf3, 0x0d, 0x3c, 0x78, 0xf1,
	0xec, 0xd1, 0x47, 0xf0, 0x09, 0x72, 0xd4, 0x37, 0x90, 0x3d, 0x7b, 0xf2, 0xe8, 0x41, 0x64, 0xba,
	0x7b, 0xc0, 0x44, 0x0f, 0x01, 0x2f, 0xbb, 0xd3, 0x55, 0xf5, 0x7d, 0xf5, 0x55, 0xd5, 0x87, 0x42,
	0x60, 0x0d, 0xd7, 0x24, 0xe1, 0x6c, 0x96, 0xcf, 0xc9, 0x2c, 0x2f, 0x14, 0x08, 0x92, 0x29, 0x55,
	0x91, 0x84, 0x26, 0x19, 0x90, 0x26, 0xa4, 0x45, 0x95, 0x51, 0xfb, 0xc2, 0x95, 0xe0, 0x8a, 0xfb,
	0x0f, 0x0c, 0x06, 0x5b, 0x0c, 0xb6, 0x18, 0xdc, 0x62, 0xb0, 0xad, 0x72, 0x98, 0xe1, 0x91, 0xe5,
	0xa6, 0x55, 0x4e, 0x9a, 0x90, 0x08, 0x5e, 0x2b, 0xb0, 0xbf, 0x71, 0xc2, 0xcb, 0x8a, 0x33, 0x60,
	0x4a, 0x5a, 0xca, 0xe1, 0x1d, 0x5b, 0xaa, 0x74, 0x05, 0xa4, 0xa4, 0x2a, 0xc9, 0x40, 0x10, 0xa9,
	0x44, 0xce, 0xe6, 0xae, 0x60, 0x6f, 0xce, 0xf9, 0xbc, 0x00, 0x62, 0x5e, 0xd3, 0x7a, 0x46, 0x28,
	0xd3, 0x2e, 0x35, 0xaa, 0xd3, 0x8a, 0x12, 0xca, 0x18, 0x57, 0x54, 0xe5, 0x9c, 0x49, 0x52, 0xe6,
	0x73, 0x41, 0x95, 0x93, 0x3b, 0xfc, 0xff, 0x8f, 0xbc, 0x54, 0x54, 0xd5, 0x5d, 0xeb, 0xdd, 0x86,
	0x16, 0x79, 0x4a, 0x15, 0x90, 0xee, 0xc3, 0x26, 0xee, 0x7e, 0x5b, 0x45, 0x83, 0xd3, 0x76, 0xa0,
	0x53, 0x33, 0xa8, 0x7f, 0x82, 0x36, 0x5a, 0x7d, 0x69, 0x6c, 0x07, 0x0f, 0xbc, 0x7d, 0xef, 0x70,
	0x10, 0xee, 0x60, 0xab, 0x0c, 0x77, 0xca, 0xf0, 0x09, 0xd3, 0x51, 0xff, 0x47, 0xb4, 0xf6, 0xc1,
	0xeb, 0xf5, 0xbd, 0xc9, 0xc0, 0x60, 0x1c, 0xc5, 0x39, 0xda, 0xa1, 0x45, 0xc1, 0x5f, 0x43, 0x1a,
	0x37, 0x54, 0xe8, 0x38, 0x03, 0x9a, 0x82, 0x90, 0x41, 0x6f, 0x7f, 0xe5, 0x70, 0x10, 0x1e, 0x60,
	0xbb, 0xd8, 0x16, 0x81, 0xdd, 0x16, 0xf0, 0xb9, 0xd9, 0xc2, 0x0b, 0xfb, 0x9a, 0xf8, 0x0e, 0xfe,
	0x8a, 0x0a, 0x7d, 0x66, 0xc1, 0xbe, 0x40, 0xfe, 0x05, 0xe8, 0x38, 0x11, 0x40, 0x15, 0x17, 0x71,
	0x45, 0x05, 0x2d, 0x65, 0xb0, 0x62, 0xd4, 0x3d, 0xc1, 0xb7, 0xbb, 0x15, 0xfe, 0x6d, 0x50, 0xfc,
	0x1c, 0xf4, 0xa9, 0x25, 0x1b, 0x1b, 0xae, 0xc9, 0xf6, 0xc5, 0x8d, 0x88, 0x7f, 0x0f, 0x6d, 0x95,
	0x74, 0x11, 0x4f, 0x79, 0xaa, 0xe3, 0xa9, 0x56, 0x20, 0x83, 0xd5, 0x7d, 0xef, 0x70, 0x73, 0xb2,
	0x51, 0xd2, 0x45, 0xc4, 0x53, 0x1d, 0xb5, 0xb1, 0xe1, 0xc7, 0x1e, 0xda, 0xbe, 0x49, 0xe6, 0xdf,
	0x47, 0x5b, 0xb0, 0x48, 0x8a, 0x3a, 0x85, 0x58, 0x26, 0x19, 0x94, 0x60, 0x16, 0xd9, 0x9f, 0x6c,
	0xba, 0xe8, 0xb9, 0x09, 0xfa, 0x07, 0x68, 0xa3, 0x2b, 0xcb, 0xb8, 0x54, 0x41, 0xcf, 0x14, 0x0d,
	0x5c, 0xec, 0x8c, 0x4b, 0xe5, 0x03, 0xda, 0xbb, 0xac, 0x41, 0x68, 0x3b, 0x32, 0x28, 0x10, 0x32,
	0xce, 0x99, 0xc9, 0xa7, 0xc1, 0x8a, 0x59, 0xe9, 0x91, 0x9b, 0x9f, 0x56, 0x39, 0x6e, 0x42, 0x6c,
	0xdc, 0x87, 0x5f, 0xb6, 0xa0, 0x71, 0x87, 0xe9, 0x56, 0xbb, 0x7b, 0x79, 0x2d, 0x2c, 0x9f, 0x39,
	0xa6, 0xbf, 0xb6, 0x71, 0x32, 0xd2, 0x60, 0xf5, 0x5f, 0xdb, 0x3c, 0x75, 0x4c, 0xd1, 0x3b, 0xef,
	0x6a, 0x39, 0xf2, 0x3e, 0x2f, 0x47, 0xde, 0xd7, 0xe5, 0xc8, 0xfb, 0xfe, 0xfe, 0xe7, 0xdb, 0xb5,
	0x47, 0xfe, 0x43, 0xcb, 0x0b, 0x0b, 0x05, 0x4c, 0xb6, 0xde, 0x75, 0x27, 0x94, 0xd7, 0x6e, 0x78,
	0x6c, 0x6e, 0xf8, 0xe9, 0xcd, 0xd5, 0x97, 0xf5, 0x5e, 0xdf, 0xb3, 0xff, 0xdb, 0xff, 0xa1, 0xc7,
	0x39, 0xb7, 0xba, 0x2a, 0xc1, 0x17, 0xfa, 0x96, 0x4e, 0x88, 0x90, 0xb1, 0xc2, 0xb8, 0x75, 0xf3,
	0xd8, 0x9b, 0xae, 0x1b, 0x5b, 0x1f, 0xff, 0x0a, 0x00, 0x00, 0xff, 0xff, 0xeb, 0x7e, 0x66, 0xa2,
	0x28, 0x04, 0x00, 0x00,
}

func (m *CacheConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CacheConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CacheConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MaxBodyBytes != 0 {
		i = encodeVarintCache(dAtA, i, uint64(m.MaxBodyBytes))
		i--
		dAtA[i] = 0x20
	}
	if m.KeyCreatorParams != nil {
		{
			size, err := m.KeyCreatorParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCache(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AllowedVaryHeaders) > 0 {
		for iNdEx := len(m.AllowedVaryHeaders) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AllowedVaryHeaders[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCache(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.TypedConfig != nil {
		{
			size, err := m.TypedConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCache(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CacheConfig_KeyCreatorParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CacheConfig_KeyCreatorParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CacheConfig_KeyCreatorParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.QueryParametersExcluded) > 0 {
		for iNdEx := len(m.QueryParametersExcluded) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.QueryParametersExcluded[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCache(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.QueryParametersIncluded) > 0 {
		for iNdEx := len(m.QueryParametersIncluded) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.QueryParametersIncluded[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCache(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.ExcludeHost {
		i--
		if m.ExcludeHost {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.ExcludeScheme {
		i--
		if m.ExcludeScheme {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintCache(dAtA []byte, offset int, v uint64) int {
	offset -= sovCache(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *CacheConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypedConfig != nil {
		l = m.TypedConfig.Size()
		n += 1 + l + sovCache(uint64(l))
	}
	if len(m.AllowedVaryHeaders) > 0 {
		for _, e := range m.AllowedVaryHeaders {
			l = e.Size()
			n += 1 + l + sovCache(uint64(l))
		}
	}
	if m.KeyCreatorParams != nil {
		l = m.KeyCreatorParams.Size()
		n += 1 + l + sovCache(uint64(l))
	}
	if m.MaxBodyBytes != 0 {
		n += 1 + sovCache(uint64(m.MaxBodyBytes))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CacheConfig_KeyCreatorParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExcludeScheme {
		n += 2
	}
	if m.ExcludeHost {
		n += 2
	}
	if len(m.QueryParametersIncluded) > 0 {
		for _, e := range m.QueryParametersIncluded {
			l = e.Size()
			n += 1 + l + sovCache(uint64(l))
		}
	}
	if len(m.QueryParametersExcluded) > 0 {
		for _, e := range m.QueryParametersExcluded {
			l = e.Size()
			n += 1 + l + sovCache(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovCache(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCache(x uint64) (n int) {
	return sovCache(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CacheConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCache
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CacheConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CacheConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypedConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCache
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCache
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCache
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TypedConfig == nil {
				m.TypedConfig = &types.Any{}
			}
			if err := m.TypedConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedVaryHeaders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCache
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCache
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCache
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowedVaryHeaders = append(m.AllowedVaryHeaders, &matcher.StringMatcher{})
			if err := m.AllowedVaryHeaders[len(m.AllowedVaryHeaders)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyCreatorParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCache
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCache
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCache
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyCreatorParams == nil {
				m.KeyCreatorParams = &CacheConfig_KeyCreatorParams{}
			}
			if err := m.KeyCreatorParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxBodyBytes", wireType)
			}
			m.MaxBodyBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCache
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxBodyBytes |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCache(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCache
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCache
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CacheConfig_KeyCreatorParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCache
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyCreatorParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyCreatorParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExcludeScheme", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCache
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExcludeScheme = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExcludeHost", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCache
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExcludeHost = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryParametersIncluded", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCache
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCache
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCache
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueryParametersIncluded = append(m.QueryParametersIncluded, &route.QueryParameterMatcher{})
			if err := m.QueryParametersIncluded[len(m.QueryParametersIncluded)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryParametersExcluded", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCache
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCache
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCache
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueryParametersExcluded = append(m.QueryParametersExcluded, &route.QueryParameterMatcher{})
			if err := m.QueryParametersExcluded[len(m.QueryParametersExcluded)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCache(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCache
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCache
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCache(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCache
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCache
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCache
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCache
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCache
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCache
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCache        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCache          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCache = fmt.Errorf("proto: unexpected end of group")
)
