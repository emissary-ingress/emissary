// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: envoy/config/cluster/v3/cluster.proto

package envoy_config_cluster_v3

import (
	fmt "fmt"
	_ "github.com/cncf/udpa/go/udpa/annotations"
	_ "github.com/datawire/ambassador/pkg/api/envoy/annotations"
	v31 "github.com/datawire/ambassador/pkg/api/envoy/config/core/v3"
	v3 "github.com/datawire/ambassador/pkg/api/envoy/config/endpoint/v3"
	v32 "github.com/datawire/ambassador/pkg/api/envoy/type/v3"
	_ "github.com/envoyproxy/protoc-gen-validate/validate"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Refer to :ref:`service discovery type <arch_overview_service_discovery_types>`
// for an explanation on each type.
type Cluster_DiscoveryType int32

const (
	// Refer to the :ref:`static discovery type<arch_overview_service_discovery_types_static>`
	// for an explanation.
	Cluster_STATIC Cluster_DiscoveryType = 0
	// Refer to the :ref:`strict DNS discovery
	// type<arch_overview_service_discovery_types_strict_dns>`
	// for an explanation.
	Cluster_STRICT_DNS Cluster_DiscoveryType = 1
	// Refer to the :ref:`logical DNS discovery
	// type<arch_overview_service_discovery_types_logical_dns>`
	// for an explanation.
	Cluster_LOGICAL_DNS Cluster_DiscoveryType = 2
	// Refer to the :ref:`service discovery type<arch_overview_service_discovery_types_eds>`
	// for an explanation.
	Cluster_EDS Cluster_DiscoveryType = 3
	// Refer to the :ref:`original destination discovery
	// type<arch_overview_service_discovery_types_original_destination>`
	// for an explanation.
	Cluster_ORIGINAL_DST Cluster_DiscoveryType = 4
)

var Cluster_DiscoveryType_name = map[int32]string{
	0: "STATIC",
	1: "STRICT_DNS",
	2: "LOGICAL_DNS",
	3: "EDS",
	4: "ORIGINAL_DST",
}

var Cluster_DiscoveryType_value = map[string]int32{
	"STATIC":       0,
	"STRICT_DNS":   1,
	"LOGICAL_DNS":  2,
	"EDS":          3,
	"ORIGINAL_DST": 4,
}

func (x Cluster_DiscoveryType) String() string {
	return proto.EnumName(Cluster_DiscoveryType_name, int32(x))
}

func (Cluster_DiscoveryType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_492f551da3119ad4, []int{0, 0}
}

// Refer to :ref:`load balancer type <arch_overview_load_balancing_types>` architecture
// overview section for information on each type.
type Cluster_LbPolicy int32

const (
	// Refer to the :ref:`round robin load balancing
	// policy<arch_overview_load_balancing_types_round_robin>`
	// for an explanation.
	Cluster_ROUND_ROBIN Cluster_LbPolicy = 0
	// Refer to the :ref:`least request load balancing
	// policy<arch_overview_load_balancing_types_least_request>`
	// for an explanation.
	Cluster_LEAST_REQUEST Cluster_LbPolicy = 1
	// Refer to the :ref:`ring hash load balancing
	// policy<arch_overview_load_balancing_types_ring_hash>`
	// for an explanation.
	Cluster_RING_HASH Cluster_LbPolicy = 2
	// Refer to the :ref:`random load balancing
	// policy<arch_overview_load_balancing_types_random>`
	// for an explanation.
	Cluster_RANDOM Cluster_LbPolicy = 3
	// Refer to the :ref:`Maglev load balancing policy<arch_overview_load_balancing_types_maglev>`
	// for an explanation.
	Cluster_MAGLEV Cluster_LbPolicy = 5
	// This load balancer type must be specified if the configured cluster provides a cluster
	// specific load balancer. Consult the configured cluster's documentation for whether to set
	// this option or not.
	Cluster_CLUSTER_PROVIDED Cluster_LbPolicy = 6
	// [#not-implemented-hide:] Use the new :ref:`load_balancing_policy
	// <envoy_api_field_config.cluster.v3.Cluster.load_balancing_policy>` field to determine the LB policy.
	// [#next-major-version: In the v3 API, we should consider deprecating the lb_policy field
	// and instead using the new load_balancing_policy field as the one and only mechanism for
	// configuring this.]
	Cluster_LOAD_BALANCING_POLICY_CONFIG Cluster_LbPolicy = 7
)

var Cluster_LbPolicy_name = map[int32]string{
	0: "ROUND_ROBIN",
	1: "LEAST_REQUEST",
	2: "RING_HASH",
	3: "RANDOM",
	5: "MAGLEV",
	6: "CLUSTER_PROVIDED",
	7: "LOAD_BALANCING_POLICY_CONFIG",
}

var Cluster_LbPolicy_value = map[string]int32{
	"ROUND_ROBIN":                  0,
	"LEAST_REQUEST":                1,
	"RING_HASH":                    2,
	"RANDOM":                       3,
	"MAGLEV":                       5,
	"CLUSTER_PROVIDED":             6,
	"LOAD_BALANCING_POLICY_CONFIG": 7,
}

func (x Cluster_LbPolicy) String() string {
	return proto.EnumName(Cluster_LbPolicy_name, int32(x))
}

func (Cluster_LbPolicy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_492f551da3119ad4, []int{0, 1}
}

// When V4_ONLY is selected, the DNS resolver will only perform a lookup for
// addresses in the IPv4 family. If V6_ONLY is selected, the DNS resolver will
// only perform a lookup for addresses in the IPv6 family. If AUTO is
// specified, the DNS resolver will first perform a lookup for addresses in
// the IPv6 family and fallback to a lookup for addresses in the IPv4 family.
// For cluster types other than
// :ref:`STRICT_DNS<envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>` and
// :ref:`LOGICAL_DNS<envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`,
// this setting is
// ignored.
type Cluster_DnsLookupFamily int32

const (
	Cluster_AUTO    Cluster_DnsLookupFamily = 0
	Cluster_V4_ONLY Cluster_DnsLookupFamily = 1
	Cluster_V6_ONLY Cluster_DnsLookupFamily = 2
)

var Cluster_DnsLookupFamily_name = map[int32]string{
	0: "AUTO",
	1: "V4_ONLY",
	2: "V6_ONLY",
}

var Cluster_DnsLookupFamily_value = map[string]int32{
	"AUTO":    0,
	"V4_ONLY": 1,
	"V6_ONLY": 2,
}

func (x Cluster_DnsLookupFamily) String() string {
	return proto.EnumName(Cluster_DnsLookupFamily_name, int32(x))
}

func (Cluster_DnsLookupFamily) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_492f551da3119ad4, []int{0, 2}
}

type Cluster_ClusterProtocolSelection int32

const (
	// Cluster can only operate on one of the possible upstream protocols (HTTP1.1, HTTP2).
	// If :ref:`http2_protocol_options <envoy_api_field_config.cluster.v3.Cluster.http2_protocol_options>` are
	// present, HTTP2 will be used, otherwise HTTP1.1 will be used.
	Cluster_USE_CONFIGURED_PROTOCOL Cluster_ClusterProtocolSelection = 0
	// Use HTTP1.1 or HTTP2, depending on which one is used on the downstream connection.
	Cluster_USE_DOWNSTREAM_PROTOCOL Cluster_ClusterProtocolSelection = 1
)

var Cluster_ClusterProtocolSelection_name = map[int32]string{
	0: "USE_CONFIGURED_PROTOCOL",
	1: "USE_DOWNSTREAM_PROTOCOL",
}

var Cluster_ClusterProtocolSelection_value = map[string]int32{
	"USE_CONFIGURED_PROTOCOL": 0,
	"USE_DOWNSTREAM_PROTOCOL": 1,
}

func (x Cluster_ClusterProtocolSelection) String() string {
	return proto.EnumName(Cluster_ClusterProtocolSelection_name, int32(x))
}

func (Cluster_ClusterProtocolSelection) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_492f551da3119ad4, []int{0, 3}
}

// If NO_FALLBACK is selected, a result
// equivalent to no healthy hosts is reported. If ANY_ENDPOINT is selected,
// any cluster endpoint may be returned (subject to policy, health checks,
// etc). If DEFAULT_SUBSET is selected, load balancing is performed over the
// endpoints matching the values from the default_subset field.
type Cluster_LbSubsetConfig_LbSubsetFallbackPolicy int32

const (
	Cluster_LbSubsetConfig_NO_FALLBACK    Cluster_LbSubsetConfig_LbSubsetFallbackPolicy = 0
	Cluster_LbSubsetConfig_ANY_ENDPOINT   Cluster_LbSubsetConfig_LbSubsetFallbackPolicy = 1
	Cluster_LbSubsetConfig_DEFAULT_SUBSET Cluster_LbSubsetConfig_LbSubsetFallbackPolicy = 2
)

var Cluster_LbSubsetConfig_LbSubsetFallbackPolicy_name = map[int32]string{
	0: "NO_FALLBACK",
	1: "ANY_ENDPOINT",
	2: "DEFAULT_SUBSET",
}

var Cluster_LbSubsetConfig_LbSubsetFallbackPolicy_value = map[string]int32{
	"NO_FALLBACK":    0,
	"ANY_ENDPOINT":   1,
	"DEFAULT_SUBSET": 2,
}

func (x Cluster_LbSubsetConfig_LbSubsetFallbackPolicy) String() string {
	return proto.EnumName(Cluster_LbSubsetConfig_LbSubsetFallbackPolicy_name, int32(x))
}

func (Cluster_LbSubsetConfig_LbSubsetFallbackPolicy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_492f551da3119ad4, []int{0, 3, 0}
}

// Allows to override top level fallback policy per selector.
type Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy int32

const (
	// If NOT_DEFINED top level config fallback policy is used instead.
	Cluster_LbSubsetConfig_LbSubsetSelector_NOT_DEFINED Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy = 0
	// If NO_FALLBACK is selected, a result equivalent to no healthy hosts is reported.
	Cluster_LbSubsetConfig_LbSubsetSelector_NO_FALLBACK Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy = 1
	// If ANY_ENDPOINT is selected, any cluster endpoint may be returned
	// (subject to policy, health checks, etc).
	Cluster_LbSubsetConfig_LbSubsetSelector_ANY_ENDPOINT Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy = 2
	// If DEFAULT_SUBSET is selected, load balancing is performed over the
	// endpoints matching the values from the default_subset field.
	Cluster_LbSubsetConfig_LbSubsetSelector_DEFAULT_SUBSET Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy = 3
	// If KEYS_SUBSET is selected, subset selector matching is performed again with metadata
	// keys reduced to
	// :ref:`fallback_keys_subset<envoy_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.fallback_keys_subset>`.
	// It allows for a fallback to a different, less specific selector if some of the keys of
	// the selector are considered optional.
	Cluster_LbSubsetConfig_LbSubsetSelector_KEYS_SUBSET Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy = 4
)

var Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy_name = map[int32]string{
	0: "NOT_DEFINED",
	1: "NO_FALLBACK",
	2: "ANY_ENDPOINT",
	3: "DEFAULT_SUBSET",
	4: "KEYS_SUBSET",
}

var Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy_value = map[string]int32{
	"NOT_DEFINED":    0,
	"NO_FALLBACK":    1,
	"ANY_ENDPOINT":   2,
	"DEFAULT_SUBSET": 3,
	"KEYS_SUBSET":    4,
}

func (x Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy) String() string {
	return proto.EnumName(Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy_name, int32(x))
}

func (Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_492f551da3119ad4, []int{0, 3, 0, 0}
}

// The hash function used to hash hosts onto the ketama ring.
type Cluster_RingHashLbConfig_HashFunction int32

const (
	// Use `xxHash <https://github.com/Cyan4973/xxHash>`_, this is the default hash function.
	Cluster_RingHashLbConfig_XX_HASH Cluster_RingHashLbConfig_HashFunction = 0
	// Use `MurmurHash2 <https://sites.google.com/site/murmurhash/>`_, this is compatible with
	// std:hash<string> in GNU libstdc++ 3.4.20 or above. This is typically the case when compiled
	// on Linux and not macOS.
	Cluster_RingHashLbConfig_MURMUR_HASH_2 Cluster_RingHashLbConfig_HashFunction = 1
)

var Cluster_RingHashLbConfig_HashFunction_name = map[int32]string{
	0: "XX_HASH",
	1: "MURMUR_HASH_2",
}

var Cluster_RingHashLbConfig_HashFunction_value = map[string]int32{
	"XX_HASH":       0,
	"MURMUR_HASH_2": 1,
}

func (x Cluster_RingHashLbConfig_HashFunction) String() string {
	return proto.EnumName(Cluster_RingHashLbConfig_HashFunction_name, int32(x))
}

func (Cluster_RingHashLbConfig_HashFunction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_492f551da3119ad4, []int{0, 5, 0}
}

// Configuration for a single upstream cluster.
// [#next-free-field: 48]
type Cluster struct {
	// Configuration to use different transport sockets for different endpoints.
	// The entry of *envoy.transport_socket* in the
	// :ref:`LbEndpoint.Metadata <envoy_api_field_config.endpoint.v3.LbEndpoint.metadata>`
	// is used to match against the transport sockets as they appear in the list. The first
	// :ref:`match <envoy_api_msg_config.cluster.v3.Cluster.TransportSocketMatch>` is used.
	// For example, with the following match
	//
	// .. code-block:: yaml
	//
	//  transport_socket_matches:
	//  - name: "enableMTLS"
	//    match:
	//      acceptMTLS: true
	//    transport_socket:
	//      name: envoy.transport_sockets.tls
	//      config: { ... } # tls socket configuration
	//  - name: "defaultToPlaintext"
	//    match: {}
	//    transport_socket:
	//      name: envoy.transport_sockets.raw_buffer
	//
	// Connections to the endpoints whose metadata value under *envoy.transport_socket*
	// having "acceptMTLS"/"true" key/value pair use the "enableMTLS" socket configuration.
	//
	// If a :ref:`socket match <envoy_api_msg_config.cluster.v3.Cluster.TransportSocketMatch>` with empty match
	// criteria is provided, that always match any endpoint. For example, the "defaultToPlaintext"
	// socket match in case above.
	//
	// If an endpoint metadata's value under *envoy.transport_socket* does not match any
	// *TransportSocketMatch*, socket configuration fallbacks to use the *tls_context* or
	// *transport_socket* specified in this cluster.
	//
	// This field allows gradual and flexible transport socket configuration changes.
	//
	// The metadata of endpoints in EDS can indicate transport socket capabilities. For example,
	// an endpoint's metadata can have two key value pairs as "acceptMTLS": "true",
	// "acceptPlaintext": "true". While some other endpoints, only accepting plaintext traffic
	// has "acceptPlaintext": "true" metadata information.
	//
	// Then the xDS server can configure the CDS to a client, Envoy A, to send mutual TLS
	// traffic for endpoints with "acceptMTLS": "true", by adding a corresponding
	// *TransportSocketMatch* in this field. Other client Envoys receive CDS without
	// *transport_socket_match* set, and still send plain text traffic to the same cluster.
	//
	// [#comment:TODO(incfly): add a detailed architecture doc on intended usage.]
	TransportSocketMatches []*Cluster_TransportSocketMatch `protobuf:"bytes,43,rep,name=transport_socket_matches,json=transportSocketMatches,proto3" json:"transport_socket_matches,omitempty"`
	// Supplies the name of the cluster which must be unique across all clusters.
	// The cluster name is used when emitting
	// :ref:`statistics <config_cluster_manager_cluster_stats>` if :ref:`alt_stat_name
	// <envoy_api_field_config.cluster.v3.Cluster.alt_stat_name>` is not provided.
	// Any ``:`` in the cluster name will be converted to ``_`` when emitting statistics.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// An optional alternative to the cluster name to be used while emitting stats.
	// Any ``:`` in the name will be converted to ``_`` when emitting statistics. This should not be
	// confused with :ref:`Router Filter Header
	// <config_http_filters_router_x-envoy-upstream-alt-stat-name>`.
	AltStatName string `protobuf:"bytes,28,opt,name=alt_stat_name,json=altStatName,proto3" json:"alt_stat_name,omitempty"`
	// Types that are valid to be assigned to ClusterDiscoveryType:
	//	*Cluster_Type
	//	*Cluster_ClusterType
	ClusterDiscoveryType isCluster_ClusterDiscoveryType `protobuf_oneof:"cluster_discovery_type"`
	// Configuration to use for EDS updates for the Cluster.
	EdsClusterConfig *Cluster_EdsClusterConfig `protobuf:"bytes,3,opt,name=eds_cluster_config,json=edsClusterConfig,proto3" json:"eds_cluster_config,omitempty"`
	// The timeout for new network connections to hosts in the cluster.
	ConnectTimeout *types.Duration `protobuf:"bytes,4,opt,name=connect_timeout,json=connectTimeout,proto3" json:"connect_timeout,omitempty"`
	// Soft limit on size of the cluster’s connections read and write buffers. If
	// unspecified, an implementation defined default is applied (1MiB).
	PerConnectionBufferLimitBytes *types.UInt32Value `protobuf:"bytes,5,opt,name=per_connection_buffer_limit_bytes,json=perConnectionBufferLimitBytes,proto3" json:"per_connection_buffer_limit_bytes,omitempty"`
	// The :ref:`load balancer type <arch_overview_load_balancing_types>` to use
	// when picking a host in the cluster.
	LbPolicy Cluster_LbPolicy `protobuf:"varint,6,opt,name=lb_policy,json=lbPolicy,proto3,enum=envoy.config.cluster.v3.Cluster_LbPolicy" json:"lb_policy,omitempty"`
	// Setting this is required for specifying members of
	// :ref:`STATIC<envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STATIC>`,
	// :ref:`STRICT_DNS<envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`
	// or :ref:`LOGICAL_DNS<envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>` clusters.
	// This field supersedes the *hosts* field in the v2 API.
	//
	// .. attention::
	//
	//   Setting this allows non-EDS cluster types to contain embedded EDS equivalent
	//   :ref:`endpoint assignments<envoy_api_msg_config.endpoint.v3.ClusterLoadAssignment>`.
	//
	LoadAssignment *v3.ClusterLoadAssignment `protobuf:"bytes,33,opt,name=load_assignment,json=loadAssignment,proto3" json:"load_assignment,omitempty"`
	// Optional :ref:`active health checking <arch_overview_health_checking>`
	// configuration for the cluster. If no
	// configuration is specified no health checking will be done and all cluster
	// members will be considered healthy at all times.
	HealthChecks []*v31.HealthCheck `protobuf:"bytes,8,rep,name=health_checks,json=healthChecks,proto3" json:"health_checks,omitempty"`
	// Optional maximum requests for a single upstream connection. This parameter
	// is respected by both the HTTP/1.1 and HTTP/2 connection pool
	// implementations. If not specified, there is no limit. Setting this
	// parameter to 1 will effectively disable keep alive.
	MaxRequestsPerConnection *types.UInt32Value `protobuf:"bytes,9,opt,name=max_requests_per_connection,json=maxRequestsPerConnection,proto3" json:"max_requests_per_connection,omitempty"`
	// Optional :ref:`circuit breaking <arch_overview_circuit_break>` for the cluster.
	CircuitBreakers *CircuitBreakers `protobuf:"bytes,10,opt,name=circuit_breakers,json=circuitBreakers,proto3" json:"circuit_breakers,omitempty"`
	// HTTP protocol options that are applied only to upstream HTTP connections.
	// These options apply to all HTTP versions.
	UpstreamHttpProtocolOptions *v31.UpstreamHttpProtocolOptions `protobuf:"bytes,46,opt,name=upstream_http_protocol_options,json=upstreamHttpProtocolOptions,proto3" json:"upstream_http_protocol_options,omitempty"`
	// Additional options when handling HTTP requests upstream. These options will be applicable to
	// both HTTP1 and HTTP2 requests.
	CommonHttpProtocolOptions *v31.HttpProtocolOptions `protobuf:"bytes,29,opt,name=common_http_protocol_options,json=commonHttpProtocolOptions,proto3" json:"common_http_protocol_options,omitempty"`
	// Additional options when handling HTTP1 requests.
	HttpProtocolOptions *v31.Http1ProtocolOptions `protobuf:"bytes,13,opt,name=http_protocol_options,json=httpProtocolOptions,proto3" json:"http_protocol_options,omitempty"`
	// Even if default HTTP2 protocol options are desired, this field must be
	// set so that Envoy will assume that the upstream supports HTTP/2 when
	// making new HTTP connection pool connections. Currently, Envoy only
	// supports prior knowledge for upstream connections. Even if TLS is used
	// with ALPN, `http2_protocol_options` must be specified. As an aside this allows HTTP/2
	// connections to happen over plain text.
	Http2ProtocolOptions *v31.Http2ProtocolOptions `protobuf:"bytes,14,opt,name=http2_protocol_options,json=http2ProtocolOptions,proto3" json:"http2_protocol_options,omitempty"`
	// The extension_protocol_options field is used to provide extension-specific protocol options
	// for upstream connections. The key should match the extension filter name, such as
	// "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
	// specific options.
	TypedExtensionProtocolOptions map[string]*types.Any `protobuf:"bytes,36,rep,name=typed_extension_protocol_options,json=typedExtensionProtocolOptions,proto3" json:"typed_extension_protocol_options,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// If the DNS refresh rate is specified and the cluster type is either
	// :ref:`STRICT_DNS<envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`,
	// or :ref:`LOGICAL_DNS<envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`,
	// this value is used as the cluster’s DNS refresh
	// rate. The value configured must be at least 1ms. If this setting is not specified, the
	// value defaults to 5000ms. For cluster types other than
	// :ref:`STRICT_DNS<envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`
	// and :ref:`LOGICAL_DNS<envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`
	// this setting is ignored.
	DnsRefreshRate *types.Duration `protobuf:"bytes,16,opt,name=dns_refresh_rate,json=dnsRefreshRate,proto3" json:"dns_refresh_rate,omitempty"`
	// If the DNS failure refresh rate is specified and the cluster type is either
	// :ref:`STRICT_DNS<envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`,
	// or :ref:`LOGICAL_DNS<envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`,
	// this is used as the cluster’s DNS refresh rate when requests are failing. If this setting is
	// not specified, the failure refresh rate defaults to the DNS refresh rate. For cluster types
	// other than :ref:`STRICT_DNS<envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>` and
	// :ref:`LOGICAL_DNS<envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>` this setting is
	// ignored.
	DnsFailureRefreshRate *Cluster_RefreshRate `protobuf:"bytes,44,opt,name=dns_failure_refresh_rate,json=dnsFailureRefreshRate,proto3" json:"dns_failure_refresh_rate,omitempty"`
	// Optional configuration for setting cluster's DNS refresh rate. If the value is set to true,
	// cluster's DNS refresh rate will be set to resource record's TTL which comes from DNS
	// resolution.
	RespectDnsTtl bool `protobuf:"varint,39,opt,name=respect_dns_ttl,json=respectDnsTtl,proto3" json:"respect_dns_ttl,omitempty"`
	// The DNS IP address resolution policy. If this setting is not specified, the
	// value defaults to
	// :ref:`AUTO<envoy_api_enum_value_config.cluster.v3.Cluster.DnsLookupFamily.AUTO>`.
	DnsLookupFamily Cluster_DnsLookupFamily `protobuf:"varint,17,opt,name=dns_lookup_family,json=dnsLookupFamily,proto3,enum=envoy.config.cluster.v3.Cluster_DnsLookupFamily" json:"dns_lookup_family,omitempty"`
	// If DNS resolvers are specified and the cluster type is either
	// :ref:`STRICT_DNS<envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`,
	// or :ref:`LOGICAL_DNS<envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`,
	// this value is used to specify the cluster’s dns resolvers.
	// If this setting is not specified, the value defaults to the default
	// resolver, which uses /etc/resolv.conf for configuration. For cluster types
	// other than
	// :ref:`STRICT_DNS<envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`
	// and :ref:`LOGICAL_DNS<envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`
	// this setting is ignored.
	DnsResolvers []*v31.Address `protobuf:"bytes,18,rep,name=dns_resolvers,json=dnsResolvers,proto3" json:"dns_resolvers,omitempty"`
	// [#next-major-version: Reconcile DNS options in a single message.]
	// Always use TCP queries instead of UDP queries for DNS lookups.
	UseTcpForDnsLookups bool `protobuf:"varint,45,opt,name=use_tcp_for_dns_lookups,json=useTcpForDnsLookups,proto3" json:"use_tcp_for_dns_lookups,omitempty"`
	// If specified, outlier detection will be enabled for this upstream cluster.
	// Each of the configuration values can be overridden via
	// :ref:`runtime values <config_cluster_manager_cluster_runtime_outlier_detection>`.
	OutlierDetection *OutlierDetection `protobuf:"bytes,19,opt,name=outlier_detection,json=outlierDetection,proto3" json:"outlier_detection,omitempty"`
	// The interval for removing stale hosts from a cluster type
	// :ref:`ORIGINAL_DST<envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.ORIGINAL_DST>`.
	// Hosts are considered stale if they have not been used
	// as upstream destinations during this interval. New hosts are added
	// to original destination clusters on demand as new connections are
	// redirected to Envoy, causing the number of hosts in the cluster to
	// grow over time. Hosts that are not stale (they are actively used as
	// destinations) are kept in the cluster, which allows connections to
	// them remain open, saving the latency that would otherwise be spent
	// on opening new connections. If this setting is not specified, the
	// value defaults to 5000ms. For cluster types other than
	// :ref:`ORIGINAL_DST<envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.ORIGINAL_DST>`
	// this setting is ignored.
	CleanupInterval *types.Duration `protobuf:"bytes,20,opt,name=cleanup_interval,json=cleanupInterval,proto3" json:"cleanup_interval,omitempty"`
	// Optional configuration used to bind newly established upstream connections.
	// This overrides any bind_config specified in the bootstrap proto.
	// If the address and port are empty, no bind will be performed.
	UpstreamBindConfig *v31.BindConfig `protobuf:"bytes,21,opt,name=upstream_bind_config,json=upstreamBindConfig,proto3" json:"upstream_bind_config,omitempty"`
	// Configuration for load balancing subsetting.
	LbSubsetConfig *Cluster_LbSubsetConfig `protobuf:"bytes,22,opt,name=lb_subset_config,json=lbSubsetConfig,proto3" json:"lb_subset_config,omitempty"`
	// Optional configuration for the load balancing algorithm selected by
	// LbPolicy. Currently only
	// :ref:`RING_HASH<envoy_api_enum_value_config.cluster.v3.Cluster.LbPolicy.RING_HASH>` and
	// :ref:`LEAST_REQUEST<envoy_api_enum_value_config.cluster.v3.Cluster.LbPolicy.LEAST_REQUEST>`
	// has additional configuration options.
	// Specifying ring_hash_lb_config or least_request_lb_config without setting the corresponding
	// LbPolicy will generate an error at runtime.
	//
	// Types that are valid to be assigned to LbConfig:
	//	*Cluster_RingHashLbConfig_
	//	*Cluster_OriginalDstLbConfig_
	//	*Cluster_LeastRequestLbConfig_
	LbConfig isCluster_LbConfig `protobuf_oneof:"lb_config"`
	// Common configuration for all load balancer implementations.
	CommonLbConfig *Cluster_CommonLbConfig `protobuf:"bytes,27,opt,name=common_lb_config,json=commonLbConfig,proto3" json:"common_lb_config,omitempty"`
	// Optional custom transport socket implementation to use for upstream connections.
	// To setup TLS, set a transport socket with name `tls` and
	// :ref:`UpstreamTlsContexts <envoy_api_msg_extensions.transport_sockets.tls.v3.UpstreamTlsContext>` in the `typed_config`.
	// If no transport socket configuration is specified, new connections
	// will be set up with plaintext.
	TransportSocket *v31.TransportSocket `protobuf:"bytes,24,opt,name=transport_socket,json=transportSocket,proto3" json:"transport_socket,omitempty"`
	// The Metadata field can be used to provide additional information about the
	// cluster. It can be used for stats, logging, and varying filter behavior.
	// Fields should use reverse DNS notation to denote which entity within Envoy
	// will need the information. For instance, if the metadata is intended for
	// the Router filter, the filter name should be specified as *envoy.filters.http.router*.
	Metadata *v31.Metadata `protobuf:"bytes,25,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// Determines how Envoy selects the protocol used to speak to upstream hosts.
	ProtocolSelection Cluster_ClusterProtocolSelection `protobuf:"varint,26,opt,name=protocol_selection,json=protocolSelection,proto3,enum=envoy.config.cluster.v3.Cluster_ClusterProtocolSelection" json:"protocol_selection,omitempty"`
	// Optional options for upstream connections.
	UpstreamConnectionOptions *UpstreamConnectionOptions `protobuf:"bytes,30,opt,name=upstream_connection_options,json=upstreamConnectionOptions,proto3" json:"upstream_connection_options,omitempty"`
	// If an upstream host becomes unhealthy (as determined by the configured health checks
	// or outlier detection), immediately close all connections to the failed host.
	//
	// .. note::
	//
	//   This is currently only supported for connections created by tcp_proxy.
	//
	// .. note::
	//
	//   The current implementation of this feature closes all connections immediately when
	//   the unhealthy status is detected. If there are a large number of connections open
	//   to an upstream host that becomes unhealthy, Envoy may spend a substantial amount of
	//   time exclusively closing these connections, and not processing any other traffic.
	CloseConnectionsOnHostHealthFailure bool `protobuf:"varint,31,opt,name=close_connections_on_host_health_failure,json=closeConnectionsOnHostHealthFailure,proto3" json:"close_connections_on_host_health_failure,omitempty"`
	// If set to true, Envoy will ignore the health value of a host when processing its removal
	// from service discovery. This means that if active health checking is used, Envoy will *not*
	// wait for the endpoint to go unhealthy before removing it.
	IgnoreHealthOnHostRemoval bool `protobuf:"varint,32,opt,name=ignore_health_on_host_removal,json=ignoreHealthOnHostRemoval,proto3" json:"ignore_health_on_host_removal,omitempty"`
	// An (optional) network filter chain, listed in the order the filters should be applied.
	// The chain will be applied to all outgoing connections that Envoy makes to the upstream
	// servers of this cluster.
	Filters []*Filter `protobuf:"bytes,40,rep,name=filters,proto3" json:"filters,omitempty"`
	// [#not-implemented-hide:] New mechanism for LB policy configuration. Used only if the
	// :ref:`lb_policy<envoy_api_field_config.cluster.v3.Cluster.lb_policy>` field has the value
	// :ref:`LOAD_BALANCING_POLICY_CONFIG<envoy_api_enum_value_config.cluster.v3.Cluster.LbPolicy.LOAD_BALANCING_POLICY_CONFIG>`.
	LoadBalancingPolicy *LoadBalancingPolicy `protobuf:"bytes,41,opt,name=load_balancing_policy,json=loadBalancingPolicy,proto3" json:"load_balancing_policy,omitempty"`
	// [#not-implemented-hide:]
	// If present, tells the client where to send load reports via LRS. If not present, the
	// client will fall back to a client-side default, which may be either (a) don't send any
	// load reports or (b) send load reports for all clusters to a single default server
	// (which may be configured in the bootstrap file).
	//
	// Note that if multiple clusters point to the same LRS server, the client may choose to
	// create a separate stream for each cluster or it may choose to coalesce the data for
	// multiple clusters onto a single stream. Either way, the client must make sure to send
	// the data for any given cluster on no more than one stream.
	//
	// [#next-major-version: In the v3 API, we should consider restructuring this somehow,
	// maybe by allowing LRS to go on the ADS stream, or maybe by moving some of the negotiation
	// from the LRS stream here.]
	LrsServer *v31.ConfigSource `protobuf:"bytes,42,opt,name=lrs_server,json=lrsServer,proto3" json:"lrs_server,omitempty"`
	// If track_timeout_budgets is true, the :ref:`timeout budget histograms
	// <config_cluster_manager_cluster_stats_timeout_budgets>` will be published for each
	// request. These show what percentage of a request's per try and global timeout was used. A value
	// of 0 would indicate that none of the timeout was used or that the timeout was infinite. A value
	// of 100 would indicate that the request took the entirety of the timeout given to it.
	TrackTimeoutBudgets  bool     `protobuf:"varint,47,opt,name=track_timeout_budgets,json=trackTimeoutBudgets,proto3" json:"track_timeout_budgets,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Cluster) Reset()         { *m = Cluster{} }
func (m *Cluster) String() string { return proto.CompactTextString(m) }
func (*Cluster) ProtoMessage()    {}
func (*Cluster) Descriptor() ([]byte, []int) {
	return fileDescriptor_492f551da3119ad4, []int{0}
}
func (m *Cluster) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Cluster) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Cluster.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Cluster) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Cluster.Merge(m, src)
}
func (m *Cluster) XXX_Size() int {
	return m.Size()
}
func (m *Cluster) XXX_DiscardUnknown() {
	xxx_messageInfo_Cluster.DiscardUnknown(m)
}

var xxx_messageInfo_Cluster proto.InternalMessageInfo

type isCluster_ClusterDiscoveryType interface {
	isCluster_ClusterDiscoveryType()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isCluster_LbConfig interface {
	isCluster_LbConfig()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Cluster_Type struct {
	Type Cluster_DiscoveryType `protobuf:"varint,2,opt,name=type,proto3,enum=envoy.config.cluster.v3.Cluster_DiscoveryType,oneof" json:"type,omitempty"`
}
type Cluster_ClusterType struct {
	ClusterType *Cluster_CustomClusterType `protobuf:"bytes,38,opt,name=cluster_type,json=clusterType,proto3,oneof" json:"cluster_type,omitempty"`
}
type Cluster_RingHashLbConfig_ struct {
	RingHashLbConfig *Cluster_RingHashLbConfig `protobuf:"bytes,23,opt,name=ring_hash_lb_config,json=ringHashLbConfig,proto3,oneof" json:"ring_hash_lb_config,omitempty"`
}
type Cluster_OriginalDstLbConfig_ struct {
	OriginalDstLbConfig *Cluster_OriginalDstLbConfig `protobuf:"bytes,34,opt,name=original_dst_lb_config,json=originalDstLbConfig,proto3,oneof" json:"original_dst_lb_config,omitempty"`
}
type Cluster_LeastRequestLbConfig_ struct {
	LeastRequestLbConfig *Cluster_LeastRequestLbConfig `protobuf:"bytes,37,opt,name=least_request_lb_config,json=leastRequestLbConfig,proto3,oneof" json:"least_request_lb_config,omitempty"`
}

func (*Cluster_Type) isCluster_ClusterDiscoveryType()        {}
func (*Cluster_ClusterType) isCluster_ClusterDiscoveryType() {}
func (*Cluster_RingHashLbConfig_) isCluster_LbConfig()       {}
func (*Cluster_OriginalDstLbConfig_) isCluster_LbConfig()    {}
func (*Cluster_LeastRequestLbConfig_) isCluster_LbConfig()   {}

func (m *Cluster) GetClusterDiscoveryType() isCluster_ClusterDiscoveryType {
	if m != nil {
		return m.ClusterDiscoveryType
	}
	return nil
}
func (m *Cluster) GetLbConfig() isCluster_LbConfig {
	if m != nil {
		return m.LbConfig
	}
	return nil
}

func (m *Cluster) GetTransportSocketMatches() []*Cluster_TransportSocketMatch {
	if m != nil {
		return m.TransportSocketMatches
	}
	return nil
}

func (m *Cluster) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Cluster) GetAltStatName() string {
	if m != nil {
		return m.AltStatName
	}
	return ""
}

func (m *Cluster) GetType() Cluster_DiscoveryType {
	if x, ok := m.GetClusterDiscoveryType().(*Cluster_Type); ok {
		return x.Type
	}
	return Cluster_STATIC
}

func (m *Cluster) GetClusterType() *Cluster_CustomClusterType {
	if x, ok := m.GetClusterDiscoveryType().(*Cluster_ClusterType); ok {
		return x.ClusterType
	}
	return nil
}

func (m *Cluster) GetEdsClusterConfig() *Cluster_EdsClusterConfig {
	if m != nil {
		return m.EdsClusterConfig
	}
	return nil
}

func (m *Cluster) GetConnectTimeout() *types.Duration {
	if m != nil {
		return m.ConnectTimeout
	}
	return nil
}

func (m *Cluster) GetPerConnectionBufferLimitBytes() *types.UInt32Value {
	if m != nil {
		return m.PerConnectionBufferLimitBytes
	}
	return nil
}

func (m *Cluster) GetLbPolicy() Cluster_LbPolicy {
	if m != nil {
		return m.LbPolicy
	}
	return Cluster_ROUND_ROBIN
}

func (m *Cluster) GetLoadAssignment() *v3.ClusterLoadAssignment {
	if m != nil {
		return m.LoadAssignment
	}
	return nil
}

func (m *Cluster) GetHealthChecks() []*v31.HealthCheck {
	if m != nil {
		return m.HealthChecks
	}
	return nil
}

func (m *Cluster) GetMaxRequestsPerConnection() *types.UInt32Value {
	if m != nil {
		return m.MaxRequestsPerConnection
	}
	return nil
}

func (m *Cluster) GetCircuitBreakers() *CircuitBreakers {
	if m != nil {
		return m.CircuitBreakers
	}
	return nil
}

func (m *Cluster) GetUpstreamHttpProtocolOptions() *v31.UpstreamHttpProtocolOptions {
	if m != nil {
		return m.UpstreamHttpProtocolOptions
	}
	return nil
}

func (m *Cluster) GetCommonHttpProtocolOptions() *v31.HttpProtocolOptions {
	if m != nil {
		return m.CommonHttpProtocolOptions
	}
	return nil
}

func (m *Cluster) GetHttpProtocolOptions() *v31.Http1ProtocolOptions {
	if m != nil {
		return m.HttpProtocolOptions
	}
	return nil
}

func (m *Cluster) GetHttp2ProtocolOptions() *v31.Http2ProtocolOptions {
	if m != nil {
		return m.Http2ProtocolOptions
	}
	return nil
}

func (m *Cluster) GetTypedExtensionProtocolOptions() map[string]*types.Any {
	if m != nil {
		return m.TypedExtensionProtocolOptions
	}
	return nil
}

func (m *Cluster) GetDnsRefreshRate() *types.Duration {
	if m != nil {
		return m.DnsRefreshRate
	}
	return nil
}

func (m *Cluster) GetDnsFailureRefreshRate() *Cluster_RefreshRate {
	if m != nil {
		return m.DnsFailureRefreshRate
	}
	return nil
}

func (m *Cluster) GetRespectDnsTtl() bool {
	if m != nil {
		return m.RespectDnsTtl
	}
	return false
}

func (m *Cluster) GetDnsLookupFamily() Cluster_DnsLookupFamily {
	if m != nil {
		return m.DnsLookupFamily
	}
	return Cluster_AUTO
}

func (m *Cluster) GetDnsResolvers() []*v31.Address {
	if m != nil {
		return m.DnsResolvers
	}
	return nil
}

func (m *Cluster) GetUseTcpForDnsLookups() bool {
	if m != nil {
		return m.UseTcpForDnsLookups
	}
	return false
}

func (m *Cluster) GetOutlierDetection() *OutlierDetection {
	if m != nil {
		return m.OutlierDetection
	}
	return nil
}

func (m *Cluster) GetCleanupInterval() *types.Duration {
	if m != nil {
		return m.CleanupInterval
	}
	return nil
}

func (m *Cluster) GetUpstreamBindConfig() *v31.BindConfig {
	if m != nil {
		return m.UpstreamBindConfig
	}
	return nil
}

func (m *Cluster) GetLbSubsetConfig() *Cluster_LbSubsetConfig {
	if m != nil {
		return m.LbSubsetConfig
	}
	return nil
}

func (m *Cluster) GetRingHashLbConfig() *Cluster_RingHashLbConfig {
	if x, ok := m.GetLbConfig().(*Cluster_RingHashLbConfig_); ok {
		return x.RingHashLbConfig
	}
	return nil
}

func (m *Cluster) GetOriginalDstLbConfig() *Cluster_OriginalDstLbConfig {
	if x, ok := m.GetLbConfig().(*Cluster_OriginalDstLbConfig_); ok {
		return x.OriginalDstLbConfig
	}
	return nil
}

func (m *Cluster) GetLeastRequestLbConfig() *Cluster_LeastRequestLbConfig {
	if x, ok := m.GetLbConfig().(*Cluster_LeastRequestLbConfig_); ok {
		return x.LeastRequestLbConfig
	}
	return nil
}

func (m *Cluster) GetCommonLbConfig() *Cluster_CommonLbConfig {
	if m != nil {
		return m.CommonLbConfig
	}
	return nil
}

func (m *Cluster) GetTransportSocket() *v31.TransportSocket {
	if m != nil {
		return m.TransportSocket
	}
	return nil
}

func (m *Cluster) GetMetadata() *v31.Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *Cluster) GetProtocolSelection() Cluster_ClusterProtocolSelection {
	if m != nil {
		return m.ProtocolSelection
	}
	return Cluster_USE_CONFIGURED_PROTOCOL
}

func (m *Cluster) GetUpstreamConnectionOptions() *UpstreamConnectionOptions {
	if m != nil {
		return m.UpstreamConnectionOptions
	}
	return nil
}

func (m *Cluster) GetCloseConnectionsOnHostHealthFailure() bool {
	if m != nil {
		return m.CloseConnectionsOnHostHealthFailure
	}
	return false
}

func (m *Cluster) GetIgnoreHealthOnHostRemoval() bool {
	if m != nil {
		return m.IgnoreHealthOnHostRemoval
	}
	return false
}

func (m *Cluster) GetFilters() []*Filter {
	if m != nil {
		return m.Filters
	}
	return nil
}

func (m *Cluster) GetLoadBalancingPolicy() *LoadBalancingPolicy {
	if m != nil {
		return m.LoadBalancingPolicy
	}
	return nil
}

func (m *Cluster) GetLrsServer() *v31.ConfigSource {
	if m != nil {
		return m.LrsServer
	}
	return nil
}

func (m *Cluster) GetTrackTimeoutBudgets() bool {
	if m != nil {
		return m.TrackTimeoutBudgets
	}
	return false
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Cluster) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Cluster_Type)(nil),
		(*Cluster_ClusterType)(nil),
		(*Cluster_RingHashLbConfig_)(nil),
		(*Cluster_OriginalDstLbConfig_)(nil),
		(*Cluster_LeastRequestLbConfig_)(nil),
	}
}

// TransportSocketMatch specifies what transport socket config will be used
// when the match conditions are satisfied.
type Cluster_TransportSocketMatch struct {
	// The name of the match, used in stats generation.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Optional endpoint metadata match criteria.
	// The connection to the endpoint with metadata matching what is set in this field
	// will use the transport socket configuration specified here.
	// The endpoint's metadata entry in *envoy.transport_socket_match* is used to match
	// against the values specified in this field.
	Match *types.Struct `protobuf:"bytes,2,opt,name=match,proto3" json:"match,omitempty"`
	// The configuration of the transport socket.
	TransportSocket      *v31.TransportSocket `protobuf:"bytes,3,opt,name=transport_socket,json=transportSocket,proto3" json:"transport_socket,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *Cluster_TransportSocketMatch) Reset()         { *m = Cluster_TransportSocketMatch{} }
func (m *Cluster_TransportSocketMatch) String() string { return proto.CompactTextString(m) }
func (*Cluster_TransportSocketMatch) ProtoMessage()    {}
func (*Cluster_TransportSocketMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_492f551da3119ad4, []int{0, 0}
}
func (m *Cluster_TransportSocketMatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Cluster_TransportSocketMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Cluster_TransportSocketMatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Cluster_TransportSocketMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Cluster_TransportSocketMatch.Merge(m, src)
}
func (m *Cluster_TransportSocketMatch) XXX_Size() int {
	return m.Size()
}
func (m *Cluster_TransportSocketMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_Cluster_TransportSocketMatch.DiscardUnknown(m)
}

var xxx_messageInfo_Cluster_TransportSocketMatch proto.InternalMessageInfo

func (m *Cluster_TransportSocketMatch) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Cluster_TransportSocketMatch) GetMatch() *types.Struct {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *Cluster_TransportSocketMatch) GetTransportSocket() *v31.TransportSocket {
	if m != nil {
		return m.TransportSocket
	}
	return nil
}

// Extended cluster type.
type Cluster_CustomClusterType struct {
	// The type of the cluster to instantiate. The name must match a supported cluster type.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Cluster specific configuration which depends on the cluster being instantiated.
	// See the supported cluster for further documentation.
	TypedConfig          *types.Any `protobuf:"bytes,2,opt,name=typed_config,json=typedConfig,proto3" json:"typed_config,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Cluster_CustomClusterType) Reset()         { *m = Cluster_CustomClusterType{} }
func (m *Cluster_CustomClusterType) String() string { return proto.CompactTextString(m) }
func (*Cluster_CustomClusterType) ProtoMessage()    {}
func (*Cluster_CustomClusterType) Descriptor() ([]byte, []int) {
	return fileDescriptor_492f551da3119ad4, []int{0, 1}
}
func (m *Cluster_CustomClusterType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Cluster_CustomClusterType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Cluster_CustomClusterType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Cluster_CustomClusterType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Cluster_CustomClusterType.Merge(m, src)
}
func (m *Cluster_CustomClusterType) XXX_Size() int {
	return m.Size()
}
func (m *Cluster_CustomClusterType) XXX_DiscardUnknown() {
	xxx_messageInfo_Cluster_CustomClusterType.DiscardUnknown(m)
}

var xxx_messageInfo_Cluster_CustomClusterType proto.InternalMessageInfo

func (m *Cluster_CustomClusterType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Cluster_CustomClusterType) GetTypedConfig() *types.Any {
	if m != nil {
		return m.TypedConfig
	}
	return nil
}

// Only valid when discovery type is EDS.
type Cluster_EdsClusterConfig struct {
	// Configuration for the source of EDS updates for this Cluster.
	EdsConfig *v31.ConfigSource `protobuf:"bytes,1,opt,name=eds_config,json=edsConfig,proto3" json:"eds_config,omitempty"`
	// Optional alternative to cluster name to present to EDS. This does not
	// have the same restrictions as cluster name, i.e. it may be arbitrary
	// length.
	ServiceName          string   `protobuf:"bytes,2,opt,name=service_name,json=serviceName,proto3" json:"service_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Cluster_EdsClusterConfig) Reset()         { *m = Cluster_EdsClusterConfig{} }
func (m *Cluster_EdsClusterConfig) String() string { return proto.CompactTextString(m) }
func (*Cluster_EdsClusterConfig) ProtoMessage()    {}
func (*Cluster_EdsClusterConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_492f551da3119ad4, []int{0, 2}
}
func (m *Cluster_EdsClusterConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Cluster_EdsClusterConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Cluster_EdsClusterConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Cluster_EdsClusterConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Cluster_EdsClusterConfig.Merge(m, src)
}
func (m *Cluster_EdsClusterConfig) XXX_Size() int {
	return m.Size()
}
func (m *Cluster_EdsClusterConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_Cluster_EdsClusterConfig.DiscardUnknown(m)
}

var xxx_messageInfo_Cluster_EdsClusterConfig proto.InternalMessageInfo

func (m *Cluster_EdsClusterConfig) GetEdsConfig() *v31.ConfigSource {
	if m != nil {
		return m.EdsConfig
	}
	return nil
}

func (m *Cluster_EdsClusterConfig) GetServiceName() string {
	if m != nil {
		return m.ServiceName
	}
	return ""
}

// Optionally divide the endpoints in this cluster into subsets defined by
// endpoint metadata and selected by route and weighted cluster metadata.
// [#next-free-field: 8]
type Cluster_LbSubsetConfig struct {
	// The behavior used when no endpoint subset matches the selected route's
	// metadata. The value defaults to
	// :ref:`NO_FALLBACK<envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK>`.
	FallbackPolicy Cluster_LbSubsetConfig_LbSubsetFallbackPolicy `protobuf:"varint,1,opt,name=fallback_policy,json=fallbackPolicy,proto3,enum=envoy.config.cluster.v3.Cluster_LbSubsetConfig_LbSubsetFallbackPolicy" json:"fallback_policy,omitempty"`
	// Specifies the default subset of endpoints used during fallback if
	// fallback_policy is
	// :ref:`DEFAULT_SUBSET<envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.DEFAULT_SUBSET>`.
	// Each field in default_subset is
	// compared to the matching LbEndpoint.Metadata under the *envoy.lb*
	// namespace. It is valid for no hosts to match, in which case the behavior
	// is the same as a fallback_policy of
	// :ref:`NO_FALLBACK<envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK>`.
	DefaultSubset *types.Struct `protobuf:"bytes,2,opt,name=default_subset,json=defaultSubset,proto3" json:"default_subset,omitempty"`
	// For each entry, LbEndpoint.Metadata's
	// *envoy.lb* namespace is traversed and a subset is created for each unique
	// combination of key and value. For example:
	//
	// .. code-block:: json
	//
	//   { "subset_selectors": [
	//       { "keys": [ "version" ] },
	//       { "keys": [ "stage", "hardware_type" ] }
	//   ]}
	//
	// A subset is matched when the metadata from the selected route and
	// weighted cluster contains the same keys and values as the subset's
	// metadata. The same host may appear in multiple subsets.
	SubsetSelectors []*Cluster_LbSubsetConfig_LbSubsetSelector `protobuf:"bytes,3,rep,name=subset_selectors,json=subsetSelectors,proto3" json:"subset_selectors,omitempty"`
	// If true, routing to subsets will take into account the localities and locality weights of the
	// endpoints when making the routing decision.
	//
	// There are some potential pitfalls associated with enabling this feature, as the resulting
	// traffic split after applying both a subset match and locality weights might be undesirable.
	//
	// Consider for example a situation in which you have 50/50 split across two localities X/Y
	// which have 100 hosts each without subsetting. If the subset LB results in X having only 1
	// host selected but Y having 100, then a lot more load is being dumped on the single host in X
	// than originally anticipated in the load balancing assignment delivered via EDS.
	LocalityWeightAware bool `protobuf:"varint,4,opt,name=locality_weight_aware,json=localityWeightAware,proto3" json:"locality_weight_aware,omitempty"`
	// When used with locality_weight_aware, scales the weight of each locality by the ratio
	// of hosts in the subset vs hosts in the original subset. This aims to even out the load
	// going to an individual locality if said locality is disproportionately affected by the
	// subset predicate.
	ScaleLocalityWeight bool `protobuf:"varint,5,opt,name=scale_locality_weight,json=scaleLocalityWeight,proto3" json:"scale_locality_weight,omitempty"`
	// If true, when a fallback policy is configured and its corresponding subset fails to find
	// a host this will cause any host to be selected instead.
	//
	// This is useful when using the default subset as the fallback policy, given the default
	// subset might become empty. With this option enabled, if that happens the LB will attempt
	// to select a host from the entire cluster.
	PanicModeAny bool `protobuf:"varint,6,opt,name=panic_mode_any,json=panicModeAny,proto3" json:"panic_mode_any,omitempty"`
	// If true, metadata specified for a metadata key will be matched against the corresponding
	// endpoint metadata if the endpoint metadata matches the value exactly OR it is a list value
	// and any of the elements in the list matches the criteria.
	ListAsAny            bool     `protobuf:"varint,7,opt,name=list_as_any,json=listAsAny,proto3" json:"list_as_any,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Cluster_LbSubsetConfig) Reset()         { *m = Cluster_LbSubsetConfig{} }
func (m *Cluster_LbSubsetConfig) String() string { return proto.CompactTextString(m) }
func (*Cluster_LbSubsetConfig) ProtoMessage()    {}
func (*Cluster_LbSubsetConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_492f551da3119ad4, []int{0, 3}
}
func (m *Cluster_LbSubsetConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Cluster_LbSubsetConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Cluster_LbSubsetConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Cluster_LbSubsetConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Cluster_LbSubsetConfig.Merge(m, src)
}
func (m *Cluster_LbSubsetConfig) XXX_Size() int {
	return m.Size()
}
func (m *Cluster_LbSubsetConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_Cluster_LbSubsetConfig.DiscardUnknown(m)
}

var xxx_messageInfo_Cluster_LbSubsetConfig proto.InternalMessageInfo

func (m *Cluster_LbSubsetConfig) GetFallbackPolicy() Cluster_LbSubsetConfig_LbSubsetFallbackPolicy {
	if m != nil {
		return m.FallbackPolicy
	}
	return Cluster_LbSubsetConfig_NO_FALLBACK
}

func (m *Cluster_LbSubsetConfig) GetDefaultSubset() *types.Struct {
	if m != nil {
		return m.DefaultSubset
	}
	return nil
}

func (m *Cluster_LbSubsetConfig) GetSubsetSelectors() []*Cluster_LbSubsetConfig_LbSubsetSelector {
	if m != nil {
		return m.SubsetSelectors
	}
	return nil
}

func (m *Cluster_LbSubsetConfig) GetLocalityWeightAware() bool {
	if m != nil {
		return m.LocalityWeightAware
	}
	return false
}

func (m *Cluster_LbSubsetConfig) GetScaleLocalityWeight() bool {
	if m != nil {
		return m.ScaleLocalityWeight
	}
	return false
}

func (m *Cluster_LbSubsetConfig) GetPanicModeAny() bool {
	if m != nil {
		return m.PanicModeAny
	}
	return false
}

func (m *Cluster_LbSubsetConfig) GetListAsAny() bool {
	if m != nil {
		return m.ListAsAny
	}
	return false
}

// Specifications for subsets.
type Cluster_LbSubsetConfig_LbSubsetSelector struct {
	// List of keys to match with the weighted cluster metadata.
	Keys []string `protobuf:"bytes,1,rep,name=keys,proto3" json:"keys,omitempty"`
	// The behavior used when no endpoint subset matches the selected route's
	// metadata.
	FallbackPolicy Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy `protobuf:"varint,2,opt,name=fallback_policy,json=fallbackPolicy,proto3,enum=envoy.config.cluster.v3.Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy" json:"fallback_policy,omitempty"`
	// Subset of
	// :ref:`keys<envoy_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.keys>` used by
	// :ref:`KEYS_SUBSET<envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy.KEYS_SUBSET>`
	// fallback policy.
	// It has to be a non empty list if KEYS_SUBSET fallback policy is selected.
	// For any other fallback policy the parameter is not used and should not be set.
	// Only values also present in
	// :ref:`keys<envoy_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.keys>` are allowed, but
	// `fallback_keys_subset` cannot be equal to `keys`.
	FallbackKeysSubset   []string `protobuf:"bytes,3,rep,name=fallback_keys_subset,json=fallbackKeysSubset,proto3" json:"fallback_keys_subset,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Cluster_LbSubsetConfig_LbSubsetSelector) Reset() {
	*m = Cluster_LbSubsetConfig_LbSubsetSelector{}
}
func (m *Cluster_LbSubsetConfig_LbSubsetSelector) String() string { return proto.CompactTextString(m) }
func (*Cluster_LbSubsetConfig_LbSubsetSelector) ProtoMessage()    {}
func (*Cluster_LbSubsetConfig_LbSubsetSelector) Descriptor() ([]byte, []int) {
	return fileDescriptor_492f551da3119ad4, []int{0, 3, 0}
}
func (m *Cluster_LbSubsetConfig_LbSubsetSelector) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Cluster_LbSubsetConfig_LbSubsetSelector) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Cluster_LbSubsetConfig_LbSubsetSelector.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Cluster_LbSubsetConfig_LbSubsetSelector) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Cluster_LbSubsetConfig_LbSubsetSelector.Merge(m, src)
}
func (m *Cluster_LbSubsetConfig_LbSubsetSelector) XXX_Size() int {
	return m.Size()
}
func (m *Cluster_LbSubsetConfig_LbSubsetSelector) XXX_DiscardUnknown() {
	xxx_messageInfo_Cluster_LbSubsetConfig_LbSubsetSelector.DiscardUnknown(m)
}

var xxx_messageInfo_Cluster_LbSubsetConfig_LbSubsetSelector proto.InternalMessageInfo

func (m *Cluster_LbSubsetConfig_LbSubsetSelector) GetKeys() []string {
	if m != nil {
		return m.Keys
	}
	return nil
}

func (m *Cluster_LbSubsetConfig_LbSubsetSelector) GetFallbackPolicy() Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy {
	if m != nil {
		return m.FallbackPolicy
	}
	return Cluster_LbSubsetConfig_LbSubsetSelector_NOT_DEFINED
}

func (m *Cluster_LbSubsetConfig_LbSubsetSelector) GetFallbackKeysSubset() []string {
	if m != nil {
		return m.FallbackKeysSubset
	}
	return nil
}

// Specific configuration for the LeastRequest load balancing policy.
type Cluster_LeastRequestLbConfig struct {
	// The number of random healthy hosts from which the host with the fewest active requests will
	// be chosen. Defaults to 2 so that we perform two-choice selection if the field is not set.
	ChoiceCount          *types.UInt32Value `protobuf:"bytes,1,opt,name=choice_count,json=choiceCount,proto3" json:"choice_count,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *Cluster_LeastRequestLbConfig) Reset()         { *m = Cluster_LeastRequestLbConfig{} }
func (m *Cluster_LeastRequestLbConfig) String() string { return proto.CompactTextString(m) }
func (*Cluster_LeastRequestLbConfig) ProtoMessage()    {}
func (*Cluster_LeastRequestLbConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_492f551da3119ad4, []int{0, 4}
}
func (m *Cluster_LeastRequestLbConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Cluster_LeastRequestLbConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Cluster_LeastRequestLbConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Cluster_LeastRequestLbConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Cluster_LeastRequestLbConfig.Merge(m, src)
}
func (m *Cluster_LeastRequestLbConfig) XXX_Size() int {
	return m.Size()
}
func (m *Cluster_LeastRequestLbConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_Cluster_LeastRequestLbConfig.DiscardUnknown(m)
}

var xxx_messageInfo_Cluster_LeastRequestLbConfig proto.InternalMessageInfo

func (m *Cluster_LeastRequestLbConfig) GetChoiceCount() *types.UInt32Value {
	if m != nil {
		return m.ChoiceCount
	}
	return nil
}

// Specific configuration for the :ref:`RingHash<arch_overview_load_balancing_types_ring_hash>`
// load balancing policy.
type Cluster_RingHashLbConfig struct {
	// Minimum hash ring size. The larger the ring is (that is, the more hashes there are for each
	// provided host) the better the request distribution will reflect the desired weights. Defaults
	// to 1024 entries, and limited to 8M entries. See also
	// :ref:`maximum_ring_size<envoy_api_field_config.cluster.v3.Cluster.RingHashLbConfig.maximum_ring_size>`.
	MinimumRingSize *types.UInt64Value `protobuf:"bytes,1,opt,name=minimum_ring_size,json=minimumRingSize,proto3" json:"minimum_ring_size,omitempty"`
	// The hash function used to hash hosts onto the ketama ring. The value defaults to
	// :ref:`XX_HASH<envoy_api_enum_value_config.cluster.v3.Cluster.RingHashLbConfig.HashFunction.XX_HASH>`.
	HashFunction Cluster_RingHashLbConfig_HashFunction `protobuf:"varint,3,opt,name=hash_function,json=hashFunction,proto3,enum=envoy.config.cluster.v3.Cluster_RingHashLbConfig_HashFunction" json:"hash_function,omitempty"`
	// Maximum hash ring size. Defaults to 8M entries, and limited to 8M entries, but can be lowered
	// to further constrain resource use. See also
	// :ref:`minimum_ring_size<envoy_api_field_config.cluster.v3.Cluster.RingHashLbConfig.minimum_ring_size>`.
	MaximumRingSize      *types.UInt64Value `protobuf:"bytes,4,opt,name=maximum_ring_size,json=maximumRingSize,proto3" json:"maximum_ring_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *Cluster_RingHashLbConfig) Reset()         { *m = Cluster_RingHashLbConfig{} }
func (m *Cluster_RingHashLbConfig) String() string { return proto.CompactTextString(m) }
func (*Cluster_RingHashLbConfig) ProtoMessage()    {}
func (*Cluster_RingHashLbConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_492f551da3119ad4, []int{0, 5}
}
func (m *Cluster_RingHashLbConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Cluster_RingHashLbConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Cluster_RingHashLbConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Cluster_RingHashLbConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Cluster_RingHashLbConfig.Merge(m, src)
}
func (m *Cluster_RingHashLbConfig) XXX_Size() int {
	return m.Size()
}
func (m *Cluster_RingHashLbConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_Cluster_RingHashLbConfig.DiscardUnknown(m)
}

var xxx_messageInfo_Cluster_RingHashLbConfig proto.InternalMessageInfo

func (m *Cluster_RingHashLbConfig) GetMinimumRingSize() *types.UInt64Value {
	if m != nil {
		return m.MinimumRingSize
	}
	return nil
}

func (m *Cluster_RingHashLbConfig) GetHashFunction() Cluster_RingHashLbConfig_HashFunction {
	if m != nil {
		return m.HashFunction
	}
	return Cluster_RingHashLbConfig_XX_HASH
}

func (m *Cluster_RingHashLbConfig) GetMaximumRingSize() *types.UInt64Value {
	if m != nil {
		return m.MaximumRingSize
	}
	return nil
}

// Specific configuration for the
// :ref:`Original Destination <arch_overview_load_balancing_types_original_destination>`
// load balancing policy.
type Cluster_OriginalDstLbConfig struct {
	// When true, :ref:`x-envoy-original-dst-host
	// <config_http_conn_man_headers_x-envoy-original-dst-host>` can be used to override destination
	// address.
	//
	// .. attention::
	//
	//   This header isn't sanitized by default, so enabling this feature allows HTTP clients to
	//   route traffic to arbitrary hosts and/or ports, which may have serious security
	//   consequences.
	UseHttpHeader        bool     `protobuf:"varint,1,opt,name=use_http_header,json=useHttpHeader,proto3" json:"use_http_header,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Cluster_OriginalDstLbConfig) Reset()         { *m = Cluster_OriginalDstLbConfig{} }
func (m *Cluster_OriginalDstLbConfig) String() string { return proto.CompactTextString(m) }
func (*Cluster_OriginalDstLbConfig) ProtoMessage()    {}
func (*Cluster_OriginalDstLbConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_492f551da3119ad4, []int{0, 6}
}
func (m *Cluster_OriginalDstLbConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Cluster_OriginalDstLbConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Cluster_OriginalDstLbConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Cluster_OriginalDstLbConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Cluster_OriginalDstLbConfig.Merge(m, src)
}
func (m *Cluster_OriginalDstLbConfig) XXX_Size() int {
	return m.Size()
}
func (m *Cluster_OriginalDstLbConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_Cluster_OriginalDstLbConfig.DiscardUnknown(m)
}

var xxx_messageInfo_Cluster_OriginalDstLbConfig proto.InternalMessageInfo

func (m *Cluster_OriginalDstLbConfig) GetUseHttpHeader() bool {
	if m != nil {
		return m.UseHttpHeader
	}
	return false
}

// Common configuration for all load balancer implementations.
// [#next-free-field: 8]
type Cluster_CommonLbConfig struct {
	// Configures the :ref:`healthy panic threshold <arch_overview_load_balancing_panic_threshold>`.
	// If not specified, the default is 50%.
	// To disable panic mode, set to 0%.
	//
	// .. note::
	//   The specified percent will be truncated to the nearest 1%.
	HealthyPanicThreshold *v32.Percent `protobuf:"bytes,1,opt,name=healthy_panic_threshold,json=healthyPanicThreshold,proto3" json:"healthy_panic_threshold,omitempty"`
	// Types that are valid to be assigned to LocalityConfigSpecifier:
	//	*Cluster_CommonLbConfig_ZoneAwareLbConfig_
	//	*Cluster_CommonLbConfig_LocalityWeightedLbConfig_
	LocalityConfigSpecifier isCluster_CommonLbConfig_LocalityConfigSpecifier `protobuf_oneof:"locality_config_specifier"`
	// If set, all health check/weight/metadata updates that happen within this duration will be
	// merged and delivered in one shot when the duration expires. The start of the duration is when
	// the first update happens. This is useful for big clusters, with potentially noisy deploys
	// that might trigger excessive CPU usage due to a constant stream of healthcheck state changes
	// or metadata updates. The first set of updates to be seen apply immediately (e.g.: a new
	// cluster). Please always keep in mind that the use of sandbox technologies may change this
	// behavior.
	//
	// If this is not set, we default to a merge window of 1000ms. To disable it, set the merge
	// window to 0.
	//
	// Note: merging does not apply to cluster membership changes (e.g.: adds/removes); this is
	// because merging those updates isn't currently safe. See
	// https://github.com/envoyproxy/envoy/pull/3941.
	UpdateMergeWindow *types.Duration `protobuf:"bytes,4,opt,name=update_merge_window,json=updateMergeWindow,proto3" json:"update_merge_window,omitempty"`
	// If set to true, Envoy will not consider new hosts when computing load balancing weights until
	// they have been health checked for the first time. This will have no effect unless
	// active health checking is also configured.
	//
	// Ignoring a host means that for any load balancing calculations that adjust weights based
	// on the ratio of eligible hosts and total hosts (priority spillover, locality weighting and
	// panic mode) Envoy will exclude these hosts in the denominator.
	//
	// For example, with hosts in two priorities P0 and P1, where P0 looks like
	// {healthy, unhealthy (new), unhealthy (new)}
	// and where P1 looks like
	// {healthy, healthy}
	// all traffic will still hit P0, as 1 / (3 - 2) = 1.
	//
	// Enabling this will allow scaling up the number of hosts for a given cluster without entering
	// panic mode or triggering priority spillover, assuming the hosts pass the first health check.
	//
	// If panic mode is triggered, new hosts are still eligible for traffic; they simply do not
	// contribute to the calculation when deciding whether panic mode is enabled or not.
	IgnoreNewHostsUntilFirstHc bool `protobuf:"varint,5,opt,name=ignore_new_hosts_until_first_hc,json=ignoreNewHostsUntilFirstHc,proto3" json:"ignore_new_hosts_until_first_hc,omitempty"`
	// If set to `true`, the cluster manager will drain all existing
	// connections to upstream hosts whenever hosts are added or removed from the cluster.
	CloseConnectionsOnHostSetChange bool `protobuf:"varint,6,opt,name=close_connections_on_host_set_change,json=closeConnectionsOnHostSetChange,proto3" json:"close_connections_on_host_set_change,omitempty"`
	//Common Configuration for all consistent hashing load balancers (MaglevLb, RingHashLb, etc.)
	ConsistentHashingLbConfig *Cluster_CommonLbConfig_ConsistentHashingLbConfig `protobuf:"bytes,7,opt,name=consistent_hashing_lb_config,json=consistentHashingLbConfig,proto3" json:"consistent_hashing_lb_config,omitempty"`
	XXX_NoUnkeyedLiteral      struct{}                                          `json:"-"`
	XXX_unrecognized          []byte                                            `json:"-"`
	XXX_sizecache             int32                                             `json:"-"`
}

func (m *Cluster_CommonLbConfig) Reset()         { *m = Cluster_CommonLbConfig{} }
func (m *Cluster_CommonLbConfig) String() string { return proto.CompactTextString(m) }
func (*Cluster_CommonLbConfig) ProtoMessage()    {}
func (*Cluster_CommonLbConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_492f551da3119ad4, []int{0, 7}
}
func (m *Cluster_CommonLbConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Cluster_CommonLbConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Cluster_CommonLbConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Cluster_CommonLbConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Cluster_CommonLbConfig.Merge(m, src)
}
func (m *Cluster_CommonLbConfig) XXX_Size() int {
	return m.Size()
}
func (m *Cluster_CommonLbConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_Cluster_CommonLbConfig.DiscardUnknown(m)
}

var xxx_messageInfo_Cluster_CommonLbConfig proto.InternalMessageInfo

type isCluster_CommonLbConfig_LocalityConfigSpecifier interface {
	isCluster_CommonLbConfig_LocalityConfigSpecifier()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Cluster_CommonLbConfig_ZoneAwareLbConfig_ struct {
	ZoneAwareLbConfig *Cluster_CommonLbConfig_ZoneAwareLbConfig `protobuf:"bytes,2,opt,name=zone_aware_lb_config,json=zoneAwareLbConfig,proto3,oneof" json:"zone_aware_lb_config,omitempty"`
}
type Cluster_CommonLbConfig_LocalityWeightedLbConfig_ struct {
	LocalityWeightedLbConfig *Cluster_CommonLbConfig_LocalityWeightedLbConfig `protobuf:"bytes,3,opt,name=locality_weighted_lb_config,json=localityWeightedLbConfig,proto3,oneof" json:"locality_weighted_lb_config,omitempty"`
}

func (*Cluster_CommonLbConfig_ZoneAwareLbConfig_) isCluster_CommonLbConfig_LocalityConfigSpecifier() {
}
func (*Cluster_CommonLbConfig_LocalityWeightedLbConfig_) isCluster_CommonLbConfig_LocalityConfigSpecifier() {
}

func (m *Cluster_CommonLbConfig) GetLocalityConfigSpecifier() isCluster_CommonLbConfig_LocalityConfigSpecifier {
	if m != nil {
		return m.LocalityConfigSpecifier
	}
	return nil
}

func (m *Cluster_CommonLbConfig) GetHealthyPanicThreshold() *v32.Percent {
	if m != nil {
		return m.HealthyPanicThreshold
	}
	return nil
}

func (m *Cluster_CommonLbConfig) GetZoneAwareLbConfig() *Cluster_CommonLbConfig_ZoneAwareLbConfig {
	if x, ok := m.GetLocalityConfigSpecifier().(*Cluster_CommonLbConfig_ZoneAwareLbConfig_); ok {
		return x.ZoneAwareLbConfig
	}
	return nil
}

func (m *Cluster_CommonLbConfig) GetLocalityWeightedLbConfig() *Cluster_CommonLbConfig_LocalityWeightedLbConfig {
	if x, ok := m.GetLocalityConfigSpecifier().(*Cluster_CommonLbConfig_LocalityWeightedLbConfig_); ok {
		return x.LocalityWeightedLbConfig
	}
	return nil
}

func (m *Cluster_CommonLbConfig) GetUpdateMergeWindow() *types.Duration {
	if m != nil {
		return m.UpdateMergeWindow
	}
	return nil
}

func (m *Cluster_CommonLbConfig) GetIgnoreNewHostsUntilFirstHc() bool {
	if m != nil {
		return m.IgnoreNewHostsUntilFirstHc
	}
	return false
}

func (m *Cluster_CommonLbConfig) GetCloseConnectionsOnHostSetChange() bool {
	if m != nil {
		return m.CloseConnectionsOnHostSetChange
	}
	return false
}

func (m *Cluster_CommonLbConfig) GetConsistentHashingLbConfig() *Cluster_CommonLbConfig_ConsistentHashingLbConfig {
	if m != nil {
		return m.ConsistentHashingLbConfig
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Cluster_CommonLbConfig) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Cluster_CommonLbConfig_ZoneAwareLbConfig_)(nil),
		(*Cluster_CommonLbConfig_LocalityWeightedLbConfig_)(nil),
	}
}

// Configuration for :ref:`zone aware routing
// <arch_overview_load_balancing_zone_aware_routing>`.
type Cluster_CommonLbConfig_ZoneAwareLbConfig struct {
	// Configures percentage of requests that will be considered for zone aware routing
	// if zone aware routing is configured. If not specified, the default is 100%.
	// * :ref:`runtime values <config_cluster_manager_cluster_runtime_zone_routing>`.
	// * :ref:`Zone aware routing support <arch_overview_load_balancing_zone_aware_routing>`.
	RoutingEnabled *v32.Percent `protobuf:"bytes,1,opt,name=routing_enabled,json=routingEnabled,proto3" json:"routing_enabled,omitempty"`
	// Configures minimum upstream cluster size required for zone aware routing
	// If upstream cluster size is less than specified, zone aware routing is not performed
	// even if zone aware routing is configured. If not specified, the default is 6.
	// * :ref:`runtime values <config_cluster_manager_cluster_runtime_zone_routing>`.
	// * :ref:`Zone aware routing support <arch_overview_load_balancing_zone_aware_routing>`.
	MinClusterSize *types.UInt64Value `protobuf:"bytes,2,opt,name=min_cluster_size,json=minClusterSize,proto3" json:"min_cluster_size,omitempty"`
	// If set to true, Envoy will not consider any hosts when the cluster is in :ref:`panic
	// mode<arch_overview_load_balancing_panic_threshold>`. Instead, the cluster will fail all
	// requests as if all hosts are unhealthy. This can help avoid potentially overwhelming a
	// failing service.
	FailTrafficOnPanic   bool     `protobuf:"varint,3,opt,name=fail_traffic_on_panic,json=failTrafficOnPanic,proto3" json:"fail_traffic_on_panic,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Cluster_CommonLbConfig_ZoneAwareLbConfig) Reset() {
	*m = Cluster_CommonLbConfig_ZoneAwareLbConfig{}
}
func (m *Cluster_CommonLbConfig_ZoneAwareLbConfig) String() string { return proto.CompactTextString(m) }
func (*Cluster_CommonLbConfig_ZoneAwareLbConfig) ProtoMessage()    {}
func (*Cluster_CommonLbConfig_ZoneAwareLbConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_492f551da3119ad4, []int{0, 7, 0}
}
func (m *Cluster_CommonLbConfig_ZoneAwareLbConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Cluster_CommonLbConfig_ZoneAwareLbConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Cluster_CommonLbConfig_ZoneAwareLbConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Cluster_CommonLbConfig_ZoneAwareLbConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Cluster_CommonLbConfig_ZoneAwareLbConfig.Merge(m, src)
}
func (m *Cluster_CommonLbConfig_ZoneAwareLbConfig) XXX_Size() int {
	return m.Size()
}
func (m *Cluster_CommonLbConfig_ZoneAwareLbConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_Cluster_CommonLbConfig_ZoneAwareLbConfig.DiscardUnknown(m)
}

var xxx_messageInfo_Cluster_CommonLbConfig_ZoneAwareLbConfig proto.InternalMessageInfo

func (m *Cluster_CommonLbConfig_ZoneAwareLbConfig) GetRoutingEnabled() *v32.Percent {
	if m != nil {
		return m.RoutingEnabled
	}
	return nil
}

func (m *Cluster_CommonLbConfig_ZoneAwareLbConfig) GetMinClusterSize() *types.UInt64Value {
	if m != nil {
		return m.MinClusterSize
	}
	return nil
}

func (m *Cluster_CommonLbConfig_ZoneAwareLbConfig) GetFailTrafficOnPanic() bool {
	if m != nil {
		return m.FailTrafficOnPanic
	}
	return false
}

// Configuration for :ref:`locality weighted load balancing
// <arch_overview_load_balancing_locality_weighted_lb>`
type Cluster_CommonLbConfig_LocalityWeightedLbConfig struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Cluster_CommonLbConfig_LocalityWeightedLbConfig) Reset() {
	*m = Cluster_CommonLbConfig_LocalityWeightedLbConfig{}
}
func (m *Cluster_CommonLbConfig_LocalityWeightedLbConfig) String() string {
	return proto.CompactTextString(m)
}
func (*Cluster_CommonLbConfig_LocalityWeightedLbConfig) ProtoMessage() {}
func (*Cluster_CommonLbConfig_LocalityWeightedLbConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_492f551da3119ad4, []int{0, 7, 1}
}
func (m *Cluster_CommonLbConfig_LocalityWeightedLbConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Cluster_CommonLbConfig_LocalityWeightedLbConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Cluster_CommonLbConfig_LocalityWeightedLbConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Cluster_CommonLbConfig_LocalityWeightedLbConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Cluster_CommonLbConfig_LocalityWeightedLbConfig.Merge(m, src)
}
func (m *Cluster_CommonLbConfig_LocalityWeightedLbConfig) XXX_Size() int {
	return m.Size()
}
func (m *Cluster_CommonLbConfig_LocalityWeightedLbConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_Cluster_CommonLbConfig_LocalityWeightedLbConfig.DiscardUnknown(m)
}

var xxx_messageInfo_Cluster_CommonLbConfig_LocalityWeightedLbConfig proto.InternalMessageInfo

// Common Configuration for all consistent hashing load balancers (MaglevLb, RingHashLb, etc.)
type Cluster_CommonLbConfig_ConsistentHashingLbConfig struct {
	// If set to `true`, the cluster will use hostname instead of the resolved
	// address as the key to consistently hash to an upstream host. Only valid for StrictDNS clusters with hostnames which resolve to a single IP address.
	UseHostnameForHashing bool     `protobuf:"varint,1,opt,name=use_hostname_for_hashing,json=useHostnameForHashing,proto3" json:"use_hostname_for_hashing,omitempty"`
	XXX_NoUnkeyedLiteral  struct{} `json:"-"`
	XXX_unrecognized      []byte   `json:"-"`
	XXX_sizecache         int32    `json:"-"`
}

func (m *Cluster_CommonLbConfig_ConsistentHashingLbConfig) Reset() {
	*m = Cluster_CommonLbConfig_ConsistentHashingLbConfig{}
}
func (m *Cluster_CommonLbConfig_ConsistentHashingLbConfig) String() string {
	return proto.CompactTextString(m)
}
func (*Cluster_CommonLbConfig_ConsistentHashingLbConfig) ProtoMessage() {}
func (*Cluster_CommonLbConfig_ConsistentHashingLbConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_492f551da3119ad4, []int{0, 7, 2}
}
func (m *Cluster_CommonLbConfig_ConsistentHashingLbConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Cluster_CommonLbConfig_ConsistentHashingLbConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Cluster_CommonLbConfig_ConsistentHashingLbConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Cluster_CommonLbConfig_ConsistentHashingLbConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Cluster_CommonLbConfig_ConsistentHashingLbConfig.Merge(m, src)
}
func (m *Cluster_CommonLbConfig_ConsistentHashingLbConfig) XXX_Size() int {
	return m.Size()
}
func (m *Cluster_CommonLbConfig_ConsistentHashingLbConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_Cluster_CommonLbConfig_ConsistentHashingLbConfig.DiscardUnknown(m)
}

var xxx_messageInfo_Cluster_CommonLbConfig_ConsistentHashingLbConfig proto.InternalMessageInfo

func (m *Cluster_CommonLbConfig_ConsistentHashingLbConfig) GetUseHostnameForHashing() bool {
	if m != nil {
		return m.UseHostnameForHashing
	}
	return false
}

type Cluster_RefreshRate struct {
	// Specifies the base interval between refreshes. This parameter is required and must be greater
	// than zero and less than
	// :ref:`max_interval <envoy_api_field_config.cluster.v3.Cluster.RefreshRate.max_interval>`.
	BaseInterval *types.Duration `protobuf:"bytes,1,opt,name=base_interval,json=baseInterval,proto3" json:"base_interval,omitempty"`
	// Specifies the maximum interval between refreshes. This parameter is optional, but must be
	// greater than or equal to the
	// :ref:`base_interval <envoy_api_field_config.cluster.v3.Cluster.RefreshRate.base_interval>`  if set. The default
	// is 10 times the :ref:`base_interval <envoy_api_field_config.cluster.v3.Cluster.RefreshRate.base_interval>`.
	MaxInterval          *types.Duration `protobuf:"bytes,2,opt,name=max_interval,json=maxInterval,proto3" json:"max_interval,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *Cluster_RefreshRate) Reset()         { *m = Cluster_RefreshRate{} }
func (m *Cluster_RefreshRate) String() string { return proto.CompactTextString(m) }
func (*Cluster_RefreshRate) ProtoMessage()    {}
func (*Cluster_RefreshRate) Descriptor() ([]byte, []int) {
	return fileDescriptor_492f551da3119ad4, []int{0, 8}
}
func (m *Cluster_RefreshRate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Cluster_RefreshRate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Cluster_RefreshRate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Cluster_RefreshRate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Cluster_RefreshRate.Merge(m, src)
}
func (m *Cluster_RefreshRate) XXX_Size() int {
	return m.Size()
}
func (m *Cluster_RefreshRate) XXX_DiscardUnknown() {
	xxx_messageInfo_Cluster_RefreshRate.DiscardUnknown(m)
}

var xxx_messageInfo_Cluster_RefreshRate proto.InternalMessageInfo

func (m *Cluster_RefreshRate) GetBaseInterval() *types.Duration {
	if m != nil {
		return m.BaseInterval
	}
	return nil
}

func (m *Cluster_RefreshRate) GetMaxInterval() *types.Duration {
	if m != nil {
		return m.MaxInterval
	}
	return nil
}

// [#not-implemented-hide:] Extensible load balancing policy configuration.
//
// Every LB policy defined via this mechanism will be identified via a unique name using reverse
// DNS notation. If the policy needs configuration parameters, it must define a message for its
// own configuration, which will be stored in the config field. The name of the policy will tell
// clients which type of message they should expect to see in the config field.
//
// Note that there are cases where it is useful to be able to independently select LB policies
// for choosing a locality and for choosing an endpoint within that locality. For example, a
// given deployment may always use the same policy to choose the locality, but for choosing the
// endpoint within the locality, some clusters may use weighted-round-robin, while others may
// use some sort of session-based balancing.
//
// This can be accomplished via hierarchical LB policies, where the parent LB policy creates a
// child LB policy for each locality. For each request, the parent chooses the locality and then
// delegates to the child policy for that locality to choose the endpoint within the locality.
//
// To facilitate this, the config message for the top-level LB policy may include a field of
// type LoadBalancingPolicy that specifies the child policy.
type LoadBalancingPolicy struct {
	// Each client will iterate over the list in order and stop at the first policy that it
	// supports. This provides a mechanism for starting to use new LB policies that are not yet
	// supported by all clients.
	Policies             []*LoadBalancingPolicy_Policy `protobuf:"bytes,1,rep,name=policies,proto3" json:"policies,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_unrecognized     []byte                        `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *LoadBalancingPolicy) Reset()         { *m = LoadBalancingPolicy{} }
func (m *LoadBalancingPolicy) String() string { return proto.CompactTextString(m) }
func (*LoadBalancingPolicy) ProtoMessage()    {}
func (*LoadBalancingPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_492f551da3119ad4, []int{1}
}
func (m *LoadBalancingPolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoadBalancingPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoadBalancingPolicy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoadBalancingPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoadBalancingPolicy.Merge(m, src)
}
func (m *LoadBalancingPolicy) XXX_Size() int {
	return m.Size()
}
func (m *LoadBalancingPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_LoadBalancingPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_LoadBalancingPolicy proto.InternalMessageInfo

func (m *LoadBalancingPolicy) GetPolicies() []*LoadBalancingPolicy_Policy {
	if m != nil {
		return m.Policies
	}
	return nil
}

type LoadBalancingPolicy_Policy struct {
	// Required. The name of the LB policy.
	Name                 string     `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	TypedConfig          *types.Any `protobuf:"bytes,3,opt,name=typed_config,json=typedConfig,proto3" json:"typed_config,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *LoadBalancingPolicy_Policy) Reset()         { *m = LoadBalancingPolicy_Policy{} }
func (m *LoadBalancingPolicy_Policy) String() string { return proto.CompactTextString(m) }
func (*LoadBalancingPolicy_Policy) ProtoMessage()    {}
func (*LoadBalancingPolicy_Policy) Descriptor() ([]byte, []int) {
	return fileDescriptor_492f551da3119ad4, []int{1, 0}
}
func (m *LoadBalancingPolicy_Policy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoadBalancingPolicy_Policy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoadBalancingPolicy_Policy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoadBalancingPolicy_Policy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoadBalancingPolicy_Policy.Merge(m, src)
}
func (m *LoadBalancingPolicy_Policy) XXX_Size() int {
	return m.Size()
}
func (m *LoadBalancingPolicy_Policy) XXX_DiscardUnknown() {
	xxx_messageInfo_LoadBalancingPolicy_Policy.DiscardUnknown(m)
}

var xxx_messageInfo_LoadBalancingPolicy_Policy proto.InternalMessageInfo

func (m *LoadBalancingPolicy_Policy) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *LoadBalancingPolicy_Policy) GetTypedConfig() *types.Any {
	if m != nil {
		return m.TypedConfig
	}
	return nil
}

// An extensible structure containing the address Envoy should bind to when
// establishing upstream connections.
type UpstreamBindConfig struct {
	// The address Envoy should bind to when establishing upstream connections.
	SourceAddress        *v31.Address `protobuf:"bytes,1,opt,name=source_address,json=sourceAddress,proto3" json:"source_address,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *UpstreamBindConfig) Reset()         { *m = UpstreamBindConfig{} }
func (m *UpstreamBindConfig) String() string { return proto.CompactTextString(m) }
func (*UpstreamBindConfig) ProtoMessage()    {}
func (*UpstreamBindConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_492f551da3119ad4, []int{2}
}
func (m *UpstreamBindConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpstreamBindConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpstreamBindConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpstreamBindConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpstreamBindConfig.Merge(m, src)
}
func (m *UpstreamBindConfig) XXX_Size() int {
	return m.Size()
}
func (m *UpstreamBindConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_UpstreamBindConfig.DiscardUnknown(m)
}

var xxx_messageInfo_UpstreamBindConfig proto.InternalMessageInfo

func (m *UpstreamBindConfig) GetSourceAddress() *v31.Address {
	if m != nil {
		return m.SourceAddress
	}
	return nil
}

type UpstreamConnectionOptions struct {
	// If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
	TcpKeepalive         *v31.TcpKeepalive `protobuf:"bytes,1,opt,name=tcp_keepalive,json=tcpKeepalive,proto3" json:"tcp_keepalive,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *UpstreamConnectionOptions) Reset()         { *m = UpstreamConnectionOptions{} }
func (m *UpstreamConnectionOptions) String() string { return proto.CompactTextString(m) }
func (*UpstreamConnectionOptions) ProtoMessage()    {}
func (*UpstreamConnectionOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_492f551da3119ad4, []int{3}
}
func (m *UpstreamConnectionOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpstreamConnectionOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpstreamConnectionOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpstreamConnectionOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpstreamConnectionOptions.Merge(m, src)
}
func (m *UpstreamConnectionOptions) XXX_Size() int {
	return m.Size()
}
func (m *UpstreamConnectionOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_UpstreamConnectionOptions.DiscardUnknown(m)
}

var xxx_messageInfo_UpstreamConnectionOptions proto.InternalMessageInfo

func (m *UpstreamConnectionOptions) GetTcpKeepalive() *v31.TcpKeepalive {
	if m != nil {
		return m.TcpKeepalive
	}
	return nil
}

func init() {
	proto.RegisterEnum("envoy.config.cluster.v3.Cluster_DiscoveryType", Cluster_DiscoveryType_name, Cluster_DiscoveryType_value)
	proto.RegisterEnum("envoy.config.cluster.v3.Cluster_LbPolicy", Cluster_LbPolicy_name, Cluster_LbPolicy_value)
	proto.RegisterEnum("envoy.config.cluster.v3.Cluster_DnsLookupFamily", Cluster_DnsLookupFamily_name, Cluster_DnsLookupFamily_value)
	proto.RegisterEnum("envoy.config.cluster.v3.Cluster_ClusterProtocolSelection", Cluster_ClusterProtocolSelection_name, Cluster_ClusterProtocolSelection_value)
	proto.RegisterEnum("envoy.config.cluster.v3.Cluster_LbSubsetConfig_LbSubsetFallbackPolicy", Cluster_LbSubsetConfig_LbSubsetFallbackPolicy_name, Cluster_LbSubsetConfig_LbSubsetFallbackPolicy_value)
	proto.RegisterEnum("envoy.config.cluster.v3.Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy", Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy_name, Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy_value)
	proto.RegisterEnum("envoy.config.cluster.v3.Cluster_RingHashLbConfig_HashFunction", Cluster_RingHashLbConfig_HashFunction_name, Cluster_RingHashLbConfig_HashFunction_value)
	proto.RegisterType((*Cluster)(nil), "envoy.config.cluster.v3.Cluster")
	proto.RegisterMapType((map[string]*types.Any)(nil), "envoy.config.cluster.v3.Cluster.TypedExtensionProtocolOptionsEntry")
	proto.RegisterType((*Cluster_TransportSocketMatch)(nil), "envoy.config.cluster.v3.Cluster.TransportSocketMatch")
	proto.RegisterType((*Cluster_CustomClusterType)(nil), "envoy.config.cluster.v3.Cluster.CustomClusterType")
	proto.RegisterType((*Cluster_EdsClusterConfig)(nil), "envoy.config.cluster.v3.Cluster.EdsClusterConfig")
	proto.RegisterType((*Cluster_LbSubsetConfig)(nil), "envoy.config.cluster.v3.Cluster.LbSubsetConfig")
	proto.RegisterType((*Cluster_LbSubsetConfig_LbSubsetSelector)(nil), "envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector")
	proto.RegisterType((*Cluster_LeastRequestLbConfig)(nil), "envoy.config.cluster.v3.Cluster.LeastRequestLbConfig")
	proto.RegisterType((*Cluster_RingHashLbConfig)(nil), "envoy.config.cluster.v3.Cluster.RingHashLbConfig")
	proto.RegisterType((*Cluster_OriginalDstLbConfig)(nil), "envoy.config.cluster.v3.Cluster.OriginalDstLbConfig")
	proto.RegisterType((*Cluster_CommonLbConfig)(nil), "envoy.config.cluster.v3.Cluster.CommonLbConfig")
	proto.RegisterType((*Cluster_CommonLbConfig_ZoneAwareLbConfig)(nil), "envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig")
	proto.RegisterType((*Cluster_CommonLbConfig_LocalityWeightedLbConfig)(nil), "envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig")
	proto.RegisterType((*Cluster_CommonLbConfig_ConsistentHashingLbConfig)(nil), "envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig")
	proto.RegisterType((*Cluster_RefreshRate)(nil), "envoy.config.cluster.v3.Cluster.RefreshRate")
	proto.RegisterType((*LoadBalancingPolicy)(nil), "envoy.config.cluster.v3.LoadBalancingPolicy")
	proto.RegisterType((*LoadBalancingPolicy_Policy)(nil), "envoy.config.cluster.v3.LoadBalancingPolicy.Policy")
	proto.RegisterType((*UpstreamBindConfig)(nil), "envoy.config.cluster.v3.UpstreamBindConfig")
	proto.RegisterType((*UpstreamConnectionOptions)(nil), "envoy.config.cluster.v3.UpstreamConnectionOptions")
}

func init() {
	proto.RegisterFile("envoy/config/cluster/v3/cluster.proto", fileDescriptor_492f551da3119ad4)
}

var fileDescriptor_492f551da3119ad4 = []byte{
	// 3332 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x7a, 0x4b, 0x73, 0x1b, 0x49,
	0x72, 0x3f, 0x1b, 0x84, 0x44, 0x30, 0x49, 0x82, 0xcd, 0x22, 0x25, 0x35, 0x41, 0x89, 0xa2, 0x30,
	0xd2, 0x88, 0xe2, 0xce, 0x80, 0x33, 0x94, 0x66, 0xe6, 0xbf, 0xfc, 0xef, 0xce, 0x2e, 0x5e, 0x14,
	0x29, 0x81, 0x00, 0xb7, 0x01, 0x4a, 0x23, 0x3b, 0xc2, 0xb5, 0x8d, 0x46, 0x81, 0x68, 0xb3, 0xd1,
	0x0d, 0x77, 0x15, 0x28, 0x61, 0x4e, 0x13, 0x1b, 0x3e, 0xf8, 0x79, 0xf0, 0xee, 0xc5, 0xb1, 0x67,
	0x8f, 0x0f, 0xf3, 0x11, 0x7c, 0xf2, 0xc5, 0x11, 0x7b, 0xb4, 0xfd, 0x09, 0x1c, 0x73, 0xf0, 0x87,
	0xd0, 0xc1, 0xe1, 0xa8, 0x47, 0x83, 0x78, 0x34, 0x08, 0xca, 0x7b, 0x22, 0xaa, 0x32, 0xf3, 0x97,
	0x59, 0x55, 0x59, 0xf9, 0xa8, 0x26, 0x3c, 0x22, 0xde, 0x85, 0xdf, 0xdb, 0xb5, 0x7d, 0xaf, 0xe9,
	0x9c, 0xed, 0xda, 0x6e, 0x97, 0x32, 0x12, 0xec, 0x5e, 0x3c, 0x0d, 0x7f, 0x66, 0x3a, 0x81, 0xcf,
	0x7c, 0x74, 0x47, 0xb0, 0x65, 0x24, 0x5b, 0x26, 0xa4, 0x5d, 0x3c, 0x4d, 0x7d, 0x3a, 0x51, 0xde,
	0x09, 0xec, 0xae, 0xc3, 0x70, 0x3d, 0x20, 0xd6, 0x79, 0x88, 0x93, 0x7a, 0x38, 0x89, 0xbd, 0xe9,
	0xb8, 0x7d, 0x6d, 0xa9, 0xdd, 0x49, 0x5c, 0x7e, 0x97, 0xb9, 0x0e, 0x09, 0x70, 0x83, 0x30, 0x62,
	0x33, 0xc7, 0xf7, 0x94, 0x40, 0x7a, 0x58, 0xc0, 0x0f, 0x08, 0xe7, 0xb6, 0x1a, 0x8d, 0x80, 0x50,
	0xaa, 0x78, 0xee, 0x47, 0xf2, 0xd4, 0x2d, 0x4a, 0x14, 0xc3, 0x76, 0x24, 0x83, 0x1c, 0x62, 0xea,
	0x77, 0x03, 0x3b, 0xe4, 0x7c, 0x1c, 0xc9, 0xd9, 0x22, 0x96, 0xcb, 0x5a, 0xd8, 0x6e, 0x11, 0xfb,
	0x5c, 0x31, 0x7e, 0x14, 0xc9, 0x28, 0x68, 0xb6, 0xef, 0x46, 0xa2, 0x11, 0xaf, 0xd1, 0xf1, 0x1d,
	0x8f, 0x71, 0xc6, 0xf0, 0xb7, 0x62, 0xdc, 0x90, 0x8c, 0xac, 0xd7, 0x91, 0x30, 0x24, 0xb0, 0x49,
	0x9f, 0xb8, 0x7e, 0xe6, 0xfb, 0x67, 0x2e, 0x91, 0xe0, 0xf5, 0x6e, 0x73, 0xd7, 0xf2, 0x7a, 0x8a,
	0xb4, 0x39, 0x4a, 0x6a, 0x74, 0x03, 0x6b, 0x60, 0xf7, 0xee, 0x8e, 0xd2, 0x29, 0x0b, 0xba, 0x36,
	0x9b, 0x24, 0xfd, 0x36, 0xb0, 0x3a, 0x1d, 0x12, 0xd0, 0xe1, 0x35, 0x5a, 0x9e, 0xe7, 0x33, 0x81,
	0x4a, 0x77, 0x1b, 0xa4, 0x13, 0x10, 0x7b, 0x50, 0xc5, 0xbd, 0x6e, 0xa3, 0x63, 0x0d, 0xf1, 0x50,
	0x66, 0xb1, 0x6e, 0x88, 0xf1, 0x60, 0x8c, 0x7c, 0x41, 0x02, 0xea, 0xf8, 0x9e, 0xe3, 0x9d, 0x29,
	0x96, 0x3b, 0x17, 0x96, 0xeb, 0x34, 0x2c, 0x46, 0x76, 0xc3, 0x1f, 0x92, 0x90, 0xfe, 0x9f, 0xaf,
	0x61, 0x2e, 0x2f, 0x5d, 0x04, 0xf9, 0x60, 0xb0, 0xc0, 0xf2, 0x68, 0xc7, 0x0f, 0x18, 0xa6, 0xbe,
	0x7d, 0x4e, 0x18, 0x6e, 0x5b, 0xcc, 0x6e, 0x11, 0x6a, 0xfc, 0x64, 0x6b, 0x76, 0x7b, 0x61, 0xef,
	0x8b, 0xcc, 0x04, 0x4f, 0xce, 0x28, 0x8c, 0x4c, 0x2d, 0x04, 0xa8, 0x0a, 0xf9, 0x63, 0x2e, 0x6e,
	0xde, 0x66, 0x11, 0xb3, 0x84, 0xa2, 0x0d, 0x88, 0x7b, 0x56, 0x9b, 0x18, 0xda, 0x96, 0xb6, 0x3d,
	0x9f, 0x9b, 0x7b, 0x9f, 0x8b, 0x07, 0xb1, 0x2d, 0xcd, 0x14, 0x93, 0x28, 0x0d, 0x4b, 0x96, 0xcb,
	0x30, 0x5f, 0x29, 0x16, 0x5c, 0x77, 0x39, 0x97, 0xb9, 0x60, 0xb9, 0xac, 0xca, 0x2c, 0x56, 0xe6,
	0x3c, 0x65, 0x88, 0xf3, 0xf3, 0x34, 0x62, 0x5b, 0xda, 0x76, 0x72, 0x2f, 0x33, 0xd5, 0xba, 0x82,
	0x43, 0x6d, 0xff, 0x82, 0x04, 0xbd, 0x5a, 0xaf, 0x43, 0x72, 0x89, 0xf7, 0xb9, 0x1b, 0xbf, 0xd1,
	0x62, 0xba, 0x76, 0x38, 0x63, 0x0a, 0x1c, 0xf4, 0x1a, 0x16, 0x95, 0x14, 0x16, 0xb8, 0x1f, 0x6f,
	0x69, 0xdb, 0x0b, 0x7b, 0x7b, 0x53, 0x71, 0xf3, 0x5d, 0xca, 0xfc, 0xb6, 0x1a, 0x71, 0xec, 0xc3,
	0x19, 0x73, 0xc1, 0xbe, 0x1c, 0x22, 0x0c, 0x88, 0x34, 0x28, 0x0e, 0xc1, 0x25, 0x92, 0x31, 0x2b,
	0xe0, 0x3f, 0x9f, 0x0a, 0x5f, 0x6c, 0x50, 0xf5, 0x33, 0x2f, 0x78, 0x4c, 0x9d, 0x8c, 0xcc, 0xa0,
	0x12, 0x2c, 0xdb, 0xbe, 0xe7, 0x11, 0x9b, 0x61, 0xe6, 0xb4, 0x89, 0xdf, 0x65, 0x46, 0x5c, 0xa0,
	0xaf, 0x67, 0xa4, 0x07, 0x66, 0x42, 0x0f, 0xcc, 0x14, 0x94, 0xff, 0x8a, 0xf5, 0xff, 0xa0, 0xc5,
	0x76, 0x66, 0xcc, 0xa4, 0x92, 0xad, 0x49, 0x51, 0xd4, 0x84, 0x07, 0x1d, 0x69, 0xa6, 0x27, 0x23,
	0x05, 0xae, 0x77, 0x9b, 0x4d, 0x12, 0x60, 0xd7, 0x69, 0xf3, 0xa8, 0xd4, 0x63, 0x84, 0x1a, 0x37,
	0x04, 0xfe, 0xdd, 0x31, 0xfc, 0xd3, 0x23, 0x8f, 0x3d, 0xdd, 0x7b, 0x65, 0xb9, 0x5d, 0x62, 0xde,
	0xeb, 0x08, 0x0b, 0x15, 0x4a, 0x4e, 0x80, 0x94, 0x38, 0x46, 0x8e, 0x43, 0xa0, 0x13, 0x98, 0x77,
	0xeb, 0xb8, 0xe3, 0xbb, 0x8e, 0xdd, 0x33, 0x6e, 0x8a, 0x43, 0x7c, 0x32, 0x75, 0x37, 0x4a, 0xf5,
	0x13, 0x21, 0x70, 0x79, 0x7e, 0x66, 0xc2, 0x55, 0x73, 0xe8, 0x1b, 0x58, 0x76, 0x7d, 0xab, 0x81,
	0x2d, 0x4a, 0x9d, 0x33, 0xaf, 0x4d, 0x3c, 0x66, 0x3c, 0x10, 0x76, 0xee, 0x0e, 0xe3, 0xf6, 0x83,
	0xc3, 0x25, 0x70, 0xc9, 0xb7, 0x1a, 0xd9, 0xbe, 0x98, 0x99, 0x74, 0x87, 0xc6, 0xe8, 0x00, 0x96,
	0x06, 0x63, 0x14, 0x35, 0x12, 0xe2, 0x4a, 0x3c, 0x18, 0xb1, 0xd7, 0x0f, 0x08, 0xc7, 0x3c, 0x14,
	0xac, 0x79, 0xce, 0x69, 0x2e, 0xb6, 0x2e, 0x07, 0x14, 0xfd, 0x29, 0x6c, 0xb4, 0xad, 0x77, 0x38,
	0x20, 0x7f, 0xd1, 0x25, 0x94, 0x51, 0x3c, 0xbc, 0xd1, 0xc6, 0xfc, 0x35, 0x76, 0xd5, 0x68, 0x5b,
	0xef, 0x4c, 0x25, 0x7f, 0x32, 0xb8, 0xc1, 0xa8, 0x0a, 0xfa, 0x48, 0xea, 0xa0, 0x06, 0x08, 0xc4,
	0xed, 0xc9, 0xfb, 0x2a, 0x05, 0x72, 0x8a, 0xdf, 0x5c, 0xb6, 0x87, 0x27, 0xd0, 0x05, 0x6c, 0x76,
	0x3b, 0x94, 0x05, 0xc4, 0x6a, 0xe3, 0x16, 0x63, 0x1d, 0x1c, 0x86, 0x60, 0xec, 0x77, 0x44, 0xbc,
	0x31, 0x32, 0x91, 0x8e, 0xac, 0xb6, 0xe2, 0x54, 0xc9, 0x1e, 0x32, 0xd6, 0x39, 0x51, 0x92, 0x15,
	0x29, 0x68, 0x6e, 0x74, 0x27, 0x13, 0xd1, 0x9f, 0xc3, 0x5d, 0xdb, 0x6f, 0xb7, 0x7d, 0x6f, 0x82,
	0xd6, 0x7b, 0x42, 0xeb, 0x93, 0x09, 0x07, 0x10, 0xa1, 0x6d, 0x5d, 0xc2, 0x45, 0xe9, 0xfa, 0x33,
	0xb8, 0x15, 0xad, 0x64, 0x49, 0x28, 0xd9, 0x99, 0xac, 0xe4, 0xf3, 0x51, 0x2d, 0xab, 0xad, 0x08,
	0xfc, 0x5f, 0xc3, 0x6d, 0x3e, 0xbd, 0x37, 0xae, 0x20, 0x39, 0x4d, 0xc1, 0xde, 0xa8, 0x82, 0xb5,
	0x56, 0xc4, 0x2c, 0xfa, 0x3b, 0x0d, 0xb6, 0x78, 0xd0, 0x6a, 0x60, 0xf2, 0x8e, 0x11, 0x8f, 0xc7,
	0xff, 0x71, 0x65, 0x0f, 0x85, 0xcf, 0xe6, 0xa7, 0x87, 0x71, 0x0e, 0x54, 0x0c, 0x71, 0x46, 0x54,
	0x15, 0x3d, 0x16, 0xf4, 0xcc, 0x7b, 0xec, 0x2a, 0x1e, 0xf4, 0x2b, 0xd0, 0x1b, 0x1e, 0xc5, 0x01,
	0x69, 0x06, 0x84, 0xb6, 0x70, 0x60, 0x31, 0x62, 0xe8, 0xd3, 0x22, 0xd2, 0xe2, 0xfb, 0xdc, 0xfc,
	0x0f, 0xda, 0xcd, 0x9d, 0xb8, 0xfe, 0xaf, 0x7f, 0xf9, 0x73, 0x33, 0xd9, 0xf0, 0xa8, 0x29, 0xe5,
	0x4d, 0x8b, 0x11, 0x44, 0xc0, 0xe0, 0x90, 0x4d, 0xcb, 0x71, 0xbb, 0x01, 0x19, 0x86, 0xfe, 0x44,
	0x40, 0x7f, 0x32, 0x75, 0x61, 0x03, 0x78, 0xe6, 0xad, 0x86, 0x47, 0x0f, 0x24, 0xd8, 0xa0, 0x9a,
	0x8f, 0x61, 0x39, 0x20, 0xb4, 0xc3, 0x43, 0x29, 0x57, 0xc7, 0x98, 0x6b, 0x3c, 0xde, 0xd2, 0xb6,
	0x13, 0xe6, 0x92, 0x9a, 0x2e, 0x78, 0xb4, 0xc6, 0x5c, 0xd4, 0x84, 0x15, 0x4e, 0x77, 0x7d, 0xff,
	0xbc, 0xdb, 0xc1, 0x4d, 0xab, 0xed, 0xb8, 0x3d, 0x63, 0x45, 0x04, 0xb1, 0xcf, 0xa6, 0x67, 0x22,
	0x8f, 0x96, 0x84, 0xe0, 0x81, 0x90, 0x1b, 0x88, 0x65, 0xcb, 0x8d, 0x61, 0x12, 0xca, 0xc1, 0x92,
	0xdc, 0x49, 0xea, 0xbb, 0x3c, 0xb1, 0x1b, 0x48, 0x1c, 0xe2, 0xbd, 0x68, 0x8f, 0xc9, 0xca, 0xb2,
	0xcd, 0x5c, 0x14, 0x9b, 0xa7, 0x44, 0xd0, 0x33, 0xb8, 0xd3, 0xa5, 0x04, 0x33, 0xbb, 0x83, 0x9b,
	0x7e, 0x80, 0x2f, 0xed, 0xa6, 0xc6, 0xa7, 0x62, 0x6d, 0xab, 0x5d, 0x4a, 0x6a, 0x76, 0xe7, 0xc0,
	0x0f, 0xfa, 0x96, 0x51, 0xf4, 0x0a, 0x56, 0xc6, 0x6a, 0x46, 0x63, 0x35, 0xf2, 0xd6, 0x5d, 0xae,
	0xb0, 0x22, 0x25, 0x0a, 0xa1, 0x80, 0xa9, 0xfb, 0x23, 0x33, 0xa8, 0x0c, 0xba, 0xed, 0x12, 0xcb,
	0xeb, 0x76, 0xb0, 0xe3, 0x31, 0x12, 0x5c, 0x58, 0xae, 0xb1, 0x76, 0xfd, 0x6c, 0xb5, 0xac, 0x84,
	0x8f, 0x94, 0x2c, 0x32, 0x61, 0xad, 0x1f, 0xa0, 0xea, 0x8e, 0xd7, 0x08, 0xf3, 0xeb, 0x2d, 0x81,
	0xb9, 0x15, 0xbd, 0x51, 0x39, 0xc7, 0x6b, 0xa8, 0x74, 0x8a, 0x42, 0xe9, 0xcb, 0x39, 0xf4, 0x06,
	0x74, 0xb7, 0x8e, 0x69, 0xb7, 0x4e, 0x09, 0x0b, 0xf1, 0x6e, 0x47, 0x65, 0x92, 0xc8, 0x0c, 0x55,
	0x15, 0x72, 0x0a, 0x3e, 0xe9, 0x0e, 0x8d, 0x51, 0x1d, 0x56, 0x03, 0xc7, 0x3b, 0xc3, 0x2d, 0x8b,
	0xb6, 0xb0, 0x5b, 0x0f, 0xd1, 0xef, 0x5c, 0xb3, 0x1a, 0x30, 0x1d, 0xef, 0xec, 0xd0, 0xa2, 0xad,
	0x52, 0x5d, 0xe2, 0x1d, 0x6a, 0xa6, 0x1e, 0x8c, 0xcc, 0xa1, 0x73, 0xb8, 0xed, 0x07, 0xce, 0x99,
	0xe3, 0x59, 0x2e, 0x6e, 0x50, 0x36, 0xa0, 0x26, 0x2d, 0xd4, 0x3c, 0x9b, 0xaa, 0xa6, 0xa2, 0xc4,
	0x0b, 0x94, 0x0d, 0x68, 0x5a, 0xf5, 0xc7, 0xa7, 0x91, 0x07, 0x77, 0x5c, 0x62, 0x51, 0x16, 0x26,
	0xb5, 0x01, 0x6d, 0x8f, 0x84, 0xb6, 0xe9, 0x75, 0x63, 0x89, 0xcb, 0xab, 0x9c, 0x36, 0xa0, 0x6e,
	0xcd, 0x8d, 0x98, 0xe7, 0x67, 0xa3, 0x12, 0xc3, 0xa5, 0xa2, 0x8d, 0x6b, 0x9e, 0x4d, 0x5e, 0x08,
	0x86, 0x50, 0xbc, 0xf2, 0x19, 0x1c, 0xa3, 0x13, 0xd0, 0x47, 0x6b, 0x60, 0xc3, 0x10, 0xd0, 0x8f,
	0xa2, 0xdd, 0x68, 0xa4, 0xe0, 0x35, 0x97, 0x47, 0x6a, 0x5d, 0xb4, 0x0f, 0x89, 0x36, 0x61, 0x56,
	0xc3, 0x62, 0x96, 0xb1, 0x2e, 0x90, 0x36, 0xa3, 0x91, 0x8e, 0x15, 0x97, 0xd9, 0xe7, 0x47, 0x2d,
	0x40, 0xfd, 0x10, 0x4e, 0x89, 0xab, 0x6e, 0x60, 0x4a, 0xc4, 0x98, 0x9f, 0x4e, 0x5f, 0xaa, 0xfc,
	0x1b, 0x46, 0xe6, 0x6a, 0x08, 0x60, 0xae, 0x74, 0x46, 0xa7, 0x50, 0x00, 0xfd, 0x54, 0x3c, 0x58,
	0xf6, 0x85, 0x79, 0x63, 0x73, 0x4a, 0x21, 0x1c, 0xe6, 0xf8, 0xcb, 0x52, 0xa4, 0x9f, 0x73, 0xbb,
	0x93, 0x48, 0xe8, 0x14, 0xb6, 0x6d, 0xd7, 0xa7, 0x64, 0x40, 0x21, 0xc5, 0x3c, 0xdb, 0xfb, 0x94,
	0x61, 0x55, 0x6b, 0xa9, 0x60, 0x6f, 0xdc, 0x17, 0x51, 0xea, 0x23, 0xc1, 0x7f, 0x89, 0x44, 0x2b,
	0xde, 0xa1, 0x4f, 0x99, 0x2c, 0xb6, 0x54, 0x28, 0x47, 0xbf, 0x84, 0x7b, 0xce, 0x99, 0xe7, 0x07,
	0x24, 0xc4, 0x08, 0x21, 0x03, 0xd2, 0xf6, 0x79, 0xa8, 0xd9, 0x12, 0x58, 0xeb, 0x92, 0x49, 0xca,
	0x4a, 0x1c, 0x53, 0x32, 0xa0, 0x9f, 0xc2, 0x9c, 0xec, 0xa8, 0xa9, 0xb1, 0x2d, 0x62, 0xed, 0xfd,
	0x89, 0x0b, 0x3f, 0x10, 0x7c, 0x66, 0xc8, 0x8f, 0x7e, 0x0d, 0xb7, 0x44, 0xfd, 0x59, 0xb7, 0x5c,
	0xcb, 0xb3, 0xf9, 0x2d, 0x57, 0xd5, 0xed, 0x93, 0x29, 0x09, 0x8a, 0x57, 0x9f, 0xb9, 0x50, 0x48,
	0x16, 0xb3, 0xe6, 0xaa, 0x3b, 0x3e, 0x89, 0xb2, 0x00, 0x6e, 0x40, 0x31, 0x25, 0xc1, 0x05, 0x09,
	0x8c, 0x1d, 0x01, 0x9b, 0x8e, 0xf6, 0x28, 0xe9, 0xd3, 0x55, 0xd1, 0x7c, 0x9b, 0xf3, 0x6e, 0x40,
	0xab, 0x42, 0x08, 0xed, 0xc1, 0x2d, 0x16, 0x58, 0xf6, 0x79, 0xd8, 0x2a, 0xe0, 0x7a, 0xb7, 0x71,
	0x46, 0x18, 0x35, 0x76, 0x65, 0x2e, 0x10, 0x44, 0xd5, 0x0b, 0xe4, 0x24, 0x29, 0xf5, 0xdf, 0x1a,
	0xac, 0x45, 0x35, 0x77, 0x91, 0x4d, 0x9c, 0x1e, 0x36, 0x71, 0x9f, 0xc2, 0x0d, 0xd1, 0x41, 0x8a,
	0x0e, 0x6d, 0x61, 0xef, 0xce, 0x58, 0x78, 0xaf, 0x8a, 0x66, 0xd9, 0x94, 0x5c, 0x91, 0xb7, 0x6f,
	0xf6, 0x8f, 0xb9, 0x7d, 0xfb, 0x9f, 0xfd, 0xfe, 0xdf, 0xfe, 0x6a, 0xf3, 0x27, 0xf0, 0x44, 0x4a,
	0x5b, 0x1d, 0x27, 0x73, 0xb1, 0x77, 0x65, 0xb3, 0x9a, 0xfa, 0x47, 0x0d, 0x56, 0xc6, 0xfa, 0xb9,
	0xab, 0x5b, 0xd5, 0xaf, 0x60, 0x51, 0x56, 0x5e, 0x2a, 0x16, 0xc9, 0xc5, 0xae, 0x8d, 0x2d, 0x36,
	0xeb, 0xf5, 0xcc, 0x05, 0xc1, 0x29, 0x4f, 0x66, 0xff, 0x53, 0x6e, 0xdd, 0x36, 0x7c, 0x1c, 0x69,
	0xdd, 0x98, 0x11, 0xa9, 0x7f, 0xd6, 0x40, 0x1f, 0xed, 0x05, 0xb9, 0x3f, 0x88, 0xd6, 0x52, 0xaa,
	0xd6, 0xae, 0xef, 0x0f, 0xbc, 0x87, 0x94, 0x10, 0x0f, 0x60, 0x91, 0xbb, 0x93, 0x63, 0x13, 0xd9,
	0x69, 0xc7, 0x64, 0xa7, 0xad, 0xe6, 0x78, 0xa7, 0xbd, 0xff, 0x09, 0xb7, 0xf4, 0xb1, 0x7a, 0xf0,
	0x1a, 0xb5, 0x74, 0xd4, 0xa6, 0xd4, 0xdf, 0x26, 0x20, 0x39, 0x9c, 0x04, 0x51, 0x0f, 0x96, 0x9b,
	0x96, 0xeb, 0xd6, 0xb9, 0xdb, 0xa9, 0x2b, 0xa1, 0x89, 0x38, 0x76, 0xf0, 0x81, 0xe9, 0xb4, 0x3f,
	0x3c, 0x50, 0x70, 0x63, 0xdd, 0x60, 0xb2, 0x39, 0x44, 0x41, 0x5f, 0x43, 0xb2, 0x41, 0x9a, 0x56,
	0xd7, 0x65, 0x2a, 0x9f, 0x4f, 0xf3, 0xc6, 0x25, 0xc5, 0x2e, 0xf5, 0xa0, 0x73, 0xd0, 0x55, 0x1d,
	0x20, 0x63, 0xb0, 0x1f, 0x50, 0x63, 0x56, 0xc4, 0x85, 0x5f, 0xfe, 0x5f, 0x6d, 0xaf, 0x2a, 0x20,
	0x73, 0x99, 0x0e, 0x8d, 0x29, 0xbf, 0x9b, 0xae, 0x6f, 0x5b, 0xae, 0xc3, 0x7a, 0xf8, 0x2d, 0x71,
	0xce, 0x5a, 0x0c, 0x5b, 0x6f, 0xad, 0x80, 0x88, 0x76, 0x3e, 0xc1, 0x43, 0x82, 0x24, 0xbe, 0x16,
	0xb4, 0x2c, 0x27, 0x71, 0x19, 0x6a, 0x5b, 0x2e, 0xc1, 0x23, 0x92, 0xa2, 0x45, 0x4f, 0x98, 0xab,
	0x82, 0x58, 0x1a, 0x12, 0x44, 0x0f, 0x21, 0xd9, 0xb1, 0x3c, 0xc7, 0xc6, 0x6d, 0xbf, 0x41, 0xb0,
	0xe5, 0xc9, 0xfe, 0x3b, 0x61, 0x2e, 0x8a, 0xd9, 0x63, 0xbf, 0x41, 0xb2, 0x5e, 0x0f, 0x6d, 0xc2,
	0x82, 0xeb, 0x50, 0x86, 0x2d, 0x2a, 0x58, 0xe6, 0x04, 0xcb, 0x3c, 0x9f, 0xca, 0xd2, 0xac, 0xd7,
	0x4b, 0x7d, 0x3f, 0x0b, 0xfa, 0xe8, 0x9a, 0x10, 0x82, 0xf8, 0x39, 0xe9, 0x51, 0x43, 0xdb, 0x9a,
	0xdd, 0x9e, 0x37, 0xc5, 0x6f, 0xf4, 0x5b, 0x6d, 0xfc, 0xfc, 0xe5, 0xab, 0x0d, 0xfe, 0x63, 0xf7,
	0x70, 0x6c, 0xe2, 0xda, 0x8e, 0xf1, 0x19, 0xac, 0xf5, 0x6d, 0xe2, 0x56, 0x86, 0xee, 0x31, 0x2b,
	0x0c, 0x47, 0x21, 0xed, 0x25, 0xe9, 0x51, 0xa9, 0x21, 0xdd, 0x83, 0xcd, 0xab, 0xb5, 0xa1, 0x65,
	0x58, 0x28, 0x57, 0x6a, 0xb8, 0x50, 0x3c, 0x38, 0x2a, 0x17, 0x0b, 0xfa, 0x8c, 0x9c, 0xc0, 0x07,
	0xd9, 0x52, 0x29, 0x97, 0xcd, 0xbf, 0xd4, 0x35, 0xa4, 0xc3, 0x62, 0xb6, 0xfc, 0x06, 0x17, 0xcb,
	0x85, 0x93, 0xca, 0x51, 0xb9, 0xa6, 0xc7, 0x10, 0x82, 0x64, 0xa1, 0x78, 0x90, 0x3d, 0x2d, 0xd5,
	0x70, 0xf5, 0x34, 0x57, 0x2d, 0xd6, 0xf4, 0x59, 0x2e, 0xf6, 0xb2, 0xf8, 0xa6, 0x1a, 0x4e, 0xc4,
	0xf7, 0xff, 0x3f, 0xbf, 0x81, 0x5f, 0xc2, 0xb3, 0xc8, 0x1b, 0x38, 0x65, 0x8b, 0xd2, 0x15, 0xb8,
	0x1d, 0x7d, 0x6d, 0x46, 0xcd, 0x9b, 0x19, 0x33, 0x4f, 0x8b, 0x30, 0x2f, 0xb6, 0xbf, 0xc3, 0xad,
	0x79, 0x04, 0x1f, 0x5d, 0xc3, 0x9a, 0xd4, 0x6f, 0x35, 0x58, 0x8b, 0xaa, 0xef, 0xd0, 0x21, 0x2c,
	0xda, 0x2d, 0x9f, 0x87, 0x1d, 0xdb, 0xef, 0x7a, 0x4c, 0x05, 0xaf, 0x2b, 0xdf, 0x3e, 0x44, 0xe8,
	0xdd, 0x89, 0x6d, 0xc7, 0xcc, 0x05, 0x29, 0x9a, 0xe7, 0x92, 0x57, 0x87, 0xf9, 0x28, 0xdd, 0xa9,
	0x7f, 0x98, 0x05, 0x7d, 0xb4, 0x92, 0x46, 0x35, 0x58, 0x69, 0x3b, 0x9e, 0xd3, 0xee, 0xb6, 0xb1,
	0xa8, 0xd0, 0xa9, 0xf3, 0x2d, 0xb9, 0xd2, 0xaa, 0x2f, 0x9f, 0x49, 0xab, 0xe0, 0x7d, 0x6e, 0x6e,
	0xef, 0x86, 0xf1, 0xdd, 0x77, 0xdf, 0xc5, 0xcd, 0x65, 0x05, 0xc1, 0xd1, 0xab, 0xce, 0xb7, 0x04,
	0xb5, 0x61, 0x49, 0x94, 0xfa, 0xcd, 0xae, 0x27, 0x0b, 0xb8, 0x59, 0xe1, 0xf8, 0x5f, 0x7f, 0x70,
	0xa5, 0x9f, 0xe1, 0x83, 0x03, 0x85, 0x32, 0xe0, 0xd7, 0x8b, 0xad, 0x81, 0x79, 0xb1, 0x08, 0xeb,
	0xdd, 0xc8, 0x22, 0xe2, 0x1f, 0xbc, 0x08, 0x09, 0x11, 0x2e, 0x22, 0x9d, 0x81, 0xc5, 0x41, 0xed,
	0x68, 0x01, 0xe6, 0xbe, 0xf9, 0x06, 0x1f, 0x66, 0xab, 0x87, 0xfa, 0x0c, 0x5a, 0x81, 0xa5, 0xe3,
	0x53, 0xf3, 0xf8, 0xd4, 0x14, 0x13, 0x78, 0x4f, 0xd7, 0xae, 0x4e, 0x18, 0xa3, 0x0b, 0x7b, 0x11,
	0x4f, 0xc4, 0xf4, 0xd9, 0x94, 0x07, 0xab, 0x11, 0x5d, 0x07, 0x6f, 0xc8, 0x79, 0xf3, 0x2a, 0xde,
	0x67, 0x5a, 0xc4, 0x6a, 0x90, 0x40, 0x9c, 0x49, 0xc2, 0x5c, 0xea, 0x52, 0x72, 0xc8, 0x58, 0xe7,
	0x50, 0x4c, 0xee, 0xef, 0x72, 0x95, 0x3b, 0xb0, 0x1d, 0xa9, 0x32, 0x02, 0x38, 0xf5, 0x3d, 0x40,
	0x72, 0xb8, 0x1f, 0x40, 0x65, 0xb8, 0x23, 0xab, 0xc6, 0x1e, 0x96, 0xe1, 0x91, 0xb5, 0x02, 0x42,
	0x5b, 0xbe, 0xdb, 0x50, 0x7e, 0x70, 0x5b, 0x9d, 0x1a, 0x4f, 0xe3, 0xfc, 0xac, 0x4e, 0xe4, 0x77,
	0x04, 0xf3, 0x96, 0x12, 0x3b, 0xe1, 0x52, 0xb5, 0x50, 0x08, 0x31, 0x58, 0xfb, 0xd6, 0xf7, 0x88,
	0x8c, 0xe1, 0x03, 0xed, 0x8a, 0xcc, 0x40, 0xd9, 0x0f, 0x6c, 0x57, 0x32, 0x7f, 0xe2, 0x7b, 0x44,
	0xc4, 0xfc, 0x7e, 0x8f, 0x34, 0x63, 0xae, 0x7c, 0x3b, 0x3a, 0x89, 0xfe, 0x5a, 0x83, 0x8d, 0x91,
	0x5c, 0x40, 0x1a, 0x03, 0xda, 0x65, 0x4d, 0x75, 0xf8, 0xa1, 0xda, 0x87, 0x53, 0x08, 0x69, 0x0c,
	0x18, 0x61, 0xb8, 0x13, 0x68, 0xe8, 0x08, 0x56, 0xbb, 0x9d, 0x86, 0xc5, 0x08, 0x6e, 0x93, 0xe0,
	0x8c, 0xe0, 0xb7, 0x8e, 0xd7, 0xf0, 0xdf, 0x4e, 0x7d, 0x9d, 0x36, 0x57, 0xa4, 0xd4, 0x31, 0x17,
	0x7a, 0x2d, 0x64, 0x50, 0x1e, 0xee, 0xab, 0xca, 0xde, 0x23, 0x6f, 0x45, 0x4d, 0x4f, 0x71, 0xd7,
	0x63, 0x8e, 0x8b, 0x9b, 0x4e, 0xc0, 0x7b, 0x06, 0x5b, 0x65, 0xbc, 0x94, 0x64, 0x2b, 0x93, 0xb7,
	0xbc, 0xac, 0xa7, 0xa7, 0x9c, 0xe7, 0x80, 0xb3, 0x1c, 0xda, 0xe8, 0x18, 0x1e, 0x4e, 0xee, 0x3a,
	0x44, 0xb3, 0xdf, 0xb2, 0xbc, 0x33, 0xa2, 0xd2, 0xe1, 0xfd, 0xe8, 0x8e, 0xa3, 0x4a, 0x58, 0x5e,
	0xb0, 0xa1, 0xbf, 0xd1, 0xe0, 0xae, 0xed, 0x7b, 0xd4, 0xa1, 0x8c, 0x78, 0x4c, 0xf4, 0xf4, 0xfc,
	0xd2, 0x5d, 0xee, 0xf5, 0x9c, 0x58, 0xe8, 0xd1, 0x87, 0xee, 0x75, 0xbe, 0x8f, 0x79, 0x28, 0x21,
	0xfb, 0x2d, 0xeb, 0xba, 0x3d, 0x89, 0x94, 0xfa, 0xfb, 0x18, 0xac, 0x8c, 0xb9, 0x08, 0xfa, 0x05,
	0x2c, 0x07, 0x7e, 0x97, 0x71, 0xb3, 0x88, 0x67, 0xd5, 0x5d, 0x32, 0xcd, 0x97, 0x93, 0x8a, 0xbd,
	0x28, 0xb9, 0xd1, 0x01, 0xe8, 0x6d, 0xc7, 0xeb, 0x7f, 0xbd, 0x10, 0x01, 0x25, 0x36, 0x3d, 0xa0,
	0x98, 0xc9, 0xb6, 0xe3, 0xa9, 0xe5, 0x89, 0x40, 0xf8, 0x39, 0xdc, 0xe2, 0xfd, 0x1c, 0x66, 0x81,
	0xd5, 0x6c, 0x3a, 0x36, 0xdf, 0x75, 0x71, 0xc9, 0x84, 0x3f, 0x26, 0x78, 0xc2, 0x75, 0xdc, 0x9a,
	0xa4, 0x55, 0x3c, 0x71, 0x91, 0xf6, 0x7f, 0xc6, 0xef, 0xf4, 0x57, 0xf0, 0x45, 0x74, 0x85, 0x3c,
	0xe5, 0x72, 0xa4, 0x30, 0x18, 0x93, 0x7c, 0x76, 0x3f, 0xcf, 0x91, 0xbf, 0x86, 0x9f, 0x5d, 0x07,
	0x79, 0x12, 0x48, 0xea, 0xf7, 0x1a, 0xac, 0x4f, 0x3c, 0x29, 0xf4, 0x15, 0x18, 0x22, 0x70, 0xf9,
	0x94, 0xf1, 0xba, 0x5a, 0x3c, 0xbd, 0x29, 0x07, 0x51, 0x11, 0xec, 0x16, 0x8f, 0x60, 0x8a, 0x7c,
	0xe0, 0x07, 0x0a, 0x60, 0xbf, 0xc0, 0x6d, 0xfb, 0x05, 0xfc, 0xfc, 0x3a, 0xb6, 0x4d, 0x54, 0x7f,
	0x75, 0x8e, 0x1e, 0x46, 0xc9, 0x6d, 0xc0, 0x7a, 0x3f, 0x60, 0x84, 0x1f, 0x6d, 0x3b, 0xc4, 0x76,
	0x9a, 0x0e, 0x09, 0x52, 0xff, 0xa9, 0xc1, 0xc2, 0xe0, 0x0b, 0x69, 0x19, 0x96, 0xea, 0x16, 0x25,
	0x97, 0x8f, 0x77, 0xda, 0xb4, 0xc7, 0xbb, 0xe4, 0xfb, 0xdc, 0xc2, 0x0f, 0x5a, 0x22, 0xa1, 0xa9,
	0xa7, 0xdd, 0x45, 0x2e, 0xdf, 0x7f, 0xbf, 0x7b, 0x01, 0x8b, 0x6d, 0xeb, 0xdd, 0x25, 0x5c, 0xec,
	0xc3, 0xde, 0x89, 0x17, 0xda, 0xd6, 0xbb, 0x10, 0x6b, 0xff, 0x31, 0x5f, 0x74, 0x1a, 0xb6, 0xa2,
	0xf3, 0xce, 0xe5, 0x22, 0x52, 0x4d, 0x48, 0x4f, 0x7f, 0xe5, 0x46, 0x3a, 0xcc, 0x9e, 0x13, 0xd9,
	0xaa, 0xcc, 0x9b, 0xfc, 0x27, 0xda, 0x81, 0x1b, 0x17, 0xdc, 0xbb, 0xaf, 0xec, 0xf2, 0x24, 0xcb,
	0x7e, 0xec, 0xff, 0x69, 0xe9, 0xd7, 0xb0, 0x34, 0xf4, 0xd9, 0x11, 0x01, 0xdc, 0xac, 0xd6, 0xb2,
	0xb5, 0xa3, 0xbc, 0x3e, 0x83, 0x92, 0x00, 0xd5, 0x9a, 0x79, 0x94, 0xaf, 0xe1, 0x42, 0xb9, 0xaa,
	0x6b, 0xbc, 0x1a, 0x2b, 0x55, 0x9e, 0x1f, 0xe5, 0xb3, 0x25, 0x31, 0x11, 0x43, 0x73, 0x30, 0x5b,
	0x2c, 0x54, 0xf5, 0x59, 0x5e, 0x96, 0x55, 0xcc, 0xa3, 0xe7, 0x47, 0x65, 0x4e, 0xaa, 0xd6, 0xf4,
	0x78, 0xfa, 0x9f, 0x34, 0x48, 0x84, 0xdf, 0xc2, 0xb8, 0xa0, 0x59, 0x39, 0x2d, 0x17, 0xb0, 0x59,
	0xc9, 0x1d, 0x95, 0x65, 0x4a, 0x2e, 0x15, 0xb3, 0xd5, 0x1a, 0x36, 0x8b, 0xbf, 0x3a, 0x2d, 0x56,
	0x79, 0x1d, 0xb7, 0x04, 0xf3, 0xe6, 0x51, 0xf9, 0xb9, 0x4c, 0xda, 0x31, 0x6e, 0x87, 0x99, 0x2d,
	0x17, 0x2a, 0xc7, 0xfa, 0x2c, 0xff, 0x7d, 0x9c, 0x7d, 0x5e, 0x2a, 0xbe, 0xd2, 0x6f, 0xa0, 0x35,
	0xd0, 0xf3, 0xa5, 0xd3, 0x6a, 0xad, 0x68, 0xe2, 0x13, 0xb3, 0xf2, 0xea, 0xa8, 0x50, 0x2c, 0xe8,
	0x37, 0xd1, 0x16, 0xdc, 0x2d, 0x55, 0xb2, 0x05, 0x9c, 0xcb, 0x96, 0xb2, 0xe5, 0x3c, 0x87, 0x39,
	0xa9, 0x94, 0x8e, 0xf2, 0x6f, 0x70, 0xbe, 0x52, 0x3e, 0x38, 0x7a, 0xae, 0xcf, 0xa5, 0xe3, 0x89,
	0xb8, 0x1e, 0xdf, 0x59, 0x1e, 0xb4, 0x12, 0x97, 0x72, 0xe9, 0x2f, 0x60, 0x79, 0xe4, 0xb1, 0x1b,
	0x25, 0x20, 0x9e, 0x3d, 0xad, 0x55, 0xf4, 0x19, 0x5e, 0x45, 0xbc, 0x7a, 0x86, 0x2b, 0xe5, 0xd2,
	0x1b, 0x5d, 0x13, 0x83, 0x2f, 0xe5, 0x20, 0x96, 0xae, 0x81, 0x31, 0xe9, 0xfd, 0x0a, 0x6d, 0xc0,
	0x9d, 0xd3, 0x6a, 0x51, 0x69, 0x3e, 0x35, 0x8b, 0x05, 0x6e, 0x68, 0xad, 0x92, 0xaf, 0x94, 0xf4,
	0x99, 0x90, 0x58, 0xa8, 0xbc, 0x2e, 0x57, 0x6b, 0x66, 0x31, 0x7b, 0x7c, 0x49, 0xd4, 0xf6, 0x37,
	0xb8, 0x77, 0xdc, 0x86, 0xb5, 0x28, 0xef, 0xc8, 0x19, 0x70, 0x3b, 0x0c, 0x71, 0x8d, 0xf0, 0xc4,
	0xc4, 0x77, 0xe0, 0xdc, 0x82, 0xf8, 0x4e, 0x69, 0x87, 0xb5, 0xca, 0xa2, 0xbe, 0xf4, 0x22, 0x9e,
	0x58, 0xd6, 0xf5, 0x17, 0xf1, 0xc4, 0x9c, 0x9e, 0x78, 0x11, 0x4f, 0x2c, 0xe8, 0x8b, 0x2f, 0xe2,
	0x89, 0x8f, 0xf4, 0x87, 0xe6, 0x0d, 0x91, 0x96, 0xcc, 0x05, 0xe6, 0x8a, 0x9e, 0x9c, 0x91, 0x77,
	0xcc, 0x4c, 0x4d, 0xfe, 0x22, 0x93, 0xfe, 0x3e, 0x06, 0xab, 0x11, 0x6f, 0x3f, 0xa8, 0x02, 0x09,
	0xd1, 0x26, 0x39, 0x44, 0x36, 0x52, 0x0b, 0x7b, 0x4f, 0x3f, 0xe4, 0xed, 0x28, 0xa3, 0x9e, 0x90,
	0xfa, 0x20, 0xa9, 0xdf, 0x69, 0x70, 0x53, 0x61, 0xa3, 0xc1, 0xc7, 0x8c, 0x09, 0x6f, 0x18, 0xb3,
	0xd7, 0x7d, 0xc3, 0xc8, 0xf0, 0x2d, 0x7d, 0x02, 0x8f, 0x87, 0xb6, 0x74, 0xb2, 0x45, 0xb2, 0xd4,
	0x33, 0x6f, 0x4a, 0x35, 0xd1, 0xd7, 0x35, 0x42, 0x3a, 0xfd, 0x1b, 0x0d, 0xd0, 0xe9, 0xf8, 0x33,
	0x7d, 0x01, 0x92, 0xf2, 0x9f, 0x4b, 0xb0, 0xfa, 0x7f, 0x15, 0x15, 0x8b, 0xa6, 0x7c, 0x1d, 0x59,
	0x92, 0x42, 0x6a, 0xb8, 0xff, 0x31, 0xb7, 0xe2, 0x01, 0xdc, 0x1f, 0xb2, 0x62, 0x5c, 0x5b, 0xfa,
	0x77, 0x1a, 0xac, 0x4f, 0x7c, 0xea, 0x44, 0xcf, 0x61, 0x89, 0xd9, 0x1d, 0x7c, 0x4e, 0x48, 0xc7,
	0x72, 0x9d, 0x0b, 0x72, 0xf5, 0x63, 0x4c, 0xcd, 0xee, 0xbc, 0x0c, 0x39, 0xcd, 0x45, 0x36, 0x30,
	0x8a, 0x7e, 0x16, 0x9a, 0xa8, 0x37, 0xf7, 0xf2, 0x0f, 0x3f, 0x6e, 0x6a, 0xff, 0xfe, 0xe3, 0xa6,
	0xf6, 0x5f, 0x3f, 0x6e, 0x6a, 0xff, 0xf2, 0xdd, 0x1f, 0xfe, 0xe3, 0x66, 0x4c, 0xd7, 0xe0, 0x91,
	0xe3, 0x4b, 0xc5, 0x9d, 0xc0, 0x7f, 0xd7, 0x9b, 0xe4, 0x3b, 0xb9, 0xc5, 0xc1, 0x5b, 0x76, 0xa2,
	0xd5, 0x6f, 0x8a, 0x93, 0x7e, 0xfa, 0xbf, 0x01, 0x00, 0x00, 0xff, 0xff, 0xff, 0x0c, 0x1a, 0x91,
	0xdb, 0x24, 0x00, 0x00,
}

func (m *Cluster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cluster) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Cluster) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TrackTimeoutBudgets {
		i--
		if m.TrackTimeoutBudgets {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf8
	}
	if m.UpstreamHttpProtocolOptions != nil {
		{
			size, err := m.UpstreamHttpProtocolOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf2
	}
	if m.UseTcpForDnsLookups {
		i--
		if m.UseTcpForDnsLookups {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe8
	}
	if m.DnsFailureRefreshRate != nil {
		{
			size, err := m.DnsFailureRefreshRate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe2
	}
	if len(m.TransportSocketMatches) > 0 {
		for iNdEx := len(m.TransportSocketMatches) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TransportSocketMatches[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCluster(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xda
		}
	}
	if m.LrsServer != nil {
		{
			size, err := m.LrsServer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd2
	}
	if m.LoadBalancingPolicy != nil {
		{
			size, err := m.LoadBalancingPolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xca
	}
	if len(m.Filters) > 0 {
		for iNdEx := len(m.Filters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Filters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCluster(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xc2
		}
	}
	if m.RespectDnsTtl {
		i--
		if m.RespectDnsTtl {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb8
	}
	if m.ClusterDiscoveryType != nil {
		{
			size := m.ClusterDiscoveryType.Size()
			i -= size
			if _, err := m.ClusterDiscoveryType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.LbConfig != nil {
		{
			size := m.LbConfig.Size()
			i -= size
			if _, err := m.LbConfig.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.TypedExtensionProtocolOptions) > 0 {
		for k := range m.TypedExtensionProtocolOptions {
			v := m.TypedExtensionProtocolOptions[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintCluster(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCluster(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCluster(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xa2
		}
	}
	if m.LoadAssignment != nil {
		{
			size, err := m.LoadAssignment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x8a
	}
	if m.IgnoreHealthOnHostRemoval {
		i--
		if m.IgnoreHealthOnHostRemoval {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x80
	}
	if m.CloseConnectionsOnHostHealthFailure {
		i--
		if m.CloseConnectionsOnHostHealthFailure {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if m.UpstreamConnectionOptions != nil {
		{
			size, err := m.UpstreamConnectionOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if m.CommonHttpProtocolOptions != nil {
		{
			size, err := m.CommonHttpProtocolOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xea
	}
	if len(m.AltStatName) > 0 {
		i -= len(m.AltStatName)
		copy(dAtA[i:], m.AltStatName)
		i = encodeVarintCluster(dAtA, i, uint64(len(m.AltStatName)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	if m.CommonLbConfig != nil {
		{
			size, err := m.CommonLbConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	if m.ProtocolSelection != 0 {
		i = encodeVarintCluster(dAtA, i, uint64(m.ProtocolSelection))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if m.TransportSocket != nil {
		{
			size, err := m.TransportSocket.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.LbSubsetConfig != nil {
		{
			size, err := m.LbSubsetConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.UpstreamBindConfig != nil {
		{
			size, err := m.UpstreamBindConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.CleanupInterval != nil {
		{
			size, err := m.CleanupInterval.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.OutlierDetection != nil {
		{
			size, err := m.OutlierDetection.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if len(m.DnsResolvers) > 0 {
		for iNdEx := len(m.DnsResolvers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DnsResolvers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCluster(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x92
		}
	}
	if m.DnsLookupFamily != 0 {
		i = encodeVarintCluster(dAtA, i, uint64(m.DnsLookupFamily))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.DnsRefreshRate != nil {
		{
			size, err := m.DnsRefreshRate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.Http2ProtocolOptions != nil {
		{
			size, err := m.Http2ProtocolOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.HttpProtocolOptions != nil {
		{
			size, err := m.HttpProtocolOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.CircuitBreakers != nil {
		{
			size, err := m.CircuitBreakers.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.MaxRequestsPerConnection != nil {
		{
			size, err := m.MaxRequestsPerConnection.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.HealthChecks) > 0 {
		for iNdEx := len(m.HealthChecks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.HealthChecks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCluster(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.LbPolicy != 0 {
		i = encodeVarintCluster(dAtA, i, uint64(m.LbPolicy))
		i--
		dAtA[i] = 0x30
	}
	if m.PerConnectionBufferLimitBytes != nil {
		{
			size, err := m.PerConnectionBufferLimitBytes.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.ConnectTimeout != nil {
		{
			size, err := m.ConnectTimeout.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.EdsClusterConfig != nil {
		{
			size, err := m.EdsClusterConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCluster(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Cluster_Type) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Cluster_Type) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintCluster(dAtA, i, uint64(m.Type))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *Cluster_RingHashLbConfig_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Cluster_RingHashLbConfig_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RingHashLbConfig != nil {
		{
			size, err := m.RingHashLbConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	return len(dAtA) - i, nil
}
func (m *Cluster_OriginalDstLbConfig_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Cluster_OriginalDstLbConfig_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.OriginalDstLbConfig != nil {
		{
			size, err := m.OriginalDstLbConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *Cluster_LeastRequestLbConfig_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Cluster_LeastRequestLbConfig_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LeastRequestLbConfig != nil {
		{
			size, err := m.LeastRequestLbConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *Cluster_ClusterType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Cluster_ClusterType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ClusterType != nil {
		{
			size, err := m.ClusterType.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *Cluster_TransportSocketMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cluster_TransportSocketMatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Cluster_TransportSocketMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TransportSocket != nil {
		{
			size, err := m.TransportSocket.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Match != nil {
		{
			size, err := m.Match.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCluster(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Cluster_CustomClusterType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cluster_CustomClusterType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Cluster_CustomClusterType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TypedConfig != nil {
		{
			size, err := m.TypedConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCluster(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Cluster_EdsClusterConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cluster_EdsClusterConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Cluster_EdsClusterConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ServiceName) > 0 {
		i -= len(m.ServiceName)
		copy(dAtA[i:], m.ServiceName)
		i = encodeVarintCluster(dAtA, i, uint64(len(m.ServiceName)))
		i--
		dAtA[i] = 0x12
	}
	if m.EdsConfig != nil {
		{
			size, err := m.EdsConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Cluster_LbSubsetConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cluster_LbSubsetConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Cluster_LbSubsetConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ListAsAny {
		i--
		if m.ListAsAny {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.PanicModeAny {
		i--
		if m.PanicModeAny {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.ScaleLocalityWeight {
		i--
		if m.ScaleLocalityWeight {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.LocalityWeightAware {
		i--
		if m.LocalityWeightAware {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.SubsetSelectors) > 0 {
		for iNdEx := len(m.SubsetSelectors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SubsetSelectors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCluster(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.DefaultSubset != nil {
		{
			size, err := m.DefaultSubset.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.FallbackPolicy != 0 {
		i = encodeVarintCluster(dAtA, i, uint64(m.FallbackPolicy))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Cluster_LbSubsetConfig_LbSubsetSelector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cluster_LbSubsetConfig_LbSubsetSelector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Cluster_LbSubsetConfig_LbSubsetSelector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.FallbackKeysSubset) > 0 {
		for iNdEx := len(m.FallbackKeysSubset) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FallbackKeysSubset[iNdEx])
			copy(dAtA[i:], m.FallbackKeysSubset[iNdEx])
			i = encodeVarintCluster(dAtA, i, uint64(len(m.FallbackKeysSubset[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.FallbackPolicy != 0 {
		i = encodeVarintCluster(dAtA, i, uint64(m.FallbackPolicy))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Keys) > 0 {
		for iNdEx := len(m.Keys) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Keys[iNdEx])
			copy(dAtA[i:], m.Keys[iNdEx])
			i = encodeVarintCluster(dAtA, i, uint64(len(m.Keys[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Cluster_LeastRequestLbConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cluster_LeastRequestLbConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Cluster_LeastRequestLbConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ChoiceCount != nil {
		{
			size, err := m.ChoiceCount.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Cluster_RingHashLbConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cluster_RingHashLbConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Cluster_RingHashLbConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MaximumRingSize != nil {
		{
			size, err := m.MaximumRingSize.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.HashFunction != 0 {
		i = encodeVarintCluster(dAtA, i, uint64(m.HashFunction))
		i--
		dAtA[i] = 0x18
	}
	if m.MinimumRingSize != nil {
		{
			size, err := m.MinimumRingSize.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Cluster_OriginalDstLbConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cluster_OriginalDstLbConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Cluster_OriginalDstLbConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UseHttpHeader {
		i--
		if m.UseHttpHeader {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Cluster_CommonLbConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cluster_CommonLbConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Cluster_CommonLbConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ConsistentHashingLbConfig != nil {
		{
			size, err := m.ConsistentHashingLbConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.CloseConnectionsOnHostSetChange {
		i--
		if m.CloseConnectionsOnHostSetChange {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.IgnoreNewHostsUntilFirstHc {
		i--
		if m.IgnoreNewHostsUntilFirstHc {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.UpdateMergeWindow != nil {
		{
			size, err := m.UpdateMergeWindow.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.LocalityConfigSpecifier != nil {
		{
			size := m.LocalityConfigSpecifier.Size()
			i -= size
			if _, err := m.LocalityConfigSpecifier.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.HealthyPanicThreshold != nil {
		{
			size, err := m.HealthyPanicThreshold.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Cluster_CommonLbConfig_ZoneAwareLbConfig_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Cluster_CommonLbConfig_ZoneAwareLbConfig_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ZoneAwareLbConfig != nil {
		{
			size, err := m.ZoneAwareLbConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Cluster_CommonLbConfig_LocalityWeightedLbConfig_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Cluster_CommonLbConfig_LocalityWeightedLbConfig_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LocalityWeightedLbConfig != nil {
		{
			size, err := m.LocalityWeightedLbConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Cluster_CommonLbConfig_ZoneAwareLbConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cluster_CommonLbConfig_ZoneAwareLbConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Cluster_CommonLbConfig_ZoneAwareLbConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.FailTrafficOnPanic {
		i--
		if m.FailTrafficOnPanic {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.MinClusterSize != nil {
		{
			size, err := m.MinClusterSize.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.RoutingEnabled != nil {
		{
			size, err := m.RoutingEnabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Cluster_CommonLbConfig_LocalityWeightedLbConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cluster_CommonLbConfig_LocalityWeightedLbConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Cluster_CommonLbConfig_LocalityWeightedLbConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *Cluster_CommonLbConfig_ConsistentHashingLbConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cluster_CommonLbConfig_ConsistentHashingLbConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Cluster_CommonLbConfig_ConsistentHashingLbConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UseHostnameForHashing {
		i--
		if m.UseHostnameForHashing {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Cluster_RefreshRate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cluster_RefreshRate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Cluster_RefreshRate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MaxInterval != nil {
		{
			size, err := m.MaxInterval.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.BaseInterval != nil {
		{
			size, err := m.BaseInterval.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LoadBalancingPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoadBalancingPolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoadBalancingPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Policies) > 0 {
		for iNdEx := len(m.Policies) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Policies[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCluster(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *LoadBalancingPolicy_Policy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoadBalancingPolicy_Policy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoadBalancingPolicy_Policy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TypedConfig != nil {
		{
			size, err := m.TypedConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCluster(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpstreamBindConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpstreamBindConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpstreamBindConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SourceAddress != nil {
		{
			size, err := m.SourceAddress.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpstreamConnectionOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpstreamConnectionOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpstreamConnectionOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TcpKeepalive != nil {
		{
			size, err := m.TcpKeepalive.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintCluster(dAtA []byte, offset int, v uint64) int {
	offset -= sovCluster(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Cluster) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.ClusterDiscoveryType != nil {
		n += m.ClusterDiscoveryType.Size()
	}
	if m.EdsClusterConfig != nil {
		l = m.EdsClusterConfig.Size()
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.ConnectTimeout != nil {
		l = m.ConnectTimeout.Size()
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.PerConnectionBufferLimitBytes != nil {
		l = m.PerConnectionBufferLimitBytes.Size()
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.LbPolicy != 0 {
		n += 1 + sovCluster(uint64(m.LbPolicy))
	}
	if len(m.HealthChecks) > 0 {
		for _, e := range m.HealthChecks {
			l = e.Size()
			n += 1 + l + sovCluster(uint64(l))
		}
	}
	if m.MaxRequestsPerConnection != nil {
		l = m.MaxRequestsPerConnection.Size()
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.CircuitBreakers != nil {
		l = m.CircuitBreakers.Size()
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.HttpProtocolOptions != nil {
		l = m.HttpProtocolOptions.Size()
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.Http2ProtocolOptions != nil {
		l = m.Http2ProtocolOptions.Size()
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.DnsRefreshRate != nil {
		l = m.DnsRefreshRate.Size()
		n += 2 + l + sovCluster(uint64(l))
	}
	if m.DnsLookupFamily != 0 {
		n += 2 + sovCluster(uint64(m.DnsLookupFamily))
	}
	if len(m.DnsResolvers) > 0 {
		for _, e := range m.DnsResolvers {
			l = e.Size()
			n += 2 + l + sovCluster(uint64(l))
		}
	}
	if m.OutlierDetection != nil {
		l = m.OutlierDetection.Size()
		n += 2 + l + sovCluster(uint64(l))
	}
	if m.CleanupInterval != nil {
		l = m.CleanupInterval.Size()
		n += 2 + l + sovCluster(uint64(l))
	}
	if m.UpstreamBindConfig != nil {
		l = m.UpstreamBindConfig.Size()
		n += 2 + l + sovCluster(uint64(l))
	}
	if m.LbSubsetConfig != nil {
		l = m.LbSubsetConfig.Size()
		n += 2 + l + sovCluster(uint64(l))
	}
	if m.LbConfig != nil {
		n += m.LbConfig.Size()
	}
	if m.TransportSocket != nil {
		l = m.TransportSocket.Size()
		n += 2 + l + sovCluster(uint64(l))
	}
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 2 + l + sovCluster(uint64(l))
	}
	if m.ProtocolSelection != 0 {
		n += 2 + sovCluster(uint64(m.ProtocolSelection))
	}
	if m.CommonLbConfig != nil {
		l = m.CommonLbConfig.Size()
		n += 2 + l + sovCluster(uint64(l))
	}
	l = len(m.AltStatName)
	if l > 0 {
		n += 2 + l + sovCluster(uint64(l))
	}
	if m.CommonHttpProtocolOptions != nil {
		l = m.CommonHttpProtocolOptions.Size()
		n += 2 + l + sovCluster(uint64(l))
	}
	if m.UpstreamConnectionOptions != nil {
		l = m.UpstreamConnectionOptions.Size()
		n += 2 + l + sovCluster(uint64(l))
	}
	if m.CloseConnectionsOnHostHealthFailure {
		n += 3
	}
	if m.IgnoreHealthOnHostRemoval {
		n += 3
	}
	if m.LoadAssignment != nil {
		l = m.LoadAssignment.Size()
		n += 2 + l + sovCluster(uint64(l))
	}
	if len(m.TypedExtensionProtocolOptions) > 0 {
		for k, v := range m.TypedExtensionProtocolOptions {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCluster(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovCluster(uint64(len(k))) + l
			n += mapEntrySize + 2 + sovCluster(uint64(mapEntrySize))
		}
	}
	if m.RespectDnsTtl {
		n += 3
	}
	if len(m.Filters) > 0 {
		for _, e := range m.Filters {
			l = e.Size()
			n += 2 + l + sovCluster(uint64(l))
		}
	}
	if m.LoadBalancingPolicy != nil {
		l = m.LoadBalancingPolicy.Size()
		n += 2 + l + sovCluster(uint64(l))
	}
	if m.LrsServer != nil {
		l = m.LrsServer.Size()
		n += 2 + l + sovCluster(uint64(l))
	}
	if len(m.TransportSocketMatches) > 0 {
		for _, e := range m.TransportSocketMatches {
			l = e.Size()
			n += 2 + l + sovCluster(uint64(l))
		}
	}
	if m.DnsFailureRefreshRate != nil {
		l = m.DnsFailureRefreshRate.Size()
		n += 2 + l + sovCluster(uint64(l))
	}
	if m.UseTcpForDnsLookups {
		n += 3
	}
	if m.UpstreamHttpProtocolOptions != nil {
		l = m.UpstreamHttpProtocolOptions.Size()
		n += 2 + l + sovCluster(uint64(l))
	}
	if m.TrackTimeoutBudgets {
		n += 3
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Cluster_Type) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCluster(uint64(m.Type))
	return n
}
func (m *Cluster_RingHashLbConfig_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RingHashLbConfig != nil {
		l = m.RingHashLbConfig.Size()
		n += 2 + l + sovCluster(uint64(l))
	}
	return n
}
func (m *Cluster_OriginalDstLbConfig_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OriginalDstLbConfig != nil {
		l = m.OriginalDstLbConfig.Size()
		n += 2 + l + sovCluster(uint64(l))
	}
	return n
}
func (m *Cluster_LeastRequestLbConfig_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LeastRequestLbConfig != nil {
		l = m.LeastRequestLbConfig.Size()
		n += 2 + l + sovCluster(uint64(l))
	}
	return n
}
func (m *Cluster_ClusterType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClusterType != nil {
		l = m.ClusterType.Size()
		n += 2 + l + sovCluster(uint64(l))
	}
	return n
}
func (m *Cluster_TransportSocketMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.Match != nil {
		l = m.Match.Size()
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.TransportSocket != nil {
		l = m.TransportSocket.Size()
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Cluster_CustomClusterType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.TypedConfig != nil {
		l = m.TypedConfig.Size()
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Cluster_EdsClusterConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EdsConfig != nil {
		l = m.EdsConfig.Size()
		n += 1 + l + sovCluster(uint64(l))
	}
	l = len(m.ServiceName)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Cluster_LbSubsetConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FallbackPolicy != 0 {
		n += 1 + sovCluster(uint64(m.FallbackPolicy))
	}
	if m.DefaultSubset != nil {
		l = m.DefaultSubset.Size()
		n += 1 + l + sovCluster(uint64(l))
	}
	if len(m.SubsetSelectors) > 0 {
		for _, e := range m.SubsetSelectors {
			l = e.Size()
			n += 1 + l + sovCluster(uint64(l))
		}
	}
	if m.LocalityWeightAware {
		n += 2
	}
	if m.ScaleLocalityWeight {
		n += 2
	}
	if m.PanicModeAny {
		n += 2
	}
	if m.ListAsAny {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Cluster_LbSubsetConfig_LbSubsetSelector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, s := range m.Keys {
			l = len(s)
			n += 1 + l + sovCluster(uint64(l))
		}
	}
	if m.FallbackPolicy != 0 {
		n += 1 + sovCluster(uint64(m.FallbackPolicy))
	}
	if len(m.FallbackKeysSubset) > 0 {
		for _, s := range m.FallbackKeysSubset {
			l = len(s)
			n += 1 + l + sovCluster(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Cluster_LeastRequestLbConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChoiceCount != nil {
		l = m.ChoiceCount.Size()
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Cluster_RingHashLbConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MinimumRingSize != nil {
		l = m.MinimumRingSize.Size()
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.HashFunction != 0 {
		n += 1 + sovCluster(uint64(m.HashFunction))
	}
	if m.MaximumRingSize != nil {
		l = m.MaximumRingSize.Size()
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Cluster_OriginalDstLbConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UseHttpHeader {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Cluster_CommonLbConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HealthyPanicThreshold != nil {
		l = m.HealthyPanicThreshold.Size()
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.LocalityConfigSpecifier != nil {
		n += m.LocalityConfigSpecifier.Size()
	}
	if m.UpdateMergeWindow != nil {
		l = m.UpdateMergeWindow.Size()
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.IgnoreNewHostsUntilFirstHc {
		n += 2
	}
	if m.CloseConnectionsOnHostSetChange {
		n += 2
	}
	if m.ConsistentHashingLbConfig != nil {
		l = m.ConsistentHashingLbConfig.Size()
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Cluster_CommonLbConfig_ZoneAwareLbConfig_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ZoneAwareLbConfig != nil {
		l = m.ZoneAwareLbConfig.Size()
		n += 1 + l + sovCluster(uint64(l))
	}
	return n
}
func (m *Cluster_CommonLbConfig_LocalityWeightedLbConfig_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LocalityWeightedLbConfig != nil {
		l = m.LocalityWeightedLbConfig.Size()
		n += 1 + l + sovCluster(uint64(l))
	}
	return n
}
func (m *Cluster_CommonLbConfig_ZoneAwareLbConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RoutingEnabled != nil {
		l = m.RoutingEnabled.Size()
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.MinClusterSize != nil {
		l = m.MinClusterSize.Size()
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.FailTrafficOnPanic {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Cluster_CommonLbConfig_LocalityWeightedLbConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Cluster_CommonLbConfig_ConsistentHashingLbConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UseHostnameForHashing {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Cluster_RefreshRate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BaseInterval != nil {
		l = m.BaseInterval.Size()
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.MaxInterval != nil {
		l = m.MaxInterval.Size()
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LoadBalancingPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Policies) > 0 {
		for _, e := range m.Policies {
			l = e.Size()
			n += 1 + l + sovCluster(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LoadBalancingPolicy_Policy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.TypedConfig != nil {
		l = m.TypedConfig.Size()
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpstreamBindConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SourceAddress != nil {
		l = m.SourceAddress.Size()
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpstreamConnectionOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TcpKeepalive != nil {
		l = m.TcpKeepalive.Size()
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovCluster(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCluster(x uint64) (n int) {
	return sovCluster(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Cluster) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cluster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cluster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v Cluster_DiscoveryType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= Cluster_DiscoveryType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ClusterDiscoveryType = &Cluster_Type{v}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EdsClusterConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EdsClusterConfig == nil {
				m.EdsClusterConfig = &Cluster_EdsClusterConfig{}
			}
			if err := m.EdsClusterConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectTimeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConnectTimeout == nil {
				m.ConnectTimeout = &types.Duration{}
			}
			if err := m.ConnectTimeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerConnectionBufferLimitBytes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PerConnectionBufferLimitBytes == nil {
				m.PerConnectionBufferLimitBytes = &types.UInt32Value{}
			}
			if err := m.PerConnectionBufferLimitBytes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LbPolicy", wireType)
			}
			m.LbPolicy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LbPolicy |= Cluster_LbPolicy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthChecks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HealthChecks = append(m.HealthChecks, &v31.HealthCheck{})
			if err := m.HealthChecks[len(m.HealthChecks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRequestsPerConnection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxRequestsPerConnection == nil {
				m.MaxRequestsPerConnection = &types.UInt32Value{}
			}
			if err := m.MaxRequestsPerConnection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CircuitBreakers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CircuitBreakers == nil {
				m.CircuitBreakers = &CircuitBreakers{}
			}
			if err := m.CircuitBreakers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpProtocolOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HttpProtocolOptions == nil {
				m.HttpProtocolOptions = &v31.Http1ProtocolOptions{}
			}
			if err := m.HttpProtocolOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Http2ProtocolOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Http2ProtocolOptions == nil {
				m.Http2ProtocolOptions = &v31.Http2ProtocolOptions{}
			}
			if err := m.Http2ProtocolOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsRefreshRate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DnsRefreshRate == nil {
				m.DnsRefreshRate = &types.Duration{}
			}
			if err := m.DnsRefreshRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsLookupFamily", wireType)
			}
			m.DnsLookupFamily = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DnsLookupFamily |= Cluster_DnsLookupFamily(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsResolvers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DnsResolvers = append(m.DnsResolvers, &v31.Address{})
			if err := m.DnsResolvers[len(m.DnsResolvers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutlierDetection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutlierDetection == nil {
				m.OutlierDetection = &OutlierDetection{}
			}
			if err := m.OutlierDetection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CleanupInterval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CleanupInterval == nil {
				m.CleanupInterval = &types.Duration{}
			}
			if err := m.CleanupInterval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpstreamBindConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpstreamBindConfig == nil {
				m.UpstreamBindConfig = &v31.BindConfig{}
			}
			if err := m.UpstreamBindConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LbSubsetConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LbSubsetConfig == nil {
				m.LbSubsetConfig = &Cluster_LbSubsetConfig{}
			}
			if err := m.LbSubsetConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RingHashLbConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Cluster_RingHashLbConfig{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LbConfig = &Cluster_RingHashLbConfig_{v}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransportSocket", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransportSocket == nil {
				m.TransportSocket = &v31.TransportSocket{}
			}
			if err := m.TransportSocket.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &v31.Metadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolSelection", wireType)
			}
			m.ProtocolSelection = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProtocolSelection |= Cluster_ClusterProtocolSelection(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommonLbConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CommonLbConfig == nil {
				m.CommonLbConfig = &Cluster_CommonLbConfig{}
			}
			if err := m.CommonLbConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AltStatName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AltStatName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommonHttpProtocolOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CommonHttpProtocolOptions == nil {
				m.CommonHttpProtocolOptions = &v31.HttpProtocolOptions{}
			}
			if err := m.CommonHttpProtocolOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpstreamConnectionOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpstreamConnectionOptions == nil {
				m.UpstreamConnectionOptions = &UpstreamConnectionOptions{}
			}
			if err := m.UpstreamConnectionOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseConnectionsOnHostHealthFailure", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CloseConnectionsOnHostHealthFailure = bool(v != 0)
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreHealthOnHostRemoval", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IgnoreHealthOnHostRemoval = bool(v != 0)
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadAssignment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LoadAssignment == nil {
				m.LoadAssignment = &v3.ClusterLoadAssignment{}
			}
			if err := m.LoadAssignment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginalDstLbConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Cluster_OriginalDstLbConfig{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LbConfig = &Cluster_OriginalDstLbConfig_{v}
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypedExtensionProtocolOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TypedExtensionProtocolOptions == nil {
				m.TypedExtensionProtocolOptions = make(map[string]*types.Any)
			}
			var mapkey string
			var mapvalue *types.Any
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCluster
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCluster
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCluster
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCluster
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCluster
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCluster
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthCluster
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &types.Any{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCluster(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCluster
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.TypedExtensionProtocolOptions[mapkey] = mapvalue
			iNdEx = postIndex
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeastRequestLbConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Cluster_LeastRequestLbConfig{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LbConfig = &Cluster_LeastRequestLbConfig_{v}
			iNdEx = postIndex
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Cluster_CustomClusterType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ClusterDiscoveryType = &Cluster_ClusterType{v}
			iNdEx = postIndex
		case 39:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RespectDnsTtl", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RespectDnsTtl = bool(v != 0)
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filters = append(m.Filters, &Filter{})
			if err := m.Filters[len(m.Filters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadBalancingPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LoadBalancingPolicy == nil {
				m.LoadBalancingPolicy = &LoadBalancingPolicy{}
			}
			if err := m.LoadBalancingPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LrsServer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LrsServer == nil {
				m.LrsServer = &v31.ConfigSource{}
			}
			if err := m.LrsServer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransportSocketMatches", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransportSocketMatches = append(m.TransportSocketMatches, &Cluster_TransportSocketMatch{})
			if err := m.TransportSocketMatches[len(m.TransportSocketMatches)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsFailureRefreshRate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DnsFailureRefreshRate == nil {
				m.DnsFailureRefreshRate = &Cluster_RefreshRate{}
			}
			if err := m.DnsFailureRefreshRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 45:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseTcpForDnsLookups", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseTcpForDnsLookups = bool(v != 0)
		case 46:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpstreamHttpProtocolOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpstreamHttpProtocolOptions == nil {
				m.UpstreamHttpProtocolOptions = &v31.UpstreamHttpProtocolOptions{}
			}
			if err := m.UpstreamHttpProtocolOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 47:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrackTimeoutBudgets", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TrackTimeoutBudgets = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cluster_TransportSocketMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransportSocketMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransportSocketMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Match == nil {
				m.Match = &types.Struct{}
			}
			if err := m.Match.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransportSocket", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransportSocket == nil {
				m.TransportSocket = &v31.TransportSocket{}
			}
			if err := m.TransportSocket.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cluster_CustomClusterType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CustomClusterType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CustomClusterType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypedConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TypedConfig == nil {
				m.TypedConfig = &types.Any{}
			}
			if err := m.TypedConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cluster_EdsClusterConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EdsClusterConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EdsClusterConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EdsConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EdsConfig == nil {
				m.EdsConfig = &v31.ConfigSource{}
			}
			if err := m.EdsConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cluster_LbSubsetConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LbSubsetConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LbSubsetConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FallbackPolicy", wireType)
			}
			m.FallbackPolicy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FallbackPolicy |= Cluster_LbSubsetConfig_LbSubsetFallbackPolicy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultSubset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultSubset == nil {
				m.DefaultSubset = &types.Struct{}
			}
			if err := m.DefaultSubset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubsetSelectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubsetSelectors = append(m.SubsetSelectors, &Cluster_LbSubsetConfig_LbSubsetSelector{})
			if err := m.SubsetSelectors[len(m.SubsetSelectors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalityWeightAware", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LocalityWeightAware = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScaleLocalityWeight", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ScaleLocalityWeight = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PanicModeAny", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PanicModeAny = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListAsAny", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ListAsAny = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cluster_LbSubsetConfig_LbSubsetSelector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LbSubsetSelector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LbSubsetSelector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FallbackPolicy", wireType)
			}
			m.FallbackPolicy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FallbackPolicy |= Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FallbackKeysSubset", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FallbackKeysSubset = append(m.FallbackKeysSubset, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cluster_LeastRequestLbConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeastRequestLbConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeastRequestLbConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChoiceCount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChoiceCount == nil {
				m.ChoiceCount = &types.UInt32Value{}
			}
			if err := m.ChoiceCount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cluster_RingHashLbConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RingHashLbConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RingHashLbConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinimumRingSize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MinimumRingSize == nil {
				m.MinimumRingSize = &types.UInt64Value{}
			}
			if err := m.MinimumRingSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashFunction", wireType)
			}
			m.HashFunction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HashFunction |= Cluster_RingHashLbConfig_HashFunction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaximumRingSize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaximumRingSize == nil {
				m.MaximumRingSize = &types.UInt64Value{}
			}
			if err := m.MaximumRingSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cluster_OriginalDstLbConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OriginalDstLbConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OriginalDstLbConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseHttpHeader", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseHttpHeader = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cluster_CommonLbConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommonLbConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommonLbConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthyPanicThreshold", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HealthyPanicThreshold == nil {
				m.HealthyPanicThreshold = &v32.Percent{}
			}
			if err := m.HealthyPanicThreshold.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZoneAwareLbConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Cluster_CommonLbConfig_ZoneAwareLbConfig{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LocalityConfigSpecifier = &Cluster_CommonLbConfig_ZoneAwareLbConfig_{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalityWeightedLbConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Cluster_CommonLbConfig_LocalityWeightedLbConfig{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LocalityConfigSpecifier = &Cluster_CommonLbConfig_LocalityWeightedLbConfig_{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateMergeWindow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdateMergeWindow == nil {
				m.UpdateMergeWindow = &types.Duration{}
			}
			if err := m.UpdateMergeWindow.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreNewHostsUntilFirstHc", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IgnoreNewHostsUntilFirstHc = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseConnectionsOnHostSetChange", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CloseConnectionsOnHostSetChange = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsistentHashingLbConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConsistentHashingLbConfig == nil {
				m.ConsistentHashingLbConfig = &Cluster_CommonLbConfig_ConsistentHashingLbConfig{}
			}
			if err := m.ConsistentHashingLbConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cluster_CommonLbConfig_ZoneAwareLbConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZoneAwareLbConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZoneAwareLbConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoutingEnabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RoutingEnabled == nil {
				m.RoutingEnabled = &v32.Percent{}
			}
			if err := m.RoutingEnabled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinClusterSize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MinClusterSize == nil {
				m.MinClusterSize = &types.UInt64Value{}
			}
			if err := m.MinClusterSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailTrafficOnPanic", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FailTrafficOnPanic = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cluster_CommonLbConfig_LocalityWeightedLbConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocalityWeightedLbConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocalityWeightedLbConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cluster_CommonLbConfig_ConsistentHashingLbConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsistentHashingLbConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsistentHashingLbConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseHostnameForHashing", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseHostnameForHashing = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cluster_RefreshRate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RefreshRate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RefreshRate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseInterval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BaseInterval == nil {
				m.BaseInterval = &types.Duration{}
			}
			if err := m.BaseInterval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxInterval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxInterval == nil {
				m.MaxInterval = &types.Duration{}
			}
			if err := m.MaxInterval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoadBalancingPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoadBalancingPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoadBalancingPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Policies = append(m.Policies, &LoadBalancingPolicy_Policy{})
			if err := m.Policies[len(m.Policies)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoadBalancingPolicy_Policy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Policy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Policy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypedConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TypedConfig == nil {
				m.TypedConfig = &types.Any{}
			}
			if err := m.TypedConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpstreamBindConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpstreamBindConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpstreamBindConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SourceAddress == nil {
				m.SourceAddress = &v31.Address{}
			}
			if err := m.SourceAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpstreamConnectionOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpstreamConnectionOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpstreamConnectionOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpKeepalive", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TcpKeepalive == nil {
				m.TcpKeepalive = &v31.TcpKeepalive{}
			}
			if err := m.TcpKeepalive.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCluster(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCluster
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCluster
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCluster
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCluster        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCluster          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCluster = fmt.Errorf("proto: unexpected end of group")
)
