// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: envoy/service/status/v2/csds.proto

package envoy_service_status_v2

import (
	context "context"
	fmt "fmt"
	_ "github.com/cncf/udpa/go/udpa/annotations"
	v2alpha "github.com/datawire/ambassador/pkg/api/envoy/admin/v2alpha"
	core "github.com/datawire/ambassador/pkg/api/envoy/api/v2/core"
	matcher "github.com/datawire/ambassador/pkg/api/envoy/type/matcher"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/gogo/protobuf/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	_ "istio.io/gogo-genproto/googleapis/google/api"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Status of a config.
type ConfigStatus int32

const (
	// Status info is not available/unknown.
	ConfigStatus_UNKNOWN ConfigStatus = 0
	// Management server has sent the config to client and received ACK.
	ConfigStatus_SYNCED ConfigStatus = 1
	// Config is not sent.
	ConfigStatus_NOT_SENT ConfigStatus = 2
	// Management server has sent the config to client but hasnâ€™t received
	// ACK/NACK.
	ConfigStatus_STALE ConfigStatus = 3
	// Management server has sent the config to client but received NACK.
	ConfigStatus_ERROR ConfigStatus = 4
)

var ConfigStatus_name = map[int32]string{
	0: "UNKNOWN",
	1: "SYNCED",
	2: "NOT_SENT",
	3: "STALE",
	4: "ERROR",
}

var ConfigStatus_value = map[string]int32{
	"UNKNOWN":  0,
	"SYNCED":   1,
	"NOT_SENT": 2,
	"STALE":    3,
	"ERROR":    4,
}

func (x ConfigStatus) String() string {
	return proto.EnumName(ConfigStatus_name, int32(x))
}

func (ConfigStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b8273221d61b8a20, []int{0}
}

// Request for client status of clients identified by a list of NodeMatchers.
type ClientStatusRequest struct {
	// Management server can use these match criteria to identify clients.
	// The match follows OR semantics.
	NodeMatchers         []*matcher.NodeMatcher `protobuf:"bytes,1,rep,name=node_matchers,json=nodeMatchers,proto3" json:"node_matchers,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *ClientStatusRequest) Reset()         { *m = ClientStatusRequest{} }
func (m *ClientStatusRequest) String() string { return proto.CompactTextString(m) }
func (*ClientStatusRequest) ProtoMessage()    {}
func (*ClientStatusRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b8273221d61b8a20, []int{0}
}
func (m *ClientStatusRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientStatusRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientStatusRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClientStatusRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientStatusRequest.Merge(m, src)
}
func (m *ClientStatusRequest) XXX_Size() int {
	return m.Size()
}
func (m *ClientStatusRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientStatusRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ClientStatusRequest proto.InternalMessageInfo

func (m *ClientStatusRequest) GetNodeMatchers() []*matcher.NodeMatcher {
	if m != nil {
		return m.NodeMatchers
	}
	return nil
}

// Detailed config (per xDS) with status.
// [#next-free-field: 6]
type PerXdsConfig struct {
	Status ConfigStatus `protobuf:"varint,1,opt,name=status,proto3,enum=envoy.service.status.v2.ConfigStatus" json:"status,omitempty"`
	// Types that are valid to be assigned to PerXdsConfig:
	//	*PerXdsConfig_ListenerConfig
	//	*PerXdsConfig_ClusterConfig
	//	*PerXdsConfig_RouteConfig
	//	*PerXdsConfig_ScopedRouteConfig
	PerXdsConfig         isPerXdsConfig_PerXdsConfig `protobuf_oneof:"per_xds_config"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *PerXdsConfig) Reset()         { *m = PerXdsConfig{} }
func (m *PerXdsConfig) String() string { return proto.CompactTextString(m) }
func (*PerXdsConfig) ProtoMessage()    {}
func (*PerXdsConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_b8273221d61b8a20, []int{1}
}
func (m *PerXdsConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PerXdsConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PerXdsConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PerXdsConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PerXdsConfig.Merge(m, src)
}
func (m *PerXdsConfig) XXX_Size() int {
	return m.Size()
}
func (m *PerXdsConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_PerXdsConfig.DiscardUnknown(m)
}

var xxx_messageInfo_PerXdsConfig proto.InternalMessageInfo

type isPerXdsConfig_PerXdsConfig interface {
	isPerXdsConfig_PerXdsConfig()
	MarshalTo([]byte) (int, error)
	Size() int
}

type PerXdsConfig_ListenerConfig struct {
	ListenerConfig *v2alpha.ListenersConfigDump `protobuf:"bytes,2,opt,name=listener_config,json=listenerConfig,proto3,oneof" json:"listener_config,omitempty"`
}
type PerXdsConfig_ClusterConfig struct {
	ClusterConfig *v2alpha.ClustersConfigDump `protobuf:"bytes,3,opt,name=cluster_config,json=clusterConfig,proto3,oneof" json:"cluster_config,omitempty"`
}
type PerXdsConfig_RouteConfig struct {
	RouteConfig *v2alpha.RoutesConfigDump `protobuf:"bytes,4,opt,name=route_config,json=routeConfig,proto3,oneof" json:"route_config,omitempty"`
}
type PerXdsConfig_ScopedRouteConfig struct {
	ScopedRouteConfig *v2alpha.ScopedRoutesConfigDump `protobuf:"bytes,5,opt,name=scoped_route_config,json=scopedRouteConfig,proto3,oneof" json:"scoped_route_config,omitempty"`
}

func (*PerXdsConfig_ListenerConfig) isPerXdsConfig_PerXdsConfig()    {}
func (*PerXdsConfig_ClusterConfig) isPerXdsConfig_PerXdsConfig()     {}
func (*PerXdsConfig_RouteConfig) isPerXdsConfig_PerXdsConfig()       {}
func (*PerXdsConfig_ScopedRouteConfig) isPerXdsConfig_PerXdsConfig() {}

func (m *PerXdsConfig) GetPerXdsConfig() isPerXdsConfig_PerXdsConfig {
	if m != nil {
		return m.PerXdsConfig
	}
	return nil
}

func (m *PerXdsConfig) GetStatus() ConfigStatus {
	if m != nil {
		return m.Status
	}
	return ConfigStatus_UNKNOWN
}

func (m *PerXdsConfig) GetListenerConfig() *v2alpha.ListenersConfigDump {
	if x, ok := m.GetPerXdsConfig().(*PerXdsConfig_ListenerConfig); ok {
		return x.ListenerConfig
	}
	return nil
}

func (m *PerXdsConfig) GetClusterConfig() *v2alpha.ClustersConfigDump {
	if x, ok := m.GetPerXdsConfig().(*PerXdsConfig_ClusterConfig); ok {
		return x.ClusterConfig
	}
	return nil
}

func (m *PerXdsConfig) GetRouteConfig() *v2alpha.RoutesConfigDump {
	if x, ok := m.GetPerXdsConfig().(*PerXdsConfig_RouteConfig); ok {
		return x.RouteConfig
	}
	return nil
}

func (m *PerXdsConfig) GetScopedRouteConfig() *v2alpha.ScopedRoutesConfigDump {
	if x, ok := m.GetPerXdsConfig().(*PerXdsConfig_ScopedRouteConfig); ok {
		return x.ScopedRouteConfig
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*PerXdsConfig) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*PerXdsConfig_ListenerConfig)(nil),
		(*PerXdsConfig_ClusterConfig)(nil),
		(*PerXdsConfig_RouteConfig)(nil),
		(*PerXdsConfig_ScopedRouteConfig)(nil),
	}
}

// All xds configs for a particular client.
type ClientConfig struct {
	// Node for a particular client.
	Node                 *core.Node      `protobuf:"bytes,1,opt,name=node,proto3" json:"node,omitempty"`
	XdsConfig            []*PerXdsConfig `protobuf:"bytes,2,rep,name=xds_config,json=xdsConfig,proto3" json:"xds_config,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *ClientConfig) Reset()         { *m = ClientConfig{} }
func (m *ClientConfig) String() string { return proto.CompactTextString(m) }
func (*ClientConfig) ProtoMessage()    {}
func (*ClientConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_b8273221d61b8a20, []int{2}
}
func (m *ClientConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClientConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientConfig.Merge(m, src)
}
func (m *ClientConfig) XXX_Size() int {
	return m.Size()
}
func (m *ClientConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ClientConfig proto.InternalMessageInfo

func (m *ClientConfig) GetNode() *core.Node {
	if m != nil {
		return m.Node
	}
	return nil
}

func (m *ClientConfig) GetXdsConfig() []*PerXdsConfig {
	if m != nil {
		return m.XdsConfig
	}
	return nil
}

type ClientStatusResponse struct {
	// Client configs for the clients specified in the ClientStatusRequest.
	Config               []*ClientConfig `protobuf:"bytes,1,rep,name=config,proto3" json:"config,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *ClientStatusResponse) Reset()         { *m = ClientStatusResponse{} }
func (m *ClientStatusResponse) String() string { return proto.CompactTextString(m) }
func (*ClientStatusResponse) ProtoMessage()    {}
func (*ClientStatusResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b8273221d61b8a20, []int{3}
}
func (m *ClientStatusResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientStatusResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientStatusResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClientStatusResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientStatusResponse.Merge(m, src)
}
func (m *ClientStatusResponse) XXX_Size() int {
	return m.Size()
}
func (m *ClientStatusResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientStatusResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ClientStatusResponse proto.InternalMessageInfo

func (m *ClientStatusResponse) GetConfig() []*ClientConfig {
	if m != nil {
		return m.Config
	}
	return nil
}

func init() {
	proto.RegisterEnum("envoy.service.status.v2.ConfigStatus", ConfigStatus_name, ConfigStatus_value)
	proto.RegisterType((*ClientStatusRequest)(nil), "envoy.service.status.v2.ClientStatusRequest")
	proto.RegisterType((*PerXdsConfig)(nil), "envoy.service.status.v2.PerXdsConfig")
	proto.RegisterType((*ClientConfig)(nil), "envoy.service.status.v2.ClientConfig")
	proto.RegisterType((*ClientStatusResponse)(nil), "envoy.service.status.v2.ClientStatusResponse")
}

func init() {
	proto.RegisterFile("envoy/service/status/v2/csds.proto", fileDescriptor_b8273221d61b8a20)
}

var fileDescriptor_b8273221d61b8a20 = []byte{
	// 685 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x94, 0xc1, 0x6e, 0xd3, 0x4c,
	0x10, 0xc7, 0xb3, 0x49, 0x9b, 0xef, 0xeb, 0x24, 0x0d, 0xae, 0x8b, 0xd4, 0xa8, 0xb4, 0xa5, 0xb2,
	0x14, 0x11, 0xb5, 0xc5, 0x46, 0xe6, 0x56, 0x89, 0x03, 0x4d, 0x82, 0x10, 0x2d, 0x6e, 0x64, 0xb7,
	0x02, 0x84, 0x90, 0xe5, 0xda, 0xdb, 0xd6, 0x52, 0xe2, 0x35, 0xde, 0x75, 0x68, 0x6e, 0xc0, 0x89,
	0x3b, 0x77, 0xde, 0x81, 0x1b, 0xe2, 0x09, 0x7a, 0x04, 0xf1, 0x02, 0xa8, 0xe2, 0x41, 0x90, 0x77,
	0xd7, 0x4a, 0x82, 0x12, 0x95, 0x13, 0xb7, 0x75, 0xe6, 0xff, 0xff, 0xcd, 0xec, 0xcc, 0x64, 0x41,
	0xc3, 0xd1, 0x80, 0x0c, 0x0d, 0x8a, 0x93, 0x41, 0xe8, 0x63, 0x83, 0x32, 0x8f, 0xa5, 0xd4, 0x18,
	0x98, 0x86, 0x4f, 0x03, 0xaa, 0xc7, 0x09, 0x61, 0x44, 0x5d, 0xe1, 0x1a, 0x5d, 0x6a, 0x74, 0xa1,
	0xd1, 0x07, 0xe6, 0x6a, 0x43, 0x98, 0xbd, 0xa0, 0x1f, 0x46, 0xc6, 0xc0, 0xf4, 0x7a, 0xf1, 0xb9,
	0x67, 0xf8, 0x24, 0x3a, 0x0d, 0xcf, 0xdc, 0x20, 0xed, 0xc7, 0xc2, 0xbf, 0xba, 0x26, 0x65, 0x71,
	0xc8, 0xc1, 0x24, 0xc1, 0xc6, 0x89, 0x47, 0xb1, 0x8c, 0xae, 0x8b, 0x28, 0x1b, 0xc6, 0xd8, 0xe8,
	0x7b, 0xcc, 0x3f, 0xc7, 0x89, 0x11, 0x91, 0x20, 0x0f, 0xaf, 0x9d, 0x11, 0x72, 0xd6, 0xc3, 0xdc,
	0xed, 0x45, 0x11, 0x61, 0x1e, 0x0b, 0x49, 0x44, 0xff, 0x88, 0xf2, 0xaf, 0x93, 0xf4, 0xd4, 0xa0,
	0x2c, 0x49, 0x7d, 0x96, 0xa3, 0xd3, 0x20, 0xf6, 0xc6, 0x5d, 0xf2, 0x7e, 0x22, 0xac, 0xbd, 0x84,
	0xe5, 0x56, 0x2f, 0xc4, 0x11, 0x73, 0xf8, 0xaf, 0x36, 0x7e, 0x9d, 0x62, 0xca, 0xd4, 0x36, 0x2c,
	0x66, 0xf9, 0x5d, 0x59, 0x0c, 0xad, 0xa3, 0xcd, 0x52, 0xb3, 0x62, 0xde, 0xd6, 0x45, 0x1b, 0xb2,
	0x42, 0x75, 0x19, 0xd3, 0x2d, 0x12, 0xe0, 0xa7, 0xe2, 0x6c, 0x57, 0xa3, 0xd1, 0x07, 0xd5, 0x3e,
	0x97, 0xa0, 0xda, 0xc5, 0xc9, 0xf3, 0x80, 0xb6, 0x78, 0x43, 0xd4, 0x07, 0x50, 0x16, 0xd9, 0xeb,
	0x68, 0x13, 0x35, 0x6b, 0x66, 0x43, 0x9f, 0xd1, 0x56, 0x5d, 0x18, 0x64, 0x51, 0xd2, 0xa4, 0x3a,
	0x70, 0xa3, 0x17, 0x52, 0x86, 0x23, 0x9c, 0xb8, 0xa2, 0xc5, 0xf5, 0xe2, 0x26, 0x6a, 0x56, 0xcc,
	0xa6, 0xe4, 0xf0, 0x29, 0xe8, 0x72, 0x0a, 0xfa, 0x81, 0xd4, 0xca, 0xec, 0xed, 0xb4, 0x1f, 0x3f,
	0x2e, 0xd8, 0xb5, 0x1c, 0x21, 0x6b, 0xea, 0x42, 0xcd, 0xef, 0xa5, 0x94, 0x8d, 0x98, 0x25, 0xce,
	0xbc, 0x33, 0x95, 0xd9, 0x12, 0xd2, 0x49, 0xe4, 0xa2, 0x04, 0x48, 0xe2, 0x13, 0xa8, 0x26, 0x24,
	0x65, 0x38, 0xe7, 0xcd, 0x71, 0x5e, 0x63, 0x2a, 0xcf, 0xce, 0x84, 0x93, 0xb4, 0x0a, 0x37, 0x4b,
	0xd6, 0x2b, 0x58, 0xa6, 0x3e, 0x89, 0x71, 0xe0, 0x4e, 0x20, 0xe7, 0x39, 0x72, 0x7b, 0x2a, 0xd2,
	0xe1, 0xfa, 0x29, 0xe0, 0x25, 0x3a, 0x8a, 0x88, 0xc0, 0x9e, 0x02, 0xb5, 0x18, 0x27, 0xee, 0x45,
	0x40, 0x25, 0x59, 0x7b, 0x87, 0xa0, 0x2a, 0x36, 0x42, 0x56, 0xb0, 0x0d, 0x73, 0xd9, 0x50, 0xf9,
	0xc4, 0x2a, 0xe6, 0x4a, 0x9e, 0x32, 0x0e, 0xb3, 0x31, 0x65, 0x8b, 0xcc, 0x17, 0xc0, 0xe6, 0x22,
	0xb5, 0x0d, 0x30, 0x62, 0xd5, 0x8b, 0x7c, 0x69, 0x66, 0x0f, 0x79, 0x7c, 0x37, 0xec, 0x85, 0x8b,
	0xfc, 0xa8, 0x1d, 0xc3, 0xcd, 0xc9, 0xa5, 0xa4, 0x31, 0x89, 0x28, 0xce, 0xd6, 0x47, 0x92, 0xd1,
	0x35, 0xe4, 0xf1, 0x1b, 0xd8, 0xd2, 0xb4, 0xb5, 0x0f, 0xd5, 0xf1, 0xb5, 0x52, 0x2b, 0xf0, 0xdf,
	0xb1, 0xb5, 0x6f, 0x1d, 0x3e, 0xb3, 0x94, 0x82, 0x0a, 0x50, 0x76, 0x5e, 0x58, 0xad, 0x4e, 0x5b,
	0x41, 0x6a, 0x15, 0xfe, 0xb7, 0x0e, 0x8f, 0x5c, 0xa7, 0x63, 0x1d, 0x29, 0x45, 0x75, 0x01, 0xe6,
	0x9d, 0xa3, 0x87, 0x07, 0x1d, 0xa5, 0x94, 0x1d, 0x3b, 0xb6, 0x7d, 0x68, 0x2b, 0x73, 0xe6, 0x97,
	0x22, 0xac, 0x8d, 0x17, 0xd9, 0x0e, 0xa9, 0x4f, 0x06, 0x38, 0x19, 0x3a, 0xa2, 0x18, 0xf5, 0x0d,
	0xa8, 0x0e, 0x4b, 0xb0, 0xd7, 0x1f, 0x57, 0xa9, 0x3b, 0xd7, 0x94, 0x3c, 0xf1, 0x37, 0x5c, 0xbd,
	0xfb, 0x97, 0x6a, 0xd1, 0x1f, 0xad, 0xd0, 0x44, 0xf7, 0x90, 0xfa, 0x09, 0xc1, 0xd2, 0x23, 0xcc,
	0xfc, 0xf3, 0x7f, 0x97, 0x78, 0xe7, 0xfd, 0x8f, 0x5f, 0x1f, 0x8b, 0xeb, 0xda, 0xad, 0xec, 0x71,
	0x0b, 0xf2, 0x4e, 0xec, 0xfa, 0x5c, 0xeb, 0x0a, 0x33, 0x97, 0x94, 0x76, 0xd1, 0xd6, 0xde, 0xfe,
	0xe5, 0xd5, 0x06, 0xfa, 0x76, 0xb5, 0x81, 0x7e, 0x5e, 0x6d, 0xa0, 0xaf, 0x6f, 0x2f, 0xbf, 0x97,
	0x8b, 0x4a, 0x01, 0x1a, 0x21, 0x11, 0x49, 0xe3, 0x84, 0x5c, 0x0c, 0x67, 0xe5, 0xdf, 0x5b, 0x68,
	0xd1, 0x80, 0x76, 0xb3, 0xb7, 0xab, 0x8b, 0x3e, 0x20, 0x74, 0x52, 0xe6, 0xef, 0xd8, 0xfd, 0xdf,
	0x01, 0x00, 0x00, 0xff, 0xff, 0x13, 0x7c, 0xd2, 0x9a, 0xc5, 0x05, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ClientStatusDiscoveryServiceClient is the client API for ClientStatusDiscoveryService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ClientStatusDiscoveryServiceClient interface {
	StreamClientStatus(ctx context.Context, opts ...grpc.CallOption) (ClientStatusDiscoveryService_StreamClientStatusClient, error)
	FetchClientStatus(ctx context.Context, in *ClientStatusRequest, opts ...grpc.CallOption) (*ClientStatusResponse, error)
}

type clientStatusDiscoveryServiceClient struct {
	cc *grpc.ClientConn
}

func NewClientStatusDiscoveryServiceClient(cc *grpc.ClientConn) ClientStatusDiscoveryServiceClient {
	return &clientStatusDiscoveryServiceClient{cc}
}

func (c *clientStatusDiscoveryServiceClient) StreamClientStatus(ctx context.Context, opts ...grpc.CallOption) (ClientStatusDiscoveryService_StreamClientStatusClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ClientStatusDiscoveryService_serviceDesc.Streams[0], "/envoy.service.status.v2.ClientStatusDiscoveryService/StreamClientStatus", opts...)
	if err != nil {
		return nil, err
	}
	x := &clientStatusDiscoveryServiceStreamClientStatusClient{stream}
	return x, nil
}

type ClientStatusDiscoveryService_StreamClientStatusClient interface {
	Send(*ClientStatusRequest) error
	Recv() (*ClientStatusResponse, error)
	grpc.ClientStream
}

type clientStatusDiscoveryServiceStreamClientStatusClient struct {
	grpc.ClientStream
}

func (x *clientStatusDiscoveryServiceStreamClientStatusClient) Send(m *ClientStatusRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *clientStatusDiscoveryServiceStreamClientStatusClient) Recv() (*ClientStatusResponse, error) {
	m := new(ClientStatusResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *clientStatusDiscoveryServiceClient) FetchClientStatus(ctx context.Context, in *ClientStatusRequest, opts ...grpc.CallOption) (*ClientStatusResponse, error) {
	out := new(ClientStatusResponse)
	err := c.cc.Invoke(ctx, "/envoy.service.status.v2.ClientStatusDiscoveryService/FetchClientStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ClientStatusDiscoveryServiceServer is the server API for ClientStatusDiscoveryService service.
type ClientStatusDiscoveryServiceServer interface {
	StreamClientStatus(ClientStatusDiscoveryService_StreamClientStatusServer) error
	FetchClientStatus(context.Context, *ClientStatusRequest) (*ClientStatusResponse, error)
}

// UnimplementedClientStatusDiscoveryServiceServer can be embedded to have forward compatible implementations.
type UnimplementedClientStatusDiscoveryServiceServer struct {
}

func (*UnimplementedClientStatusDiscoveryServiceServer) StreamClientStatus(srv ClientStatusDiscoveryService_StreamClientStatusServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamClientStatus not implemented")
}
func (*UnimplementedClientStatusDiscoveryServiceServer) FetchClientStatus(ctx context.Context, req *ClientStatusRequest) (*ClientStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FetchClientStatus not implemented")
}

func RegisterClientStatusDiscoveryServiceServer(s *grpc.Server, srv ClientStatusDiscoveryServiceServer) {
	s.RegisterService(&_ClientStatusDiscoveryService_serviceDesc, srv)
}

func _ClientStatusDiscoveryService_StreamClientStatus_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ClientStatusDiscoveryServiceServer).StreamClientStatus(&clientStatusDiscoveryServiceStreamClientStatusServer{stream})
}

type ClientStatusDiscoveryService_StreamClientStatusServer interface {
	Send(*ClientStatusResponse) error
	Recv() (*ClientStatusRequest, error)
	grpc.ServerStream
}

type clientStatusDiscoveryServiceStreamClientStatusServer struct {
	grpc.ServerStream
}

func (x *clientStatusDiscoveryServiceStreamClientStatusServer) Send(m *ClientStatusResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *clientStatusDiscoveryServiceStreamClientStatusServer) Recv() (*ClientStatusRequest, error) {
	m := new(ClientStatusRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ClientStatusDiscoveryService_FetchClientStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClientStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClientStatusDiscoveryServiceServer).FetchClientStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/envoy.service.status.v2.ClientStatusDiscoveryService/FetchClientStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClientStatusDiscoveryServiceServer).FetchClientStatus(ctx, req.(*ClientStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ClientStatusDiscoveryService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "envoy.service.status.v2.ClientStatusDiscoveryService",
	HandlerType: (*ClientStatusDiscoveryServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "FetchClientStatus",
			Handler:    _ClientStatusDiscoveryService_FetchClientStatus_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamClientStatus",
			Handler:       _ClientStatusDiscoveryService_StreamClientStatus_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "envoy/service/status/v2/csds.proto",
}

func (m *ClientStatusRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientStatusRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientStatusRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.NodeMatchers) > 0 {
		for iNdEx := len(m.NodeMatchers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NodeMatchers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCsds(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PerXdsConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PerXdsConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PerXdsConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PerXdsConfig != nil {
		{
			size := m.PerXdsConfig.Size()
			i -= size
			if _, err := m.PerXdsConfig.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Status != 0 {
		i = encodeVarintCsds(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PerXdsConfig_ListenerConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PerXdsConfig_ListenerConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ListenerConfig != nil {
		{
			size, err := m.ListenerConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCsds(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *PerXdsConfig_ClusterConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PerXdsConfig_ClusterConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ClusterConfig != nil {
		{
			size, err := m.ClusterConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCsds(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *PerXdsConfig_RouteConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PerXdsConfig_RouteConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RouteConfig != nil {
		{
			size, err := m.RouteConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCsds(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *PerXdsConfig_ScopedRouteConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PerXdsConfig_ScopedRouteConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ScopedRouteConfig != nil {
		{
			size, err := m.ScopedRouteConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCsds(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *ClientConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.XdsConfig) > 0 {
		for iNdEx := len(m.XdsConfig) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.XdsConfig[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCsds(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Node != nil {
		{
			size, err := m.Node.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCsds(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClientStatusResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientStatusResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientStatusResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Config) > 0 {
		for iNdEx := len(m.Config) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Config[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCsds(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintCsds(dAtA []byte, offset int, v uint64) int {
	offset -= sovCsds(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ClientStatusRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.NodeMatchers) > 0 {
		for _, e := range m.NodeMatchers {
			l = e.Size()
			n += 1 + l + sovCsds(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PerXdsConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovCsds(uint64(m.Status))
	}
	if m.PerXdsConfig != nil {
		n += m.PerXdsConfig.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PerXdsConfig_ListenerConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ListenerConfig != nil {
		l = m.ListenerConfig.Size()
		n += 1 + l + sovCsds(uint64(l))
	}
	return n
}
func (m *PerXdsConfig_ClusterConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClusterConfig != nil {
		l = m.ClusterConfig.Size()
		n += 1 + l + sovCsds(uint64(l))
	}
	return n
}
func (m *PerXdsConfig_RouteConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RouteConfig != nil {
		l = m.RouteConfig.Size()
		n += 1 + l + sovCsds(uint64(l))
	}
	return n
}
func (m *PerXdsConfig_ScopedRouteConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ScopedRouteConfig != nil {
		l = m.ScopedRouteConfig.Size()
		n += 1 + l + sovCsds(uint64(l))
	}
	return n
}
func (m *ClientConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Node != nil {
		l = m.Node.Size()
		n += 1 + l + sovCsds(uint64(l))
	}
	if len(m.XdsConfig) > 0 {
		for _, e := range m.XdsConfig {
			l = e.Size()
			n += 1 + l + sovCsds(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClientStatusResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Config) > 0 {
		for _, e := range m.Config {
			l = e.Size()
			n += 1 + l + sovCsds(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovCsds(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCsds(x uint64) (n int) {
	return sovCsds(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ClientStatusRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientStatusRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientStatusRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeMatchers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsds
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCsds
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeMatchers = append(m.NodeMatchers, &matcher.NodeMatcher{})
			if err := m.NodeMatchers[len(m.NodeMatchers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCsds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsds
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCsds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PerXdsConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PerXdsConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PerXdsConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ConfigStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListenerConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsds
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCsds
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v2alpha.ListenersConfigDump{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PerXdsConfig = &PerXdsConfig_ListenerConfig{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsds
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCsds
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v2alpha.ClustersConfigDump{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PerXdsConfig = &PerXdsConfig_ClusterConfig{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsds
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCsds
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v2alpha.RoutesConfigDump{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PerXdsConfig = &PerXdsConfig_RouteConfig{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScopedRouteConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsds
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCsds
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v2alpha.ScopedRoutesConfigDump{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PerXdsConfig = &PerXdsConfig_ScopedRouteConfig{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCsds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsds
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCsds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsds
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCsds
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Node == nil {
				m.Node = &core.Node{}
			}
			if err := m.Node.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field XdsConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsds
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCsds
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.XdsConfig = append(m.XdsConfig, &PerXdsConfig{})
			if err := m.XdsConfig[len(m.XdsConfig)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCsds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsds
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCsds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientStatusResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientStatusResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientStatusResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsds
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCsds
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Config = append(m.Config, &ClientConfig{})
			if err := m.Config[len(m.Config)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCsds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsds
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCsds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCsds(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCsds
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCsds
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCsds
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCsds
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCsds
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCsds
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCsds        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCsds          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCsds = fmt.Errorf("proto: unexpected end of group")
)
