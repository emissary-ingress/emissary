// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: envoy/api/v3alpha/route/route.proto

package envoy_api_v3alpha_route

import (
	fmt "fmt"
	core "github.com/datawire/ambassador/pkg/api/envoy/api/v3alpha/core"
	v3alpha "github.com/datawire/ambassador/pkg/api/envoy/type/matcher/v3alpha"
	v3alpha1 "github.com/datawire/ambassador/pkg/api/envoy/type/v3alpha"
	_ "github.com/envoyproxy/protoc-gen-validate/validate"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type VirtualHost_TlsRequirementType int32

const (
	// No TLS requirement for the virtual host.
	VirtualHost_NONE VirtualHost_TlsRequirementType = 0
	// External requests must use TLS. If a request is external and it is not
	// using TLS, a 301 redirect will be sent telling the client to use HTTPS.
	VirtualHost_EXTERNAL_ONLY VirtualHost_TlsRequirementType = 1
	// All requests must use TLS. If a request is not using TLS, a 301 redirect
	// will be sent telling the client to use HTTPS.
	VirtualHost_ALL VirtualHost_TlsRequirementType = 2
)

var VirtualHost_TlsRequirementType_name = map[int32]string{
	0: "NONE",
	1: "EXTERNAL_ONLY",
	2: "ALL",
}

var VirtualHost_TlsRequirementType_value = map[string]int32{
	"NONE":          0,
	"EXTERNAL_ONLY": 1,
	"ALL":           2,
}

func (x VirtualHost_TlsRequirementType) String() string {
	return proto.EnumName(VirtualHost_TlsRequirementType_name, int32(x))
}

func (VirtualHost_TlsRequirementType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3f3197b7daaf8719, []int{0, 0}
}

type RouteAction_ClusterNotFoundResponseCode int32

const (
	// HTTP status code - 503 Service Unavailable.
	RouteAction_SERVICE_UNAVAILABLE RouteAction_ClusterNotFoundResponseCode = 0
	// HTTP status code - 404 Not Found.
	RouteAction_NOT_FOUND RouteAction_ClusterNotFoundResponseCode = 1
)

var RouteAction_ClusterNotFoundResponseCode_name = map[int32]string{
	0: "SERVICE_UNAVAILABLE",
	1: "NOT_FOUND",
}

var RouteAction_ClusterNotFoundResponseCode_value = map[string]int32{
	"SERVICE_UNAVAILABLE": 0,
	"NOT_FOUND":           1,
}

func (x RouteAction_ClusterNotFoundResponseCode) String() string {
	return proto.EnumName(RouteAction_ClusterNotFoundResponseCode_name, int32(x))
}

func (RouteAction_ClusterNotFoundResponseCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3f3197b7daaf8719, []int{5, 0}
}

// Configures :ref:`internal redirect <arch_overview_internal_redirects>` behavior.
type RouteAction_InternalRedirectAction int32

const (
	RouteAction_PASS_THROUGH_INTERNAL_REDIRECT RouteAction_InternalRedirectAction = 0
	RouteAction_HANDLE_INTERNAL_REDIRECT       RouteAction_InternalRedirectAction = 1
)

var RouteAction_InternalRedirectAction_name = map[int32]string{
	0: "PASS_THROUGH_INTERNAL_REDIRECT",
	1: "HANDLE_INTERNAL_REDIRECT",
}

var RouteAction_InternalRedirectAction_value = map[string]int32{
	"PASS_THROUGH_INTERNAL_REDIRECT": 0,
	"HANDLE_INTERNAL_REDIRECT":       1,
}

func (x RouteAction_InternalRedirectAction) String() string {
	return proto.EnumName(RouteAction_InternalRedirectAction_name, int32(x))
}

func (RouteAction_InternalRedirectAction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3f3197b7daaf8719, []int{5, 1}
}

type RedirectAction_RedirectResponseCode int32

const (
	// Moved Permanently HTTP Status Code - 301.
	RedirectAction_MOVED_PERMANENTLY RedirectAction_RedirectResponseCode = 0
	// Found HTTP Status Code - 302.
	RedirectAction_FOUND RedirectAction_RedirectResponseCode = 1
	// See Other HTTP Status Code - 303.
	RedirectAction_SEE_OTHER RedirectAction_RedirectResponseCode = 2
	// Temporary Redirect HTTP Status Code - 307.
	RedirectAction_TEMPORARY_REDIRECT RedirectAction_RedirectResponseCode = 3
	// Permanent Redirect HTTP Status Code - 308.
	RedirectAction_PERMANENT_REDIRECT RedirectAction_RedirectResponseCode = 4
)

var RedirectAction_RedirectResponseCode_name = map[int32]string{
	0: "MOVED_PERMANENTLY",
	1: "FOUND",
	2: "SEE_OTHER",
	3: "TEMPORARY_REDIRECT",
	4: "PERMANENT_REDIRECT",
}

var RedirectAction_RedirectResponseCode_value = map[string]int32{
	"MOVED_PERMANENTLY":  0,
	"FOUND":              1,
	"SEE_OTHER":          2,
	"TEMPORARY_REDIRECT": 3,
	"PERMANENT_REDIRECT": 4,
}

func (x RedirectAction_RedirectResponseCode) String() string {
	return proto.EnumName(RedirectAction_RedirectResponseCode_name, int32(x))
}

func (RedirectAction_RedirectResponseCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3f3197b7daaf8719, []int{8, 0}
}

// The top level element in the routing configuration is a virtual host. Each virtual host has
// a logical name as well as a set of domains that get routed to it based on the incoming request's
// host header. This allows a single listener to service multiple top level domain path trees. Once
// a virtual host is selected based on the domain, the routes are processed in order to see which
// upstream cluster to route to or whether to perform a redirect.
// [#next-free-field: 19]
type VirtualHost struct {
	// The logical name of the virtual host. This is used when emitting certain
	// statistics but is not relevant for routing.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// A list of domains (host/authority header) that will be matched to this
	// virtual host. Wildcard hosts are supported in the suffix or prefix form.
	//
	// Domain search order:
	//  1. Exact domain names: ``www.foo.com``.
	//  2. Suffix domain wildcards: ``*.foo.com`` or ``*-bar.foo.com``.
	//  3. Prefix domain wildcards: ``foo.*`` or ``foo-*``.
	//  4. Special wildcard ``*`` matching any domain.
	//
	// .. note::
	//
	//   The wildcard will not match the empty string.
	//   e.g. ``*-bar.foo.com`` will match ``baz-bar.foo.com`` but not ``-bar.foo.com``.
	//   The longest wildcards match first.
	//   Only a single virtual host in the entire route configuration can match on ``*``. A domain
	//   must be unique across all virtual hosts or the config will fail to load.
	Domains []string `protobuf:"bytes,2,rep,name=domains,proto3" json:"domains,omitempty"`
	// The list of routes that will be matched, in order, for incoming requests.
	// The first route that matches will be used.
	Routes []*Route `protobuf:"bytes,3,rep,name=routes,proto3" json:"routes,omitempty"`
	// Specifies the type of TLS enforcement the virtual host expects. If this option is not
	// specified, there is no TLS requirement for the virtual host.
	RequireTls VirtualHost_TlsRequirementType `protobuf:"varint,4,opt,name=require_tls,json=requireTls,proto3,enum=envoy.api.v3alpha.route.VirtualHost_TlsRequirementType" json:"require_tls,omitempty"`
	// A list of virtual clusters defined for this virtual host. Virtual clusters
	// are used for additional statistics gathering.
	VirtualClusters []*VirtualCluster `protobuf:"bytes,5,rep,name=virtual_clusters,json=virtualClusters,proto3" json:"virtual_clusters,omitempty"`
	// Specifies a set of rate limit configurations that will be applied to the
	// virtual host.
	RateLimits []*RateLimit `protobuf:"bytes,6,rep,name=rate_limits,json=rateLimits,proto3" json:"rate_limits,omitempty"`
	// Specifies a list of HTTP headers that should be added to each request
	// handled by this virtual host. Headers specified at this level are applied
	// after headers from enclosed :ref:`envoy_api_msg_route.Route` and before headers from the
	// enclosing :ref:`envoy_api_msg_RouteConfiguration`. For more information, including
	// details on header value syntax, see the documentation on :ref:`custom request headers
	// <config_http_conn_man_headers_custom_request_headers>`.
	RequestHeadersToAdd []*core.HeaderValueOption `protobuf:"bytes,7,rep,name=request_headers_to_add,json=requestHeadersToAdd,proto3" json:"request_headers_to_add,omitempty"`
	// Specifies a list of HTTP headers that should be removed from each request
	// handled by this virtual host.
	RequestHeadersToRemove []string `protobuf:"bytes,13,rep,name=request_headers_to_remove,json=requestHeadersToRemove,proto3" json:"request_headers_to_remove,omitempty"`
	// Specifies a list of HTTP headers that should be added to each response
	// handled by this virtual host. Headers specified at this level are applied
	// after headers from enclosed :ref:`envoy_api_msg_route.Route` and before headers from the
	// enclosing :ref:`envoy_api_msg_RouteConfiguration`. For more information, including
	// details on header value syntax, see the documentation on :ref:`custom request headers
	// <config_http_conn_man_headers_custom_request_headers>`.
	ResponseHeadersToAdd []*core.HeaderValueOption `protobuf:"bytes,10,rep,name=response_headers_to_add,json=responseHeadersToAdd,proto3" json:"response_headers_to_add,omitempty"`
	// Specifies a list of HTTP headers that should be removed from each response
	// handled by this virtual host.
	ResponseHeadersToRemove []string `protobuf:"bytes,11,rep,name=response_headers_to_remove,json=responseHeadersToRemove,proto3" json:"response_headers_to_remove,omitempty"`
	// Indicates that the virtual host has a CORS policy.
	Cors *CorsPolicy `protobuf:"bytes,8,opt,name=cors,proto3" json:"cors,omitempty"`
	// The per_filter_config field can be used to provide virtual host-specific
	// configurations for filters. The key should match the filter name, such as
	// *envoy.buffer* for the HTTP buffer filter. Use of this field is filter
	// specific; see the :ref:`HTTP filter documentation <config_http_filters>`
	// for if and how it is utilized.
	TypedPerFilterConfig map[string]*types.Any `protobuf:"bytes,15,rep,name=typed_per_filter_config,json=typedPerFilterConfig,proto3" json:"typed_per_filter_config,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Decides whether the :ref:`x-envoy-attempt-count
	// <config_http_filters_router_x-envoy-attempt-count>` header should be included
	// in the upstream request. Setting this option will cause it to override any existing header
	// value, so in the case of two Envoys on the request path with this option enabled, the upstream
	// will see the attempt count as perceived by the second Envoy. Defaults to false.
	// This header is unaffected by the
	// :ref:`suppress_envoy_headers
	// <envoy_api_field_config.filter.http.router.v3alpha.Router.suppress_envoy_headers>` flag.
	IncludeRequestAttemptCount bool `protobuf:"varint,14,opt,name=include_request_attempt_count,json=includeRequestAttemptCount,proto3" json:"include_request_attempt_count,omitempty"`
	// Indicates the retry policy for all routes in this virtual host. Note that setting a
	// route level entry will take precedence over this config and it'll be treated
	// independently (e.g.: values are not inherited).
	RetryPolicy *RetryPolicy `protobuf:"bytes,16,opt,name=retry_policy,json=retryPolicy,proto3" json:"retry_policy,omitempty"`
	// Indicates the hedge policy for all routes in this virtual host. Note that setting a
	// route level entry will take precedence over this config and it'll be treated
	// independently (e.g.: values are not inherited).
	HedgePolicy *HedgePolicy `protobuf:"bytes,17,opt,name=hedge_policy,json=hedgePolicy,proto3" json:"hedge_policy,omitempty"`
	// The maximum bytes which will be buffered for retries and shadowing.
	// If set and a route-specific limit is not set, the bytes actually buffered will be the minimum
	// value of this and the listener per_connection_buffer_limit_bytes.
	PerRequestBufferLimitBytes *types.UInt32Value `protobuf:"bytes,18,opt,name=per_request_buffer_limit_bytes,json=perRequestBufferLimitBytes,proto3" json:"per_request_buffer_limit_bytes,omitempty"`
	XXX_NoUnkeyedLiteral       struct{}           `json:"-"`
	XXX_unrecognized           []byte             `json:"-"`
	XXX_sizecache              int32              `json:"-"`
}

func (m *VirtualHost) Reset()         { *m = VirtualHost{} }
func (m *VirtualHost) String() string { return proto.CompactTextString(m) }
func (*VirtualHost) ProtoMessage()    {}
func (*VirtualHost) Descriptor() ([]byte, []int) {
	return fileDescriptor_3f3197b7daaf8719, []int{0}
}
func (m *VirtualHost) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VirtualHost) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VirtualHost.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VirtualHost) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VirtualHost.Merge(m, src)
}
func (m *VirtualHost) XXX_Size() int {
	return m.Size()
}
func (m *VirtualHost) XXX_DiscardUnknown() {
	xxx_messageInfo_VirtualHost.DiscardUnknown(m)
}

var xxx_messageInfo_VirtualHost proto.InternalMessageInfo

func (m *VirtualHost) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *VirtualHost) GetDomains() []string {
	if m != nil {
		return m.Domains
	}
	return nil
}

func (m *VirtualHost) GetRoutes() []*Route {
	if m != nil {
		return m.Routes
	}
	return nil
}

func (m *VirtualHost) GetRequireTls() VirtualHost_TlsRequirementType {
	if m != nil {
		return m.RequireTls
	}
	return VirtualHost_NONE
}

func (m *VirtualHost) GetVirtualClusters() []*VirtualCluster {
	if m != nil {
		return m.VirtualClusters
	}
	return nil
}

func (m *VirtualHost) GetRateLimits() []*RateLimit {
	if m != nil {
		return m.RateLimits
	}
	return nil
}

func (m *VirtualHost) GetRequestHeadersToAdd() []*core.HeaderValueOption {
	if m != nil {
		return m.RequestHeadersToAdd
	}
	return nil
}

func (m *VirtualHost) GetRequestHeadersToRemove() []string {
	if m != nil {
		return m.RequestHeadersToRemove
	}
	return nil
}

func (m *VirtualHost) GetResponseHeadersToAdd() []*core.HeaderValueOption {
	if m != nil {
		return m.ResponseHeadersToAdd
	}
	return nil
}

func (m *VirtualHost) GetResponseHeadersToRemove() []string {
	if m != nil {
		return m.ResponseHeadersToRemove
	}
	return nil
}

func (m *VirtualHost) GetCors() *CorsPolicy {
	if m != nil {
		return m.Cors
	}
	return nil
}

func (m *VirtualHost) GetTypedPerFilterConfig() map[string]*types.Any {
	if m != nil {
		return m.TypedPerFilterConfig
	}
	return nil
}

func (m *VirtualHost) GetIncludeRequestAttemptCount() bool {
	if m != nil {
		return m.IncludeRequestAttemptCount
	}
	return false
}

func (m *VirtualHost) GetRetryPolicy() *RetryPolicy {
	if m != nil {
		return m.RetryPolicy
	}
	return nil
}

func (m *VirtualHost) GetHedgePolicy() *HedgePolicy {
	if m != nil {
		return m.HedgePolicy
	}
	return nil
}

func (m *VirtualHost) GetPerRequestBufferLimitBytes() *types.UInt32Value {
	if m != nil {
		return m.PerRequestBufferLimitBytes
	}
	return nil
}

// A route is both a specification of how to match a request as well as an indication of what to do
// next (e.g., redirect, forward, rewrite, etc.).
//
// .. attention::
//
//   Envoy supports routing on HTTP method via :ref:`header matching
//   <envoy_api_msg_api.v3alpha.route.HeaderMatcher>`.
// [#next-free-field: 17]
type Route struct {
	// Name for the route.
	Name string `protobuf:"bytes,14,opt,name=name,proto3" json:"name,omitempty"`
	// Route matching parameters.
	Match *RouteMatch `protobuf:"bytes,1,opt,name=match,proto3" json:"match,omitempty"`
	// Types that are valid to be assigned to Action:
	//	*Route_Route
	//	*Route_Redirect
	//	*Route_DirectResponse
	Action isRoute_Action `protobuf_oneof:"action"`
	// The Metadata field can be used to provide additional information
	// about the route. It can be used for configuration, stats, and logging.
	// The metadata should go under the filter namespace that will need it.
	// For instance, if the metadata is intended for the Router filter,
	// the filter name should be specified as *envoy.router*.
	Metadata *core.Metadata `protobuf:"bytes,4,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// Decorator for the matched route.
	Decorator *Decorator `protobuf:"bytes,5,opt,name=decorator,proto3" json:"decorator,omitempty"`
	// The per_filter_config field can be used to provide route-specific
	// configurations for filters. The key should match the filter name, such as
	// *envoy.buffer* for the HTTP buffer filter. Use of this field is filter
	// specific; see the :ref:`HTTP filter documentation <config_http_filters>` for
	// if and how it is utilized.
	TypedPerFilterConfig map[string]*types.Any `protobuf:"bytes,13,rep,name=typed_per_filter_config,json=typedPerFilterConfig,proto3" json:"typed_per_filter_config,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Specifies a set of headers that will be added to requests matching this
	// route. Headers specified at this level are applied before headers from the
	// enclosing :ref:`envoy_api_msg_route.VirtualHost` and
	// :ref:`envoy_api_msg_RouteConfiguration`. For more information, including details on
	// header value syntax, see the documentation on :ref:`custom request headers
	// <config_http_conn_man_headers_custom_request_headers>`.
	RequestHeadersToAdd []*core.HeaderValueOption `protobuf:"bytes,9,rep,name=request_headers_to_add,json=requestHeadersToAdd,proto3" json:"request_headers_to_add,omitempty"`
	// Specifies a list of HTTP headers that should be removed from each request
	// matching this route.
	RequestHeadersToRemove []string `protobuf:"bytes,12,rep,name=request_headers_to_remove,json=requestHeadersToRemove,proto3" json:"request_headers_to_remove,omitempty"`
	// Specifies a set of headers that will be added to responses to requests
	// matching this route. Headers specified at this level are applied before
	// headers from the enclosing :ref:`envoy_api_msg_route.VirtualHost` and
	// :ref:`envoy_api_msg_RouteConfiguration`. For more information, including
	// details on header value syntax, see the documentation on
	// :ref:`custom request headers <config_http_conn_man_headers_custom_request_headers>`.
	ResponseHeadersToAdd []*core.HeaderValueOption `protobuf:"bytes,10,rep,name=response_headers_to_add,json=responseHeadersToAdd,proto3" json:"response_headers_to_add,omitempty"`
	// Specifies a list of HTTP headers that should be removed from each response
	// to requests matching this route.
	ResponseHeadersToRemove []string `protobuf:"bytes,11,rep,name=response_headers_to_remove,json=responseHeadersToRemove,proto3" json:"response_headers_to_remove,omitempty"`
	// Presence of the object defines whether the connection manager's tracing configuration
	// is overridden by this route specific instance.
	Tracing *Tracing `protobuf:"bytes,15,opt,name=tracing,proto3" json:"tracing,omitempty"`
	// The maximum bytes which will be buffered for retries and shadowing.
	// If set, the bytes actually buffered will be the minimum value of this and the
	// listener per_connection_buffer_limit_bytes.
	PerRequestBufferLimitBytes *types.UInt32Value `protobuf:"bytes,16,opt,name=per_request_buffer_limit_bytes,json=perRequestBufferLimitBytes,proto3" json:"per_request_buffer_limit_bytes,omitempty"`
	XXX_NoUnkeyedLiteral       struct{}           `json:"-"`
	XXX_unrecognized           []byte             `json:"-"`
	XXX_sizecache              int32              `json:"-"`
}

func (m *Route) Reset()         { *m = Route{} }
func (m *Route) String() string { return proto.CompactTextString(m) }
func (*Route) ProtoMessage()    {}
func (*Route) Descriptor() ([]byte, []int) {
	return fileDescriptor_3f3197b7daaf8719, []int{1}
}
func (m *Route) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Route) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Route.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Route) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Route.Merge(m, src)
}
func (m *Route) XXX_Size() int {
	return m.Size()
}
func (m *Route) XXX_DiscardUnknown() {
	xxx_messageInfo_Route.DiscardUnknown(m)
}

var xxx_messageInfo_Route proto.InternalMessageInfo

type isRoute_Action interface {
	isRoute_Action()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Route_Route struct {
	Route *RouteAction `protobuf:"bytes,2,opt,name=route,proto3,oneof"`
}
type Route_Redirect struct {
	Redirect *RedirectAction `protobuf:"bytes,3,opt,name=redirect,proto3,oneof"`
}
type Route_DirectResponse struct {
	DirectResponse *DirectResponseAction `protobuf:"bytes,7,opt,name=direct_response,json=directResponse,proto3,oneof"`
}

func (*Route_Route) isRoute_Action()          {}
func (*Route_Redirect) isRoute_Action()       {}
func (*Route_DirectResponse) isRoute_Action() {}

func (m *Route) GetAction() isRoute_Action {
	if m != nil {
		return m.Action
	}
	return nil
}

func (m *Route) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Route) GetMatch() *RouteMatch {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *Route) GetRoute() *RouteAction {
	if x, ok := m.GetAction().(*Route_Route); ok {
		return x.Route
	}
	return nil
}

func (m *Route) GetRedirect() *RedirectAction {
	if x, ok := m.GetAction().(*Route_Redirect); ok {
		return x.Redirect
	}
	return nil
}

func (m *Route) GetDirectResponse() *DirectResponseAction {
	if x, ok := m.GetAction().(*Route_DirectResponse); ok {
		return x.DirectResponse
	}
	return nil
}

func (m *Route) GetMetadata() *core.Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *Route) GetDecorator() *Decorator {
	if m != nil {
		return m.Decorator
	}
	return nil
}

func (m *Route) GetTypedPerFilterConfig() map[string]*types.Any {
	if m != nil {
		return m.TypedPerFilterConfig
	}
	return nil
}

func (m *Route) GetRequestHeadersToAdd() []*core.HeaderValueOption {
	if m != nil {
		return m.RequestHeadersToAdd
	}
	return nil
}

func (m *Route) GetRequestHeadersToRemove() []string {
	if m != nil {
		return m.RequestHeadersToRemove
	}
	return nil
}

func (m *Route) GetResponseHeadersToAdd() []*core.HeaderValueOption {
	if m != nil {
		return m.ResponseHeadersToAdd
	}
	return nil
}

func (m *Route) GetResponseHeadersToRemove() []string {
	if m != nil {
		return m.ResponseHeadersToRemove
	}
	return nil
}

func (m *Route) GetTracing() *Tracing {
	if m != nil {
		return m.Tracing
	}
	return nil
}

func (m *Route) GetPerRequestBufferLimitBytes() *types.UInt32Value {
	if m != nil {
		return m.PerRequestBufferLimitBytes
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Route) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Route_Route)(nil),
		(*Route_Redirect)(nil),
		(*Route_DirectResponse)(nil),
	}
}

// Compared to the :ref:`cluster <envoy_api_field_api.v3alpha.route.RouteAction.cluster>` field that
// specifies a single upstream cluster as the target of a request, the :ref:`weighted_clusters
// <envoy_api_field_api.v3alpha.route.RouteAction.weighted_clusters>` option allows for
// specification of multiple upstream clusters along with weights that indicate the percentage of
// traffic to be forwarded to each cluster. The router selects an upstream cluster based on the
// weights.
type WeightedCluster struct {
	// Specifies one or more upstream clusters associated with the route.
	Clusters []*WeightedCluster_ClusterWeight `protobuf:"bytes,1,rep,name=clusters,proto3" json:"clusters,omitempty"`
	// Specifies the total weight across all clusters. The sum of all cluster weights must equal this
	// value, which must be greater than 0. Defaults to 100.
	TotalWeight *types.UInt32Value `protobuf:"bytes,3,opt,name=total_weight,json=totalWeight,proto3" json:"total_weight,omitempty"`
	// Specifies the runtime key prefix that should be used to construct the
	// runtime keys associated with each cluster. When the *runtime_key_prefix* is
	// specified, the router will look for weights associated with each upstream
	// cluster under the key *runtime_key_prefix* + "." + *cluster[i].name* where
	// *cluster[i]* denotes an entry in the clusters array field. If the runtime
	// key for the cluster does not exist, the value specified in the
	// configuration file will be used as the default weight. See the :ref:`runtime documentation
	// <operations_runtime>` for how key names map to the underlying implementation.
	RuntimeKeyPrefix     string   `protobuf:"bytes,2,opt,name=runtime_key_prefix,json=runtimeKeyPrefix,proto3" json:"runtime_key_prefix,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WeightedCluster) Reset()         { *m = WeightedCluster{} }
func (m *WeightedCluster) String() string { return proto.CompactTextString(m) }
func (*WeightedCluster) ProtoMessage()    {}
func (*WeightedCluster) Descriptor() ([]byte, []int) {
	return fileDescriptor_3f3197b7daaf8719, []int{2}
}
func (m *WeightedCluster) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WeightedCluster) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WeightedCluster.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WeightedCluster) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WeightedCluster.Merge(m, src)
}
func (m *WeightedCluster) XXX_Size() int {
	return m.Size()
}
func (m *WeightedCluster) XXX_DiscardUnknown() {
	xxx_messageInfo_WeightedCluster.DiscardUnknown(m)
}

var xxx_messageInfo_WeightedCluster proto.InternalMessageInfo

func (m *WeightedCluster) GetClusters() []*WeightedCluster_ClusterWeight {
	if m != nil {
		return m.Clusters
	}
	return nil
}

func (m *WeightedCluster) GetTotalWeight() *types.UInt32Value {
	if m != nil {
		return m.TotalWeight
	}
	return nil
}

func (m *WeightedCluster) GetRuntimeKeyPrefix() string {
	if m != nil {
		return m.RuntimeKeyPrefix
	}
	return ""
}

// [#next-free-field: 11]
type WeightedCluster_ClusterWeight struct {
	// Name of the upstream cluster. The cluster must exist in the
	// :ref:`cluster manager configuration <config_cluster_manager>`.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// An integer between 0 and :ref:`total_weight
	// <envoy_api_field_api.v3alpha.route.WeightedCluster.total_weight>`. When a request matches the
	// route, the choice of an upstream cluster is determined by its weight. The sum of weights
	// across all entries in the clusters array must add up to the total_weight, which defaults to
	// 100.
	Weight *types.UInt32Value `protobuf:"bytes,2,opt,name=weight,proto3" json:"weight,omitempty"`
	// Optional endpoint metadata match criteria used by the subset load balancer. Only endpoints in
	// the upstream cluster with metadata matching what is set in this field will be considered for
	// load balancing. Note that this will be merged with what's provided in :ref:
	// `RouteAction.MetadataMatch <envoy_api_field_api.v3alpha.route.RouteAction.metadata_match>`,
	// with values here taking precedence. The filter name should be specified as *envoy.lb*.
	MetadataMatch *core.Metadata `protobuf:"bytes,3,opt,name=metadata_match,json=metadataMatch,proto3" json:"metadata_match,omitempty"`
	// Specifies a list of headers to be added to requests when this cluster is selected
	// through the enclosing :ref:`envoy_api_msg_route.RouteAction`.
	// Headers specified at this level are applied before headers from the enclosing
	// :ref:`envoy_api_msg_route.Route`, :ref:`envoy_api_msg_route.VirtualHost`, and
	// :ref:`envoy_api_msg_RouteConfiguration`. For more information, including details on
	// header value syntax, see the documentation on :ref:`custom request headers
	// <config_http_conn_man_headers_custom_request_headers>`.
	RequestHeadersToAdd []*core.HeaderValueOption `protobuf:"bytes,4,rep,name=request_headers_to_add,json=requestHeadersToAdd,proto3" json:"request_headers_to_add,omitempty"`
	// Specifies a list of HTTP headers that should be removed from each request when
	// this cluster is selected through the enclosing :ref:`envoy_api_msg_route.RouteAction`.
	RequestHeadersToRemove []string `protobuf:"bytes,9,rep,name=request_headers_to_remove,json=requestHeadersToRemove,proto3" json:"request_headers_to_remove,omitempty"`
	// Specifies a list of headers to be added to responses when this cluster is selected
	// through the enclosing :ref:`envoy_api_msg_route.RouteAction`.
	// Headers specified at this level are applied before headers from the enclosing
	// :ref:`envoy_api_msg_route.Route`, :ref:`envoy_api_msg_route.VirtualHost`, and
	// :ref:`envoy_api_msg_RouteConfiguration`. For more information, including details on
	// header value syntax, see the documentation on :ref:`custom request headers
	// <config_http_conn_man_headers_custom_request_headers>`.
	ResponseHeadersToAdd []*core.HeaderValueOption `protobuf:"bytes,5,rep,name=response_headers_to_add,json=responseHeadersToAdd,proto3" json:"response_headers_to_add,omitempty"`
	// Specifies a list of headers to be removed from responses when this cluster is selected
	// through the enclosing :ref:`envoy_api_msg_route.RouteAction`.
	ResponseHeadersToRemove []string `protobuf:"bytes,6,rep,name=response_headers_to_remove,json=responseHeadersToRemove,proto3" json:"response_headers_to_remove,omitempty"`
	// The per_filter_config field can be used to provide weighted cluster-specific
	// configurations for filters. The key should match the filter name, such as
	// *envoy.buffer* for the HTTP buffer filter. Use of this field is filter
	// specific; see the :ref:`HTTP filter documentation <config_http_filters>`
	// for if and how it is utilized.
	TypedPerFilterConfig map[string]*types.Any `protobuf:"bytes,10,rep,name=typed_per_filter_config,json=typedPerFilterConfig,proto3" json:"typed_per_filter_config,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *WeightedCluster_ClusterWeight) Reset()         { *m = WeightedCluster_ClusterWeight{} }
func (m *WeightedCluster_ClusterWeight) String() string { return proto.CompactTextString(m) }
func (*WeightedCluster_ClusterWeight) ProtoMessage()    {}
func (*WeightedCluster_ClusterWeight) Descriptor() ([]byte, []int) {
	return fileDescriptor_3f3197b7daaf8719, []int{2, 0}
}
func (m *WeightedCluster_ClusterWeight) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WeightedCluster_ClusterWeight) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WeightedCluster_ClusterWeight.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WeightedCluster_ClusterWeight) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WeightedCluster_ClusterWeight.Merge(m, src)
}
func (m *WeightedCluster_ClusterWeight) XXX_Size() int {
	return m.Size()
}
func (m *WeightedCluster_ClusterWeight) XXX_DiscardUnknown() {
	xxx_messageInfo_WeightedCluster_ClusterWeight.DiscardUnknown(m)
}

var xxx_messageInfo_WeightedCluster_ClusterWeight proto.InternalMessageInfo

func (m *WeightedCluster_ClusterWeight) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *WeightedCluster_ClusterWeight) GetWeight() *types.UInt32Value {
	if m != nil {
		return m.Weight
	}
	return nil
}

func (m *WeightedCluster_ClusterWeight) GetMetadataMatch() *core.Metadata {
	if m != nil {
		return m.MetadataMatch
	}
	return nil
}

func (m *WeightedCluster_ClusterWeight) GetRequestHeadersToAdd() []*core.HeaderValueOption {
	if m != nil {
		return m.RequestHeadersToAdd
	}
	return nil
}

func (m *WeightedCluster_ClusterWeight) GetRequestHeadersToRemove() []string {
	if m != nil {
		return m.RequestHeadersToRemove
	}
	return nil
}

func (m *WeightedCluster_ClusterWeight) GetResponseHeadersToAdd() []*core.HeaderValueOption {
	if m != nil {
		return m.ResponseHeadersToAdd
	}
	return nil
}

func (m *WeightedCluster_ClusterWeight) GetResponseHeadersToRemove() []string {
	if m != nil {
		return m.ResponseHeadersToRemove
	}
	return nil
}

func (m *WeightedCluster_ClusterWeight) GetTypedPerFilterConfig() map[string]*types.Any {
	if m != nil {
		return m.TypedPerFilterConfig
	}
	return nil
}

// [#next-free-field: 12]
type RouteMatch struct {
	// Types that are valid to be assigned to PathSpecifier:
	//	*RouteMatch_Prefix
	//	*RouteMatch_Path
	//	*RouteMatch_SafeRegex
	PathSpecifier isRouteMatch_PathSpecifier `protobuf_oneof:"path_specifier"`
	// Indicates that prefix/path matching should be case insensitive. The default
	// is true.
	CaseSensitive *types.BoolValue `protobuf:"bytes,4,opt,name=case_sensitive,json=caseSensitive,proto3" json:"case_sensitive,omitempty"`
	// Indicates that the route should additionally match on a runtime key. Every time the route
	// is considered for a match, it must also fall under the percentage of matches indicated by
	// this field. For some fraction N/D, a random number in the range [0,D) is selected. If the
	// number is <= the value of the numerator N, or if the key is not present, the default
	// value, the router continues to evaluate the remaining match criteria. A runtime_fraction
	// route configuration can be used to roll out route changes in a gradual manner without full
	// code/config deploys. Refer to the :ref:`traffic shifting
	// <config_http_conn_man_route_table_traffic_splitting_shift>` docs for additional documentation.
	//
	// .. note::
	//
	//    Parsing this field is implemented such that the runtime key's data may be represented
	//    as a FractionalPercent proto represented as JSON/YAML and may also be represented as an
	//    integer with the assumption that the value is an integral percentage out of 100. For
	//    instance, a runtime key lookup returning the value "42" would parse as a FractionalPercent
	//    whose numerator is 42 and denominator is HUNDRED. This preserves legacy semantics.
	RuntimeFraction *core.RuntimeFractionalPercent `protobuf:"bytes,9,opt,name=runtime_fraction,json=runtimeFraction,proto3" json:"runtime_fraction,omitempty"`
	// Specifies a set of headers that the route should match on. The router will
	// check the request’s headers against all the specified headers in the route
	// config. A match will happen if all the headers in the route are present in
	// the request with the same values (or based on presence if the value field
	// is not in the config).
	Headers []*HeaderMatcher `protobuf:"bytes,6,rep,name=headers,proto3" json:"headers,omitempty"`
	// Specifies a set of URL query parameters on which the route should
	// match. The router will check the query string from the *path* header
	// against all the specified query parameters. If the number of specified
	// query parameters is nonzero, they all must match the *path* header's
	// query string for a match to occur.
	QueryParameters []*QueryParameterMatcher `protobuf:"bytes,7,rep,name=query_parameters,json=queryParameters,proto3" json:"query_parameters,omitempty"`
	// If specified, only gRPC requests will be matched. The router will check
	// that the content-type header has a application/grpc or one of the various
	// application/grpc+ values.
	Grpc *RouteMatch_GrpcRouteMatchOptions `protobuf:"bytes,8,opt,name=grpc,proto3" json:"grpc,omitempty"`
	// If specified, the client tls context will be matched against the defined
	// match options.
	//
	// [#next-major-version: unify with RBAC]
	TlsContext           *RouteMatch_TlsContextMatchOptions `protobuf:"bytes,11,opt,name=tls_context,json=tlsContext,proto3" json:"tls_context,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                           `json:"-"`
	XXX_unrecognized     []byte                             `json:"-"`
	XXX_sizecache        int32                              `json:"-"`
}

func (m *RouteMatch) Reset()         { *m = RouteMatch{} }
func (m *RouteMatch) String() string { return proto.CompactTextString(m) }
func (*RouteMatch) ProtoMessage()    {}
func (*RouteMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_3f3197b7daaf8719, []int{3}
}
func (m *RouteMatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RouteMatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RouteMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteMatch.Merge(m, src)
}
func (m *RouteMatch) XXX_Size() int {
	return m.Size()
}
func (m *RouteMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteMatch.DiscardUnknown(m)
}

var xxx_messageInfo_RouteMatch proto.InternalMessageInfo

type isRouteMatch_PathSpecifier interface {
	isRouteMatch_PathSpecifier()
	MarshalTo([]byte) (int, error)
	Size() int
}

type RouteMatch_Prefix struct {
	Prefix string `protobuf:"bytes,1,opt,name=prefix,proto3,oneof"`
}
type RouteMatch_Path struct {
	Path string `protobuf:"bytes,2,opt,name=path,proto3,oneof"`
}
type RouteMatch_SafeRegex struct {
	SafeRegex *v3alpha.RegexMatcher `protobuf:"bytes,10,opt,name=safe_regex,json=safeRegex,proto3,oneof"`
}

func (*RouteMatch_Prefix) isRouteMatch_PathSpecifier()    {}
func (*RouteMatch_Path) isRouteMatch_PathSpecifier()      {}
func (*RouteMatch_SafeRegex) isRouteMatch_PathSpecifier() {}

func (m *RouteMatch) GetPathSpecifier() isRouteMatch_PathSpecifier {
	if m != nil {
		return m.PathSpecifier
	}
	return nil
}

func (m *RouteMatch) GetPrefix() string {
	if x, ok := m.GetPathSpecifier().(*RouteMatch_Prefix); ok {
		return x.Prefix
	}
	return ""
}

func (m *RouteMatch) GetPath() string {
	if x, ok := m.GetPathSpecifier().(*RouteMatch_Path); ok {
		return x.Path
	}
	return ""
}

func (m *RouteMatch) GetSafeRegex() *v3alpha.RegexMatcher {
	if x, ok := m.GetPathSpecifier().(*RouteMatch_SafeRegex); ok {
		return x.SafeRegex
	}
	return nil
}

func (m *RouteMatch) GetCaseSensitive() *types.BoolValue {
	if m != nil {
		return m.CaseSensitive
	}
	return nil
}

func (m *RouteMatch) GetRuntimeFraction() *core.RuntimeFractionalPercent {
	if m != nil {
		return m.RuntimeFraction
	}
	return nil
}

func (m *RouteMatch) GetHeaders() []*HeaderMatcher {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *RouteMatch) GetQueryParameters() []*QueryParameterMatcher {
	if m != nil {
		return m.QueryParameters
	}
	return nil
}

func (m *RouteMatch) GetGrpc() *RouteMatch_GrpcRouteMatchOptions {
	if m != nil {
		return m.Grpc
	}
	return nil
}

func (m *RouteMatch) GetTlsContext() *RouteMatch_TlsContextMatchOptions {
	if m != nil {
		return m.TlsContext
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*RouteMatch) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*RouteMatch_Prefix)(nil),
		(*RouteMatch_Path)(nil),
		(*RouteMatch_SafeRegex)(nil),
	}
}

type RouteMatch_GrpcRouteMatchOptions struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RouteMatch_GrpcRouteMatchOptions) Reset()         { *m = RouteMatch_GrpcRouteMatchOptions{} }
func (m *RouteMatch_GrpcRouteMatchOptions) String() string { return proto.CompactTextString(m) }
func (*RouteMatch_GrpcRouteMatchOptions) ProtoMessage()    {}
func (*RouteMatch_GrpcRouteMatchOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_3f3197b7daaf8719, []int{3, 0}
}
func (m *RouteMatch_GrpcRouteMatchOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteMatch_GrpcRouteMatchOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RouteMatch_GrpcRouteMatchOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RouteMatch_GrpcRouteMatchOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteMatch_GrpcRouteMatchOptions.Merge(m, src)
}
func (m *RouteMatch_GrpcRouteMatchOptions) XXX_Size() int {
	return m.Size()
}
func (m *RouteMatch_GrpcRouteMatchOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteMatch_GrpcRouteMatchOptions.DiscardUnknown(m)
}

var xxx_messageInfo_RouteMatch_GrpcRouteMatchOptions proto.InternalMessageInfo

type RouteMatch_TlsContextMatchOptions struct {
	// If specified, the route will match against whether or not a certificate is presented.
	Presented            *types.BoolValue `protobuf:"bytes,1,opt,name=presented,proto3" json:"presented,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *RouteMatch_TlsContextMatchOptions) Reset()         { *m = RouteMatch_TlsContextMatchOptions{} }
func (m *RouteMatch_TlsContextMatchOptions) String() string { return proto.CompactTextString(m) }
func (*RouteMatch_TlsContextMatchOptions) ProtoMessage()    {}
func (*RouteMatch_TlsContextMatchOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_3f3197b7daaf8719, []int{3, 1}
}
func (m *RouteMatch_TlsContextMatchOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteMatch_TlsContextMatchOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RouteMatch_TlsContextMatchOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RouteMatch_TlsContextMatchOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteMatch_TlsContextMatchOptions.Merge(m, src)
}
func (m *RouteMatch_TlsContextMatchOptions) XXX_Size() int {
	return m.Size()
}
func (m *RouteMatch_TlsContextMatchOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteMatch_TlsContextMatchOptions.DiscardUnknown(m)
}

var xxx_messageInfo_RouteMatch_TlsContextMatchOptions proto.InternalMessageInfo

func (m *RouteMatch_TlsContextMatchOptions) GetPresented() *types.BoolValue {
	if m != nil {
		return m.Presented
	}
	return nil
}

// [#next-free-field: 12]
type CorsPolicy struct {
	// Specifies string patterns that match allowed origins. An origin is allowed if any of the
	// string matchers match.
	AllowOriginStringMatch []*v3alpha.StringMatcher `protobuf:"bytes,11,rep,name=allow_origin_string_match,json=allowOriginStringMatch,proto3" json:"allow_origin_string_match,omitempty"`
	// Specifies the content for the *access-control-allow-methods* header.
	AllowMethods string `protobuf:"bytes,2,opt,name=allow_methods,json=allowMethods,proto3" json:"allow_methods,omitempty"`
	// Specifies the content for the *access-control-allow-headers* header.
	AllowHeaders string `protobuf:"bytes,3,opt,name=allow_headers,json=allowHeaders,proto3" json:"allow_headers,omitempty"`
	// Specifies the content for the *access-control-expose-headers* header.
	ExposeHeaders string `protobuf:"bytes,4,opt,name=expose_headers,json=exposeHeaders,proto3" json:"expose_headers,omitempty"`
	// Specifies the content for the *access-control-max-age* header.
	MaxAge string `protobuf:"bytes,5,opt,name=max_age,json=maxAge,proto3" json:"max_age,omitempty"`
	// Specifies whether the resource allows credentials.
	AllowCredentials *types.BoolValue `protobuf:"bytes,6,opt,name=allow_credentials,json=allowCredentials,proto3" json:"allow_credentials,omitempty"`
	// Types that are valid to be assigned to EnabledSpecifier:
	//	*CorsPolicy_FilterEnabled
	EnabledSpecifier isCorsPolicy_EnabledSpecifier `protobuf_oneof:"enabled_specifier"`
	// Specifies the % of requests for which the CORS policies will be evaluated and tracked, but not
	// enforced.
	//
	// This field is intended to be used when ``filter_enabled`` and ``enabled`` are off. One of those
	// fields have to explicitly disable the filter in order for this setting to take effect.
	//
	// If :ref:`runtime_key <envoy_api_field_core.runtimefractionalpercent.runtime_key>` is specified,
	// Envoy will lookup the runtime key to get the percentage of requests for which it will evaluate
	// and track the request's *Origin* to determine if it's valid but will not enforce any policies.
	ShadowEnabled        *core.RuntimeFractionalPercent `protobuf:"bytes,10,opt,name=shadow_enabled,json=shadowEnabled,proto3" json:"shadow_enabled,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                       `json:"-"`
	XXX_unrecognized     []byte                         `json:"-"`
	XXX_sizecache        int32                          `json:"-"`
}

func (m *CorsPolicy) Reset()         { *m = CorsPolicy{} }
func (m *CorsPolicy) String() string { return proto.CompactTextString(m) }
func (*CorsPolicy) ProtoMessage()    {}
func (*CorsPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_3f3197b7daaf8719, []int{4}
}
func (m *CorsPolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CorsPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CorsPolicy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CorsPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CorsPolicy.Merge(m, src)
}
func (m *CorsPolicy) XXX_Size() int {
	return m.Size()
}
func (m *CorsPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_CorsPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_CorsPolicy proto.InternalMessageInfo

type isCorsPolicy_EnabledSpecifier interface {
	isCorsPolicy_EnabledSpecifier()
	MarshalTo([]byte) (int, error)
	Size() int
}

type CorsPolicy_FilterEnabled struct {
	FilterEnabled *core.RuntimeFractionalPercent `protobuf:"bytes,9,opt,name=filter_enabled,json=filterEnabled,proto3,oneof"`
}

func (*CorsPolicy_FilterEnabled) isCorsPolicy_EnabledSpecifier() {}

func (m *CorsPolicy) GetEnabledSpecifier() isCorsPolicy_EnabledSpecifier {
	if m != nil {
		return m.EnabledSpecifier
	}
	return nil
}

func (m *CorsPolicy) GetAllowOriginStringMatch() []*v3alpha.StringMatcher {
	if m != nil {
		return m.AllowOriginStringMatch
	}
	return nil
}

func (m *CorsPolicy) GetAllowMethods() string {
	if m != nil {
		return m.AllowMethods
	}
	return ""
}

func (m *CorsPolicy) GetAllowHeaders() string {
	if m != nil {
		return m.AllowHeaders
	}
	return ""
}

func (m *CorsPolicy) GetExposeHeaders() string {
	if m != nil {
		return m.ExposeHeaders
	}
	return ""
}

func (m *CorsPolicy) GetMaxAge() string {
	if m != nil {
		return m.MaxAge
	}
	return ""
}

func (m *CorsPolicy) GetAllowCredentials() *types.BoolValue {
	if m != nil {
		return m.AllowCredentials
	}
	return nil
}

func (m *CorsPolicy) GetFilterEnabled() *core.RuntimeFractionalPercent {
	if x, ok := m.GetEnabledSpecifier().(*CorsPolicy_FilterEnabled); ok {
		return x.FilterEnabled
	}
	return nil
}

func (m *CorsPolicy) GetShadowEnabled() *core.RuntimeFractionalPercent {
	if m != nil {
		return m.ShadowEnabled
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CorsPolicy) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CorsPolicy_FilterEnabled)(nil),
	}
}

// [#next-free-field: 30]
type RouteAction struct {
	// Types that are valid to be assigned to ClusterSpecifier:
	//	*RouteAction_Cluster
	//	*RouteAction_ClusterHeader
	//	*RouteAction_WeightedClusters
	ClusterSpecifier isRouteAction_ClusterSpecifier `protobuf_oneof:"cluster_specifier"`
	// The HTTP status code to use when configured cluster is not found.
	// The default response code is 503 Service Unavailable.
	ClusterNotFoundResponseCode RouteAction_ClusterNotFoundResponseCode `protobuf:"varint,20,opt,name=cluster_not_found_response_code,json=clusterNotFoundResponseCode,proto3,enum=envoy.api.v3alpha.route.RouteAction_ClusterNotFoundResponseCode" json:"cluster_not_found_response_code,omitempty"`
	// Optional endpoint metadata match criteria used by the subset load balancer. Only endpoints
	// in the upstream cluster with metadata matching what's set in this field will be considered
	// for load balancing. If using :ref:`weighted_clusters
	// <envoy_api_field_api.v3alpha.route.RouteAction.weighted_clusters>`, metadata will be merged,
	// with values provided there taking precedence. The filter name should be specified as
	// *envoy.lb*.
	MetadataMatch *core.Metadata `protobuf:"bytes,4,opt,name=metadata_match,json=metadataMatch,proto3" json:"metadata_match,omitempty"`
	// Indicates that during forwarding, the matched prefix (or path) should be
	// swapped with this value. This option allows application URLs to be rooted
	// at a different path from those exposed at the reverse proxy layer. The router filter will
	// place the original path before rewrite into the :ref:`x-envoy-original-path
	// <config_http_filters_router_x-envoy-original-path>` header.
	//
	// .. attention::
	//
	//   Pay careful attention to the use of trailing slashes in the
	//   :ref:`route's match <envoy_api_field_api.v3alpha.route.Route.match>` prefix value.
	//   Stripping a prefix from a path requires multiple Routes to handle all cases. For example,
	//   rewriting */prefix* to */* and */prefix/etc* to */etc* cannot be done in a single
	//   :ref:`Route <envoy_api_msg_api.v3alpha.route.Route>`, as shown by the below config entries:
	//
	//   .. code-block:: yaml
	//
	//     - match:
	//         prefix: "/prefix/"
	//       route:
	//         prefix_rewrite: "/"
	//     - match:
	//         prefix: "/prefix"
	//       route:
	//         prefix_rewrite: "/"
	//
	//   Having above entries in the config, requests to */prefix* will be stripped to */*, while
	//   requests to */prefix/etc* will be stripped to */etc*.
	PrefixRewrite string `protobuf:"bytes,5,opt,name=prefix_rewrite,json=prefixRewrite,proto3" json:"prefix_rewrite,omitempty"`
	// Types that are valid to be assigned to HostRewriteSpecifier:
	//	*RouteAction_HostRewrite
	//	*RouteAction_AutoHostRewrite
	//	*RouteAction_AutoHostRewriteHeader
	HostRewriteSpecifier isRouteAction_HostRewriteSpecifier `protobuf_oneof:"host_rewrite_specifier"`
	// Specifies the upstream timeout for the route. If not specified, the default is 15s. This
	// spans between the point at which the entire downstream request (i.e. end-of-stream) has been
	// processed and when the upstream response has been completely processed. A value of 0 will
	// disable the route's timeout.
	//
	// .. note::
	//
	//   This timeout includes all retries. See also
	//   :ref:`config_http_filters_router_x-envoy-upstream-rq-timeout-ms`,
	//   :ref:`config_http_filters_router_x-envoy-upstream-rq-per-try-timeout-ms`, and the
	//   :ref:`retry overview <arch_overview_http_routing_retry>`.
	Timeout *types.Duration `protobuf:"bytes,8,opt,name=timeout,proto3" json:"timeout,omitempty"`
	// Specifies the idle timeout for the route. If not specified, there is no per-route idle timeout,
	// although the connection manager wide :ref:`stream_idle_timeout
	// <envoy_api_field_config.filter.network.http_connection_manager.v3alpha.HttpConnectionManager.stream_idle_timeout>`
	// will still apply. A value of 0 will completely disable the route's idle timeout, even if a
	// connection manager stream idle timeout is configured.
	//
	// The idle timeout is distinct to :ref:`timeout
	// <envoy_api_field_api.v3alpha.route.RouteAction.timeout>`, which provides an upper bound
	// on the upstream response time; :ref:`idle_timeout
	// <envoy_api_field_api.v3alpha.route.RouteAction.idle_timeout>` instead bounds the amount
	// of time the request's stream may be idle.
	//
	// After header decoding, the idle timeout will apply on downstream and
	// upstream request events. Each time an encode/decode event for headers or
	// data is processed for the stream, the timer will be reset. If the timeout
	// fires, the stream is terminated with a 408 Request Timeout error code if no
	// upstream response header has been received, otherwise a stream reset
	// occurs.
	IdleTimeout *types.Duration `protobuf:"bytes,24,opt,name=idle_timeout,json=idleTimeout,proto3" json:"idle_timeout,omitempty"`
	// Indicates that the route has a retry policy. Note that if this is set,
	// it'll take precedence over the virtual host level retry policy entirely
	// (e.g.: policies are not merged, most internal one becomes the enforced policy).
	RetryPolicy *RetryPolicy `protobuf:"bytes,9,opt,name=retry_policy,json=retryPolicy,proto3" json:"retry_policy,omitempty"`
	// Indicates that the route has a request mirroring policy.
	RequestMirrorPolicy *RouteAction_RequestMirrorPolicy `protobuf:"bytes,10,opt,name=request_mirror_policy,json=requestMirrorPolicy,proto3" json:"request_mirror_policy,omitempty"`
	// Optionally specifies the :ref:`routing priority <arch_overview_http_routing_priority>`.
	Priority core.RoutingPriority `protobuf:"varint,11,opt,name=priority,proto3,enum=envoy.api.v3alpha.core.RoutingPriority" json:"priority,omitempty"`
	// Specifies a set of rate limit configurations that could be applied to the
	// route.
	RateLimits []*RateLimit `protobuf:"bytes,13,rep,name=rate_limits,json=rateLimits,proto3" json:"rate_limits,omitempty"`
	// Specifies if the rate limit filter should include the virtual host rate
	// limits. By default, if the route configured rate limits, the virtual host
	// :ref:`rate_limits <envoy_api_field_api.v3alpha.route.VirtualHost.rate_limits>` are not applied
	// to the request.
	IncludeVhRateLimits *types.BoolValue `protobuf:"bytes,14,opt,name=include_vh_rate_limits,json=includeVhRateLimits,proto3" json:"include_vh_rate_limits,omitempty"`
	// Specifies a list of hash policies to use for ring hash load balancing. Each
	// hash policy is evaluated individually and the combined result is used to
	// route the request. The method of combination is deterministic such that
	// identical lists of hash policies will produce the same hash. Since a hash
	// policy examines specific parts of a request, it can fail to produce a hash
	// (i.e. if the hashed header is not present). If (and only if) all configured
	// hash policies fail to generate a hash, no hash will be produced for
	// the route. In this case, the behavior is the same as if no hash policies
	// were specified (i.e. the ring hash load balancer will choose a random
	// backend). If a hash policy has the "terminal" attribute set to true, and
	// there is already a hash generated, the hash is returned immediately,
	// ignoring the rest of the hash policy list.
	HashPolicy []*RouteAction_HashPolicy `protobuf:"bytes,15,rep,name=hash_policy,json=hashPolicy,proto3" json:"hash_policy,omitempty"`
	// Indicates that the route has a CORS policy.
	Cors *CorsPolicy `protobuf:"bytes,17,opt,name=cors,proto3" json:"cors,omitempty"`
	// If present, and the request is a gRPC request, use the
	// `grpc-timeout header <https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md>`_,
	// or its default value (infinity) instead of
	// :ref:`timeout <envoy_api_field_api.v3alpha.route.RouteAction.timeout>`, but limit the applied
	// timeout to the maximum value specified here. If configured as 0, the maximum allowed timeout
	// for gRPC requests is infinity. If not configured at all, the `grpc-timeout` header is not used
	// and gRPC requests time out like any other requests using
	// :ref:`timeout <envoy_api_field_api.v3alpha.route.RouteAction.timeout>` or its default.
	// This can be used to prevent unexpected upstream request timeouts due to potentially long
	// time gaps between gRPC request and response in gRPC streaming mode.
	MaxGrpcTimeout *types.Duration `protobuf:"bytes,23,opt,name=max_grpc_timeout,json=maxGrpcTimeout,proto3" json:"max_grpc_timeout,omitempty"`
	// If present, Envoy will adjust the timeout provided by the `grpc-timeout` header by subtracting
	// the provided duration from the header. This is useful in allowing Envoy to set its global
	// timeout to be less than that of the deadline imposed by the calling client, which makes it more
	// likely that Envoy will handle the timeout instead of having the call canceled by the client.
	// The offset will only be applied if the provided grpc_timeout is greater than the offset. This
	// ensures that the offset will only ever decrease the timeout and never set it to 0 (meaning
	// infinity).
	GrpcTimeoutOffset      *types.Duration                    `protobuf:"bytes,28,opt,name=grpc_timeout_offset,json=grpcTimeoutOffset,proto3" json:"grpc_timeout_offset,omitempty"`
	UpgradeConfigs         []*RouteAction_UpgradeConfig       `protobuf:"bytes,25,rep,name=upgrade_configs,json=upgradeConfigs,proto3" json:"upgrade_configs,omitempty"`
	InternalRedirectAction RouteAction_InternalRedirectAction `protobuf:"varint,26,opt,name=internal_redirect_action,json=internalRedirectAction,proto3,enum=envoy.api.v3alpha.route.RouteAction_InternalRedirectAction" json:"internal_redirect_action,omitempty"`
	// Indicates that the route has a hedge policy. Note that if this is set,
	// it'll take precedence over the virtual host level hedge policy entirely
	// (e.g.: policies are not merged, most internal one becomes the enforced policy).
	HedgePolicy          *HedgePolicy `protobuf:"bytes,27,opt,name=hedge_policy,json=hedgePolicy,proto3" json:"hedge_policy,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *RouteAction) Reset()         { *m = RouteAction{} }
func (m *RouteAction) String() string { return proto.CompactTextString(m) }
func (*RouteAction) ProtoMessage()    {}
func (*RouteAction) Descriptor() ([]byte, []int) {
	return fileDescriptor_3f3197b7daaf8719, []int{5}
}
func (m *RouteAction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteAction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RouteAction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RouteAction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteAction.Merge(m, src)
}
func (m *RouteAction) XXX_Size() int {
	return m.Size()
}
func (m *RouteAction) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteAction.DiscardUnknown(m)
}

var xxx_messageInfo_RouteAction proto.InternalMessageInfo

type isRouteAction_ClusterSpecifier interface {
	isRouteAction_ClusterSpecifier()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isRouteAction_HostRewriteSpecifier interface {
	isRouteAction_HostRewriteSpecifier()
	MarshalTo([]byte) (int, error)
	Size() int
}

type RouteAction_Cluster struct {
	Cluster string `protobuf:"bytes,1,opt,name=cluster,proto3,oneof"`
}
type RouteAction_ClusterHeader struct {
	ClusterHeader string `protobuf:"bytes,2,opt,name=cluster_header,json=clusterHeader,proto3,oneof"`
}
type RouteAction_WeightedClusters struct {
	WeightedClusters *WeightedCluster `protobuf:"bytes,3,opt,name=weighted_clusters,json=weightedClusters,proto3,oneof"`
}
type RouteAction_HostRewrite struct {
	HostRewrite string `protobuf:"bytes,6,opt,name=host_rewrite,json=hostRewrite,proto3,oneof"`
}
type RouteAction_AutoHostRewrite struct {
	AutoHostRewrite *types.BoolValue `protobuf:"bytes,7,opt,name=auto_host_rewrite,json=autoHostRewrite,proto3,oneof"`
}
type RouteAction_AutoHostRewriteHeader struct {
	AutoHostRewriteHeader string `protobuf:"bytes,29,opt,name=auto_host_rewrite_header,json=autoHostRewriteHeader,proto3,oneof"`
}

func (*RouteAction_Cluster) isRouteAction_ClusterSpecifier()                   {}
func (*RouteAction_ClusterHeader) isRouteAction_ClusterSpecifier()             {}
func (*RouteAction_WeightedClusters) isRouteAction_ClusterSpecifier()          {}
func (*RouteAction_HostRewrite) isRouteAction_HostRewriteSpecifier()           {}
func (*RouteAction_AutoHostRewrite) isRouteAction_HostRewriteSpecifier()       {}
func (*RouteAction_AutoHostRewriteHeader) isRouteAction_HostRewriteSpecifier() {}

func (m *RouteAction) GetClusterSpecifier() isRouteAction_ClusterSpecifier {
	if m != nil {
		return m.ClusterSpecifier
	}
	return nil
}
func (m *RouteAction) GetHostRewriteSpecifier() isRouteAction_HostRewriteSpecifier {
	if m != nil {
		return m.HostRewriteSpecifier
	}
	return nil
}

func (m *RouteAction) GetCluster() string {
	if x, ok := m.GetClusterSpecifier().(*RouteAction_Cluster); ok {
		return x.Cluster
	}
	return ""
}

func (m *RouteAction) GetClusterHeader() string {
	if x, ok := m.GetClusterSpecifier().(*RouteAction_ClusterHeader); ok {
		return x.ClusterHeader
	}
	return ""
}

func (m *RouteAction) GetWeightedClusters() *WeightedCluster {
	if x, ok := m.GetClusterSpecifier().(*RouteAction_WeightedClusters); ok {
		return x.WeightedClusters
	}
	return nil
}

func (m *RouteAction) GetClusterNotFoundResponseCode() RouteAction_ClusterNotFoundResponseCode {
	if m != nil {
		return m.ClusterNotFoundResponseCode
	}
	return RouteAction_SERVICE_UNAVAILABLE
}

func (m *RouteAction) GetMetadataMatch() *core.Metadata {
	if m != nil {
		return m.MetadataMatch
	}
	return nil
}

func (m *RouteAction) GetPrefixRewrite() string {
	if m != nil {
		return m.PrefixRewrite
	}
	return ""
}

func (m *RouteAction) GetHostRewrite() string {
	if x, ok := m.GetHostRewriteSpecifier().(*RouteAction_HostRewrite); ok {
		return x.HostRewrite
	}
	return ""
}

func (m *RouteAction) GetAutoHostRewrite() *types.BoolValue {
	if x, ok := m.GetHostRewriteSpecifier().(*RouteAction_AutoHostRewrite); ok {
		return x.AutoHostRewrite
	}
	return nil
}

func (m *RouteAction) GetAutoHostRewriteHeader() string {
	if x, ok := m.GetHostRewriteSpecifier().(*RouteAction_AutoHostRewriteHeader); ok {
		return x.AutoHostRewriteHeader
	}
	return ""
}

func (m *RouteAction) GetTimeout() *types.Duration {
	if m != nil {
		return m.Timeout
	}
	return nil
}

func (m *RouteAction) GetIdleTimeout() *types.Duration {
	if m != nil {
		return m.IdleTimeout
	}
	return nil
}

func (m *RouteAction) GetRetryPolicy() *RetryPolicy {
	if m != nil {
		return m.RetryPolicy
	}
	return nil
}

func (m *RouteAction) GetRequestMirrorPolicy() *RouteAction_RequestMirrorPolicy {
	if m != nil {
		return m.RequestMirrorPolicy
	}
	return nil
}

func (m *RouteAction) GetPriority() core.RoutingPriority {
	if m != nil {
		return m.Priority
	}
	return core.RoutingPriority_DEFAULT
}

func (m *RouteAction) GetRateLimits() []*RateLimit {
	if m != nil {
		return m.RateLimits
	}
	return nil
}

func (m *RouteAction) GetIncludeVhRateLimits() *types.BoolValue {
	if m != nil {
		return m.IncludeVhRateLimits
	}
	return nil
}

func (m *RouteAction) GetHashPolicy() []*RouteAction_HashPolicy {
	if m != nil {
		return m.HashPolicy
	}
	return nil
}

func (m *RouteAction) GetCors() *CorsPolicy {
	if m != nil {
		return m.Cors
	}
	return nil
}

func (m *RouteAction) GetMaxGrpcTimeout() *types.Duration {
	if m != nil {
		return m.MaxGrpcTimeout
	}
	return nil
}

func (m *RouteAction) GetGrpcTimeoutOffset() *types.Duration {
	if m != nil {
		return m.GrpcTimeoutOffset
	}
	return nil
}

func (m *RouteAction) GetUpgradeConfigs() []*RouteAction_UpgradeConfig {
	if m != nil {
		return m.UpgradeConfigs
	}
	return nil
}

func (m *RouteAction) GetInternalRedirectAction() RouteAction_InternalRedirectAction {
	if m != nil {
		return m.InternalRedirectAction
	}
	return RouteAction_PASS_THROUGH_INTERNAL_REDIRECT
}

func (m *RouteAction) GetHedgePolicy() *HedgePolicy {
	if m != nil {
		return m.HedgePolicy
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*RouteAction) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*RouteAction_Cluster)(nil),
		(*RouteAction_ClusterHeader)(nil),
		(*RouteAction_WeightedClusters)(nil),
		(*RouteAction_HostRewrite)(nil),
		(*RouteAction_AutoHostRewrite)(nil),
		(*RouteAction_AutoHostRewriteHeader)(nil),
	}
}

// The router is capable of shadowing traffic from one cluster to another. The current
// implementation is "fire and forget," meaning Envoy will not wait for the shadow cluster to
// respond before returning the response from the primary cluster. All normal statistics are
// collected for the shadow cluster making this feature useful for testing.
//
// During shadowing, the host/authority header is altered such that *-shadow* is appended. This is
// useful for logging. For example, *cluster1* becomes *cluster1-shadow*.
type RouteAction_RequestMirrorPolicy struct {
	// Specifies the cluster that requests will be mirrored to. The cluster must
	// exist in the cluster manager configuration.
	Cluster string `protobuf:"bytes,1,opt,name=cluster,proto3" json:"cluster,omitempty"`
	// If both :ref:`runtime_key
	// <envoy_api_field_api.v3alpha.route.RouteAction.RequestMirrorPolicy.runtime_key>` and this
	// field are not specified, all requests to the target cluster will be mirrored.
	//
	// If specified, this field takes precedence over the `runtime_key` field and requests must also
	// fall under the percentage of matches indicated by this field.
	//
	// For some fraction N/D, a random number in the range [0,D) is selected. If the
	// number is <= the value of the numerator N, or if the key is not present, the default
	// value, the request will be mirrored.
	RuntimeFraction      *core.RuntimeFractionalPercent `protobuf:"bytes,3,opt,name=runtime_fraction,json=runtimeFraction,proto3" json:"runtime_fraction,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                       `json:"-"`
	XXX_unrecognized     []byte                         `json:"-"`
	XXX_sizecache        int32                          `json:"-"`
}

func (m *RouteAction_RequestMirrorPolicy) Reset()         { *m = RouteAction_RequestMirrorPolicy{} }
func (m *RouteAction_RequestMirrorPolicy) String() string { return proto.CompactTextString(m) }
func (*RouteAction_RequestMirrorPolicy) ProtoMessage()    {}
func (*RouteAction_RequestMirrorPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_3f3197b7daaf8719, []int{5, 0}
}
func (m *RouteAction_RequestMirrorPolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteAction_RequestMirrorPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RouteAction_RequestMirrorPolicy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RouteAction_RequestMirrorPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteAction_RequestMirrorPolicy.Merge(m, src)
}
func (m *RouteAction_RequestMirrorPolicy) XXX_Size() int {
	return m.Size()
}
func (m *RouteAction_RequestMirrorPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteAction_RequestMirrorPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_RouteAction_RequestMirrorPolicy proto.InternalMessageInfo

func (m *RouteAction_RequestMirrorPolicy) GetCluster() string {
	if m != nil {
		return m.Cluster
	}
	return ""
}

func (m *RouteAction_RequestMirrorPolicy) GetRuntimeFraction() *core.RuntimeFractionalPercent {
	if m != nil {
		return m.RuntimeFraction
	}
	return nil
}

// Specifies the route's hashing policy if the upstream cluster uses a hashing :ref:`load balancer
// <arch_overview_load_balancing_types>`.
type RouteAction_HashPolicy struct {
	// Types that are valid to be assigned to PolicySpecifier:
	//	*RouteAction_HashPolicy_Header_
	//	*RouteAction_HashPolicy_Cookie_
	//	*RouteAction_HashPolicy_ConnectionProperties_
	PolicySpecifier isRouteAction_HashPolicy_PolicySpecifier `protobuf_oneof:"policy_specifier"`
	// The flag that short-circuits the hash computing. This field provides a
	// 'fallback' style of configuration: "if a terminal policy doesn't work,
	// fallback to rest of the policy list", it saves time when the terminal
	// policy works.
	//
	// If true, and there is already a hash computed, ignore rest of the
	// list of hash polices.
	// For example, if the following hash methods are configured:
	//
	//  ========= ========
	//  specifier terminal
	//  ========= ========
	//  Header A  true
	//  Header B  false
	//  Header C  false
	//  ========= ========
	//
	// The generateHash process ends if policy "header A" generates a hash, as
	// it's a terminal policy.
	Terminal             bool     `protobuf:"varint,4,opt,name=terminal,proto3" json:"terminal,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RouteAction_HashPolicy) Reset()         { *m = RouteAction_HashPolicy{} }
func (m *RouteAction_HashPolicy) String() string { return proto.CompactTextString(m) }
func (*RouteAction_HashPolicy) ProtoMessage()    {}
func (*RouteAction_HashPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_3f3197b7daaf8719, []int{5, 1}
}
func (m *RouteAction_HashPolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteAction_HashPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RouteAction_HashPolicy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RouteAction_HashPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteAction_HashPolicy.Merge(m, src)
}
func (m *RouteAction_HashPolicy) XXX_Size() int {
	return m.Size()
}
func (m *RouteAction_HashPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteAction_HashPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_RouteAction_HashPolicy proto.InternalMessageInfo

type isRouteAction_HashPolicy_PolicySpecifier interface {
	isRouteAction_HashPolicy_PolicySpecifier()
	MarshalTo([]byte) (int, error)
	Size() int
}

type RouteAction_HashPolicy_Header_ struct {
	Header *RouteAction_HashPolicy_Header `protobuf:"bytes,1,opt,name=header,proto3,oneof"`
}
type RouteAction_HashPolicy_Cookie_ struct {
	Cookie *RouteAction_HashPolicy_Cookie `protobuf:"bytes,2,opt,name=cookie,proto3,oneof"`
}
type RouteAction_HashPolicy_ConnectionProperties_ struct {
	ConnectionProperties *RouteAction_HashPolicy_ConnectionProperties `protobuf:"bytes,3,opt,name=connection_properties,json=connectionProperties,proto3,oneof"`
}

func (*RouteAction_HashPolicy_Header_) isRouteAction_HashPolicy_PolicySpecifier()               {}
func (*RouteAction_HashPolicy_Cookie_) isRouteAction_HashPolicy_PolicySpecifier()               {}
func (*RouteAction_HashPolicy_ConnectionProperties_) isRouteAction_HashPolicy_PolicySpecifier() {}

func (m *RouteAction_HashPolicy) GetPolicySpecifier() isRouteAction_HashPolicy_PolicySpecifier {
	if m != nil {
		return m.PolicySpecifier
	}
	return nil
}

func (m *RouteAction_HashPolicy) GetHeader() *RouteAction_HashPolicy_Header {
	if x, ok := m.GetPolicySpecifier().(*RouteAction_HashPolicy_Header_); ok {
		return x.Header
	}
	return nil
}

func (m *RouteAction_HashPolicy) GetCookie() *RouteAction_HashPolicy_Cookie {
	if x, ok := m.GetPolicySpecifier().(*RouteAction_HashPolicy_Cookie_); ok {
		return x.Cookie
	}
	return nil
}

func (m *RouteAction_HashPolicy) GetConnectionProperties() *RouteAction_HashPolicy_ConnectionProperties {
	if x, ok := m.GetPolicySpecifier().(*RouteAction_HashPolicy_ConnectionProperties_); ok {
		return x.ConnectionProperties
	}
	return nil
}

func (m *RouteAction_HashPolicy) GetTerminal() bool {
	if m != nil {
		return m.Terminal
	}
	return false
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*RouteAction_HashPolicy) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*RouteAction_HashPolicy_Header_)(nil),
		(*RouteAction_HashPolicy_Cookie_)(nil),
		(*RouteAction_HashPolicy_ConnectionProperties_)(nil),
	}
}

type RouteAction_HashPolicy_Header struct {
	// The name of the request header that will be used to obtain the hash
	// key. If the request header is not present, no hash will be produced.
	HeaderName           string   `protobuf:"bytes,1,opt,name=header_name,json=headerName,proto3" json:"header_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RouteAction_HashPolicy_Header) Reset()         { *m = RouteAction_HashPolicy_Header{} }
func (m *RouteAction_HashPolicy_Header) String() string { return proto.CompactTextString(m) }
func (*RouteAction_HashPolicy_Header) ProtoMessage()    {}
func (*RouteAction_HashPolicy_Header) Descriptor() ([]byte, []int) {
	return fileDescriptor_3f3197b7daaf8719, []int{5, 1, 0}
}
func (m *RouteAction_HashPolicy_Header) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteAction_HashPolicy_Header) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RouteAction_HashPolicy_Header.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RouteAction_HashPolicy_Header) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteAction_HashPolicy_Header.Merge(m, src)
}
func (m *RouteAction_HashPolicy_Header) XXX_Size() int {
	return m.Size()
}
func (m *RouteAction_HashPolicy_Header) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteAction_HashPolicy_Header.DiscardUnknown(m)
}

var xxx_messageInfo_RouteAction_HashPolicy_Header proto.InternalMessageInfo

func (m *RouteAction_HashPolicy_Header) GetHeaderName() string {
	if m != nil {
		return m.HeaderName
	}
	return ""
}

// Envoy supports two types of cookie affinity:
//
// 1. Passive. Envoy takes a cookie that's present in the cookies header and
//    hashes on its value.
//
// 2. Generated. Envoy generates and sets a cookie with an expiration (TTL)
//    on the first request from the client in its response to the client,
//    based on the endpoint the request gets sent to. The client then
//    presents this on the next and all subsequent requests. The hash of
//    this is sufficient to ensure these requests get sent to the same
//    endpoint. The cookie is generated by hashing the source and
//    destination ports and addresses so that multiple independent HTTP2
//    streams on the same connection will independently receive the same
//    cookie, even if they arrive at the Envoy simultaneously.
type RouteAction_HashPolicy_Cookie struct {
	// The name of the cookie that will be used to obtain the hash key. If the
	// cookie is not present and ttl below is not set, no hash will be
	// produced.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// If specified, a cookie with the TTL will be generated if the cookie is
	// not present. If the TTL is present and zero, the generated cookie will
	// be a session cookie.
	Ttl *types.Duration `protobuf:"bytes,2,opt,name=ttl,proto3" json:"ttl,omitempty"`
	// The name of the path for the cookie. If no path is specified here, no path
	// will be set for the cookie.
	Path                 string   `protobuf:"bytes,3,opt,name=path,proto3" json:"path,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RouteAction_HashPolicy_Cookie) Reset()         { *m = RouteAction_HashPolicy_Cookie{} }
func (m *RouteAction_HashPolicy_Cookie) String() string { return proto.CompactTextString(m) }
func (*RouteAction_HashPolicy_Cookie) ProtoMessage()    {}
func (*RouteAction_HashPolicy_Cookie) Descriptor() ([]byte, []int) {
	return fileDescriptor_3f3197b7daaf8719, []int{5, 1, 1}
}
func (m *RouteAction_HashPolicy_Cookie) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteAction_HashPolicy_Cookie) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RouteAction_HashPolicy_Cookie.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RouteAction_HashPolicy_Cookie) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteAction_HashPolicy_Cookie.Merge(m, src)
}
func (m *RouteAction_HashPolicy_Cookie) XXX_Size() int {
	return m.Size()
}
func (m *RouteAction_HashPolicy_Cookie) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteAction_HashPolicy_Cookie.DiscardUnknown(m)
}

var xxx_messageInfo_RouteAction_HashPolicy_Cookie proto.InternalMessageInfo

func (m *RouteAction_HashPolicy_Cookie) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RouteAction_HashPolicy_Cookie) GetTtl() *types.Duration {
	if m != nil {
		return m.Ttl
	}
	return nil
}

func (m *RouteAction_HashPolicy_Cookie) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

type RouteAction_HashPolicy_ConnectionProperties struct {
	// Hash on source IP address.
	SourceIp             bool     `protobuf:"varint,1,opt,name=source_ip,json=sourceIp,proto3" json:"source_ip,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RouteAction_HashPolicy_ConnectionProperties) Reset() {
	*m = RouteAction_HashPolicy_ConnectionProperties{}
}
func (m *RouteAction_HashPolicy_ConnectionProperties) String() string {
	return proto.CompactTextString(m)
}
func (*RouteAction_HashPolicy_ConnectionProperties) ProtoMessage() {}
func (*RouteAction_HashPolicy_ConnectionProperties) Descriptor() ([]byte, []int) {
	return fileDescriptor_3f3197b7daaf8719, []int{5, 1, 2}
}
func (m *RouteAction_HashPolicy_ConnectionProperties) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteAction_HashPolicy_ConnectionProperties) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RouteAction_HashPolicy_ConnectionProperties.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RouteAction_HashPolicy_ConnectionProperties) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteAction_HashPolicy_ConnectionProperties.Merge(m, src)
}
func (m *RouteAction_HashPolicy_ConnectionProperties) XXX_Size() int {
	return m.Size()
}
func (m *RouteAction_HashPolicy_ConnectionProperties) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteAction_HashPolicy_ConnectionProperties.DiscardUnknown(m)
}

var xxx_messageInfo_RouteAction_HashPolicy_ConnectionProperties proto.InternalMessageInfo

func (m *RouteAction_HashPolicy_ConnectionProperties) GetSourceIp() bool {
	if m != nil {
		return m.SourceIp
	}
	return false
}

// Allows enabling and disabling upgrades on a per-route basis.
// This overrides any enabled/disabled upgrade filter chain specified in the
// HttpConnectionManager
// :ref:upgrade_configs`
// <envoy_api_field_config.filter.network.http_connection_manager.v3alpha.HttpConnectionManager.upgrade_configs>`
// but does not affect any custom filter chain specified there.
type RouteAction_UpgradeConfig struct {
	// The case-insensitive name of this upgrade, e.g. "websocket".
	// For each upgrade type present in upgrade_configs, requests with
	// Upgrade: [upgrade_type] will be proxied upstream.
	UpgradeType string `protobuf:"bytes,1,opt,name=upgrade_type,json=upgradeType,proto3" json:"upgrade_type,omitempty"`
	// Determines if upgrades are available on this route. Defaults to true.
	Enabled              *types.BoolValue `protobuf:"bytes,2,opt,name=enabled,proto3" json:"enabled,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *RouteAction_UpgradeConfig) Reset()         { *m = RouteAction_UpgradeConfig{} }
func (m *RouteAction_UpgradeConfig) String() string { return proto.CompactTextString(m) }
func (*RouteAction_UpgradeConfig) ProtoMessage()    {}
func (*RouteAction_UpgradeConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_3f3197b7daaf8719, []int{5, 2}
}
func (m *RouteAction_UpgradeConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteAction_UpgradeConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RouteAction_UpgradeConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RouteAction_UpgradeConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteAction_UpgradeConfig.Merge(m, src)
}
func (m *RouteAction_UpgradeConfig) XXX_Size() int {
	return m.Size()
}
func (m *RouteAction_UpgradeConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteAction_UpgradeConfig.DiscardUnknown(m)
}

var xxx_messageInfo_RouteAction_UpgradeConfig proto.InternalMessageInfo

func (m *RouteAction_UpgradeConfig) GetUpgradeType() string {
	if m != nil {
		return m.UpgradeType
	}
	return ""
}

func (m *RouteAction_UpgradeConfig) GetEnabled() *types.BoolValue {
	if m != nil {
		return m.Enabled
	}
	return nil
}

// HTTP retry :ref:`architecture overview <arch_overview_http_routing_retry>`.
// [#next-free-field: 11]
type RetryPolicy struct {
	// Specifies the conditions under which retry takes place. These are the same
	// conditions documented for :ref:`config_http_filters_router_x-envoy-retry-on` and
	// :ref:`config_http_filters_router_x-envoy-retry-grpc-on`.
	RetryOn string `protobuf:"bytes,1,opt,name=retry_on,json=retryOn,proto3" json:"retry_on,omitempty"`
	// Specifies the allowed number of retries. This parameter is optional and
	// defaults to 1. These are the same conditions documented for
	// :ref:`config_http_filters_router_x-envoy-max-retries`.
	NumRetries *types.UInt32Value `protobuf:"bytes,2,opt,name=num_retries,json=numRetries,proto3" json:"num_retries,omitempty"`
	// Specifies a non-zero upstream timeout per retry attempt. This parameter is optional. The
	// same conditions documented for
	// :ref:`config_http_filters_router_x-envoy-upstream-rq-per-try-timeout-ms` apply.
	//
	// .. note::
	//
	//   If left unspecified, Envoy will use the global
	//   :ref:`route timeout <envoy_api_field_api.v3alpha.route.RouteAction.timeout>` for the request.
	//   Consequently, when using a :ref:`5xx <config_http_filters_router_x-envoy-retry-on>` based
	//   retry policy, a request that times out will not be retried as the total timeout budget
	//   would have been exhausted.
	PerTryTimeout *types.Duration `protobuf:"bytes,3,opt,name=per_try_timeout,json=perTryTimeout,proto3" json:"per_try_timeout,omitempty"`
	// Specifies an implementation of a RetryPriority which is used to determine the
	// distribution of load across priorities used for retries. Refer to
	// :ref:`retry plugin configuration <arch_overview_http_retry_plugins>` for more details.
	RetryPriority *RetryPolicy_RetryPriority `protobuf:"bytes,4,opt,name=retry_priority,json=retryPriority,proto3" json:"retry_priority,omitempty"`
	// Specifies a collection of RetryHostPredicates that will be consulted when selecting a host
	// for retries. If any of the predicates reject the host, host selection will be reattempted.
	// Refer to :ref:`retry plugin configuration <arch_overview_http_retry_plugins>` for more
	// details.
	RetryHostPredicate []*RetryPolicy_RetryHostPredicate `protobuf:"bytes,5,rep,name=retry_host_predicate,json=retryHostPredicate,proto3" json:"retry_host_predicate,omitempty"`
	// The maximum number of times host selection will be reattempted before giving up, at which
	// point the host that was last selected will be routed to. If unspecified, this will default to
	// retrying once.
	HostSelectionRetryMaxAttempts int64 `protobuf:"varint,6,opt,name=host_selection_retry_max_attempts,json=hostSelectionRetryMaxAttempts,proto3" json:"host_selection_retry_max_attempts,omitempty"`
	// HTTP status codes that should trigger a retry in addition to those specified by retry_on.
	RetriableStatusCodes []uint32 `protobuf:"varint,7,rep,packed,name=retriable_status_codes,json=retriableStatusCodes,proto3" json:"retriable_status_codes,omitempty"`
	// Specifies parameters that control retry back off. This parameter is optional, in which case the
	// default base interval is 25 milliseconds or, if set, the current value of the
	// `upstream.base_retry_backoff_ms` runtime parameter. The default maximum interval is 10 times
	// the base interval. The documentation for :ref:`config_http_filters_router_x-envoy-max-retries`
	// describes Envoy's back-off algorithm.
	RetryBackOff *RetryPolicy_RetryBackOff `protobuf:"bytes,8,opt,name=retry_back_off,json=retryBackOff,proto3" json:"retry_back_off,omitempty"`
	// HTTP response headers that trigger a retry if present in the response. A retry will be
	// triggered if any of the header matches match the upstream response headers.
	// The field is only consulted if 'retriable-headers' retry policy is active.
	RetriableHeaders []*HeaderMatcher `protobuf:"bytes,9,rep,name=retriable_headers,json=retriableHeaders,proto3" json:"retriable_headers,omitempty"`
	// HTTP headers which must be present in the request for retries to be attempted.
	RetriableRequestHeaders []*HeaderMatcher `protobuf:"bytes,10,rep,name=retriable_request_headers,json=retriableRequestHeaders,proto3" json:"retriable_request_headers,omitempty"`
	XXX_NoUnkeyedLiteral    struct{}         `json:"-"`
	XXX_unrecognized        []byte           `json:"-"`
	XXX_sizecache           int32            `json:"-"`
}

func (m *RetryPolicy) Reset()         { *m = RetryPolicy{} }
func (m *RetryPolicy) String() string { return proto.CompactTextString(m) }
func (*RetryPolicy) ProtoMessage()    {}
func (*RetryPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_3f3197b7daaf8719, []int{6}
}
func (m *RetryPolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RetryPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RetryPolicy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RetryPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RetryPolicy.Merge(m, src)
}
func (m *RetryPolicy) XXX_Size() int {
	return m.Size()
}
func (m *RetryPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_RetryPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_RetryPolicy proto.InternalMessageInfo

func (m *RetryPolicy) GetRetryOn() string {
	if m != nil {
		return m.RetryOn
	}
	return ""
}

func (m *RetryPolicy) GetNumRetries() *types.UInt32Value {
	if m != nil {
		return m.NumRetries
	}
	return nil
}

func (m *RetryPolicy) GetPerTryTimeout() *types.Duration {
	if m != nil {
		return m.PerTryTimeout
	}
	return nil
}

func (m *RetryPolicy) GetRetryPriority() *RetryPolicy_RetryPriority {
	if m != nil {
		return m.RetryPriority
	}
	return nil
}

func (m *RetryPolicy) GetRetryHostPredicate() []*RetryPolicy_RetryHostPredicate {
	if m != nil {
		return m.RetryHostPredicate
	}
	return nil
}

func (m *RetryPolicy) GetHostSelectionRetryMaxAttempts() int64 {
	if m != nil {
		return m.HostSelectionRetryMaxAttempts
	}
	return 0
}

func (m *RetryPolicy) GetRetriableStatusCodes() []uint32 {
	if m != nil {
		return m.RetriableStatusCodes
	}
	return nil
}

func (m *RetryPolicy) GetRetryBackOff() *RetryPolicy_RetryBackOff {
	if m != nil {
		return m.RetryBackOff
	}
	return nil
}

func (m *RetryPolicy) GetRetriableHeaders() []*HeaderMatcher {
	if m != nil {
		return m.RetriableHeaders
	}
	return nil
}

func (m *RetryPolicy) GetRetriableRequestHeaders() []*HeaderMatcher {
	if m != nil {
		return m.RetriableRequestHeaders
	}
	return nil
}

type RetryPolicy_RetryPriority struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Types that are valid to be assigned to ConfigType:
	//	*RetryPolicy_RetryPriority_TypedConfig
	ConfigType           isRetryPolicy_RetryPriority_ConfigType `protobuf_oneof:"config_type"`
	XXX_NoUnkeyedLiteral struct{}                               `json:"-"`
	XXX_unrecognized     []byte                                 `json:"-"`
	XXX_sizecache        int32                                  `json:"-"`
}

func (m *RetryPolicy_RetryPriority) Reset()         { *m = RetryPolicy_RetryPriority{} }
func (m *RetryPolicy_RetryPriority) String() string { return proto.CompactTextString(m) }
func (*RetryPolicy_RetryPriority) ProtoMessage()    {}
func (*RetryPolicy_RetryPriority) Descriptor() ([]byte, []int) {
	return fileDescriptor_3f3197b7daaf8719, []int{6, 0}
}
func (m *RetryPolicy_RetryPriority) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RetryPolicy_RetryPriority) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RetryPolicy_RetryPriority.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RetryPolicy_RetryPriority) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RetryPolicy_RetryPriority.Merge(m, src)
}
func (m *RetryPolicy_RetryPriority) XXX_Size() int {
	return m.Size()
}
func (m *RetryPolicy_RetryPriority) XXX_DiscardUnknown() {
	xxx_messageInfo_RetryPolicy_RetryPriority.DiscardUnknown(m)
}

var xxx_messageInfo_RetryPolicy_RetryPriority proto.InternalMessageInfo

type isRetryPolicy_RetryPriority_ConfigType interface {
	isRetryPolicy_RetryPriority_ConfigType()
	MarshalTo([]byte) (int, error)
	Size() int
}

type RetryPolicy_RetryPriority_TypedConfig struct {
	TypedConfig *types.Any `protobuf:"bytes,3,opt,name=typed_config,json=typedConfig,proto3,oneof"`
}

func (*RetryPolicy_RetryPriority_TypedConfig) isRetryPolicy_RetryPriority_ConfigType() {}

func (m *RetryPolicy_RetryPriority) GetConfigType() isRetryPolicy_RetryPriority_ConfigType {
	if m != nil {
		return m.ConfigType
	}
	return nil
}

func (m *RetryPolicy_RetryPriority) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RetryPolicy_RetryPriority) GetTypedConfig() *types.Any {
	if x, ok := m.GetConfigType().(*RetryPolicy_RetryPriority_TypedConfig); ok {
		return x.TypedConfig
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*RetryPolicy_RetryPriority) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*RetryPolicy_RetryPriority_TypedConfig)(nil),
	}
}

type RetryPolicy_RetryHostPredicate struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Types that are valid to be assigned to ConfigType:
	//	*RetryPolicy_RetryHostPredicate_TypedConfig
	ConfigType           isRetryPolicy_RetryHostPredicate_ConfigType `protobuf_oneof:"config_type"`
	XXX_NoUnkeyedLiteral struct{}                                    `json:"-"`
	XXX_unrecognized     []byte                                      `json:"-"`
	XXX_sizecache        int32                                       `json:"-"`
}

func (m *RetryPolicy_RetryHostPredicate) Reset()         { *m = RetryPolicy_RetryHostPredicate{} }
func (m *RetryPolicy_RetryHostPredicate) String() string { return proto.CompactTextString(m) }
func (*RetryPolicy_RetryHostPredicate) ProtoMessage()    {}
func (*RetryPolicy_RetryHostPredicate) Descriptor() ([]byte, []int) {
	return fileDescriptor_3f3197b7daaf8719, []int{6, 1}
}
func (m *RetryPolicy_RetryHostPredicate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RetryPolicy_RetryHostPredicate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RetryPolicy_RetryHostPredicate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RetryPolicy_RetryHostPredicate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RetryPolicy_RetryHostPredicate.Merge(m, src)
}
func (m *RetryPolicy_RetryHostPredicate) XXX_Size() int {
	return m.Size()
}
func (m *RetryPolicy_RetryHostPredicate) XXX_DiscardUnknown() {
	xxx_messageInfo_RetryPolicy_RetryHostPredicate.DiscardUnknown(m)
}

var xxx_messageInfo_RetryPolicy_RetryHostPredicate proto.InternalMessageInfo

type isRetryPolicy_RetryHostPredicate_ConfigType interface {
	isRetryPolicy_RetryHostPredicate_ConfigType()
	MarshalTo([]byte) (int, error)
	Size() int
}

type RetryPolicy_RetryHostPredicate_TypedConfig struct {
	TypedConfig *types.Any `protobuf:"bytes,3,opt,name=typed_config,json=typedConfig,proto3,oneof"`
}

func (*RetryPolicy_RetryHostPredicate_TypedConfig) isRetryPolicy_RetryHostPredicate_ConfigType() {}

func (m *RetryPolicy_RetryHostPredicate) GetConfigType() isRetryPolicy_RetryHostPredicate_ConfigType {
	if m != nil {
		return m.ConfigType
	}
	return nil
}

func (m *RetryPolicy_RetryHostPredicate) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RetryPolicy_RetryHostPredicate) GetTypedConfig() *types.Any {
	if x, ok := m.GetConfigType().(*RetryPolicy_RetryHostPredicate_TypedConfig); ok {
		return x.TypedConfig
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*RetryPolicy_RetryHostPredicate) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*RetryPolicy_RetryHostPredicate_TypedConfig)(nil),
	}
}

type RetryPolicy_RetryBackOff struct {
	// Specifies the base interval between retries. This parameter is required and must be greater
	// than zero. Values less than 1 ms are rounded up to 1 ms.
	// See :ref:`config_http_filters_router_x-envoy-max-retries` for a discussion of Envoy's
	// back-off algorithm.
	BaseInterval *types.Duration `protobuf:"bytes,1,opt,name=base_interval,json=baseInterval,proto3" json:"base_interval,omitempty"`
	// Specifies the maximum interval between retries. This parameter is optional, but must be
	// greater than or equal to the `base_interval` if set. The default is 10 times the
	// `base_interval`. See :ref:`config_http_filters_router_x-envoy-max-retries` for a discussion
	// of Envoy's back-off algorithm.
	MaxInterval          *types.Duration `protobuf:"bytes,2,opt,name=max_interval,json=maxInterval,proto3" json:"max_interval,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *RetryPolicy_RetryBackOff) Reset()         { *m = RetryPolicy_RetryBackOff{} }
func (m *RetryPolicy_RetryBackOff) String() string { return proto.CompactTextString(m) }
func (*RetryPolicy_RetryBackOff) ProtoMessage()    {}
func (*RetryPolicy_RetryBackOff) Descriptor() ([]byte, []int) {
	return fileDescriptor_3f3197b7daaf8719, []int{6, 2}
}
func (m *RetryPolicy_RetryBackOff) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RetryPolicy_RetryBackOff) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RetryPolicy_RetryBackOff.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RetryPolicy_RetryBackOff) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RetryPolicy_RetryBackOff.Merge(m, src)
}
func (m *RetryPolicy_RetryBackOff) XXX_Size() int {
	return m.Size()
}
func (m *RetryPolicy_RetryBackOff) XXX_DiscardUnknown() {
	xxx_messageInfo_RetryPolicy_RetryBackOff.DiscardUnknown(m)
}

var xxx_messageInfo_RetryPolicy_RetryBackOff proto.InternalMessageInfo

func (m *RetryPolicy_RetryBackOff) GetBaseInterval() *types.Duration {
	if m != nil {
		return m.BaseInterval
	}
	return nil
}

func (m *RetryPolicy_RetryBackOff) GetMaxInterval() *types.Duration {
	if m != nil {
		return m.MaxInterval
	}
	return nil
}

// HTTP request hedging :ref:`architecture overview <arch_overview_http_routing_hedging>`.
type HedgePolicy struct {
	// Specifies the number of initial requests that should be sent upstream.
	// Must be at least 1.
	// Defaults to 1.
	// [#not-implemented-hide:]
	InitialRequests *types.UInt32Value `protobuf:"bytes,1,opt,name=initial_requests,json=initialRequests,proto3" json:"initial_requests,omitempty"`
	// Specifies a probability that an additional upstream request should be sent
	// on top of what is specified by initial_requests.
	// Defaults to 0.
	// [#not-implemented-hide:]
	AdditionalRequestChance *v3alpha1.FractionalPercent `protobuf:"bytes,2,opt,name=additional_request_chance,json=additionalRequestChance,proto3" json:"additional_request_chance,omitempty"`
	// Indicates that a hedged request should be sent when the per-try timeout
	// is hit. This will only occur if the retry policy also indicates that a
	// timed out request should be retried.
	// Once a timed out request is retried due to per try timeout, the router
	// filter will ensure that it is not retried again even if the returned
	// response headers would otherwise be retried according the specified
	// :ref:`RetryPolicy <envoy_api_msg_api.v3alpha.route.RetryPolicy>`.
	// Defaults to false.
	HedgeOnPerTryTimeout bool     `protobuf:"varint,3,opt,name=hedge_on_per_try_timeout,json=hedgeOnPerTryTimeout,proto3" json:"hedge_on_per_try_timeout,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HedgePolicy) Reset()         { *m = HedgePolicy{} }
func (m *HedgePolicy) String() string { return proto.CompactTextString(m) }
func (*HedgePolicy) ProtoMessage()    {}
func (*HedgePolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_3f3197b7daaf8719, []int{7}
}
func (m *HedgePolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HedgePolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HedgePolicy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HedgePolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HedgePolicy.Merge(m, src)
}
func (m *HedgePolicy) XXX_Size() int {
	return m.Size()
}
func (m *HedgePolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_HedgePolicy.DiscardUnknown(m)
}

var xxx_messageInfo_HedgePolicy proto.InternalMessageInfo

func (m *HedgePolicy) GetInitialRequests() *types.UInt32Value {
	if m != nil {
		return m.InitialRequests
	}
	return nil
}

func (m *HedgePolicy) GetAdditionalRequestChance() *v3alpha1.FractionalPercent {
	if m != nil {
		return m.AdditionalRequestChance
	}
	return nil
}

func (m *HedgePolicy) GetHedgeOnPerTryTimeout() bool {
	if m != nil {
		return m.HedgeOnPerTryTimeout
	}
	return false
}

// [#next-free-field: 9]
type RedirectAction struct {
	// When the scheme redirection take place, the following rules apply:
	//  1. If the source URI scheme is `http` and the port is explicitly
	//     set to `:80`, the port will be removed after the redirection
	//  2. If the source URI scheme is `https` and the port is explicitly
	//     set to `:443`, the port will be removed after the redirection
	//
	// Types that are valid to be assigned to SchemeRewriteSpecifier:
	//	*RedirectAction_HttpsRedirect
	//	*RedirectAction_SchemeRedirect
	SchemeRewriteSpecifier isRedirectAction_SchemeRewriteSpecifier `protobuf_oneof:"scheme_rewrite_specifier"`
	// The host portion of the URL will be swapped with this value.
	HostRedirect string `protobuf:"bytes,1,opt,name=host_redirect,json=hostRedirect,proto3" json:"host_redirect,omitempty"`
	// The port value of the URL will be swapped with this value.
	PortRedirect uint32 `protobuf:"varint,8,opt,name=port_redirect,json=portRedirect,proto3" json:"port_redirect,omitempty"`
	// Types that are valid to be assigned to PathRewriteSpecifier:
	//	*RedirectAction_PathRedirect
	//	*RedirectAction_PrefixRewrite
	PathRewriteSpecifier isRedirectAction_PathRewriteSpecifier `protobuf_oneof:"path_rewrite_specifier"`
	// The HTTP status code to use in the redirect response. The default response
	// code is MOVED_PERMANENTLY (301).
	ResponseCode RedirectAction_RedirectResponseCode `protobuf:"varint,3,opt,name=response_code,json=responseCode,proto3,enum=envoy.api.v3alpha.route.RedirectAction_RedirectResponseCode" json:"response_code,omitempty"`
	// Indicates that during redirection, the query portion of the URL will
	// be removed. Default value is false.
	StripQuery           bool     `protobuf:"varint,6,opt,name=strip_query,json=stripQuery,proto3" json:"strip_query,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RedirectAction) Reset()         { *m = RedirectAction{} }
func (m *RedirectAction) String() string { return proto.CompactTextString(m) }
func (*RedirectAction) ProtoMessage()    {}
func (*RedirectAction) Descriptor() ([]byte, []int) {
	return fileDescriptor_3f3197b7daaf8719, []int{8}
}
func (m *RedirectAction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RedirectAction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RedirectAction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RedirectAction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RedirectAction.Merge(m, src)
}
func (m *RedirectAction) XXX_Size() int {
	return m.Size()
}
func (m *RedirectAction) XXX_DiscardUnknown() {
	xxx_messageInfo_RedirectAction.DiscardUnknown(m)
}

var xxx_messageInfo_RedirectAction proto.InternalMessageInfo

type isRedirectAction_SchemeRewriteSpecifier interface {
	isRedirectAction_SchemeRewriteSpecifier()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isRedirectAction_PathRewriteSpecifier interface {
	isRedirectAction_PathRewriteSpecifier()
	MarshalTo([]byte) (int, error)
	Size() int
}

type RedirectAction_HttpsRedirect struct {
	HttpsRedirect bool `protobuf:"varint,4,opt,name=https_redirect,json=httpsRedirect,proto3,oneof"`
}
type RedirectAction_SchemeRedirect struct {
	SchemeRedirect string `protobuf:"bytes,7,opt,name=scheme_redirect,json=schemeRedirect,proto3,oneof"`
}
type RedirectAction_PathRedirect struct {
	PathRedirect string `protobuf:"bytes,2,opt,name=path_redirect,json=pathRedirect,proto3,oneof"`
}
type RedirectAction_PrefixRewrite struct {
	PrefixRewrite string `protobuf:"bytes,5,opt,name=prefix_rewrite,json=prefixRewrite,proto3,oneof"`
}

func (*RedirectAction_HttpsRedirect) isRedirectAction_SchemeRewriteSpecifier()  {}
func (*RedirectAction_SchemeRedirect) isRedirectAction_SchemeRewriteSpecifier() {}
func (*RedirectAction_PathRedirect) isRedirectAction_PathRewriteSpecifier()     {}
func (*RedirectAction_PrefixRewrite) isRedirectAction_PathRewriteSpecifier()    {}

func (m *RedirectAction) GetSchemeRewriteSpecifier() isRedirectAction_SchemeRewriteSpecifier {
	if m != nil {
		return m.SchemeRewriteSpecifier
	}
	return nil
}
func (m *RedirectAction) GetPathRewriteSpecifier() isRedirectAction_PathRewriteSpecifier {
	if m != nil {
		return m.PathRewriteSpecifier
	}
	return nil
}

func (m *RedirectAction) GetHttpsRedirect() bool {
	if x, ok := m.GetSchemeRewriteSpecifier().(*RedirectAction_HttpsRedirect); ok {
		return x.HttpsRedirect
	}
	return false
}

func (m *RedirectAction) GetSchemeRedirect() string {
	if x, ok := m.GetSchemeRewriteSpecifier().(*RedirectAction_SchemeRedirect); ok {
		return x.SchemeRedirect
	}
	return ""
}

func (m *RedirectAction) GetHostRedirect() string {
	if m != nil {
		return m.HostRedirect
	}
	return ""
}

func (m *RedirectAction) GetPortRedirect() uint32 {
	if m != nil {
		return m.PortRedirect
	}
	return 0
}

func (m *RedirectAction) GetPathRedirect() string {
	if x, ok := m.GetPathRewriteSpecifier().(*RedirectAction_PathRedirect); ok {
		return x.PathRedirect
	}
	return ""
}

func (m *RedirectAction) GetPrefixRewrite() string {
	if x, ok := m.GetPathRewriteSpecifier().(*RedirectAction_PrefixRewrite); ok {
		return x.PrefixRewrite
	}
	return ""
}

func (m *RedirectAction) GetResponseCode() RedirectAction_RedirectResponseCode {
	if m != nil {
		return m.ResponseCode
	}
	return RedirectAction_MOVED_PERMANENTLY
}

func (m *RedirectAction) GetStripQuery() bool {
	if m != nil {
		return m.StripQuery
	}
	return false
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*RedirectAction) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*RedirectAction_HttpsRedirect)(nil),
		(*RedirectAction_SchemeRedirect)(nil),
		(*RedirectAction_PathRedirect)(nil),
		(*RedirectAction_PrefixRewrite)(nil),
	}
}

type DirectResponseAction struct {
	// Specifies the HTTP response status to be returned.
	Status uint32 `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
	// Specifies the content of the response body. If this setting is omitted,
	// no body is included in the generated response.
	//
	// .. note::
	//
	//   Headers can be specified using *response_headers_to_add* in the enclosing
	//   :ref:`envoy_api_msg_route.Route`, :ref:`envoy_api_msg_RouteConfiguration` or
	//   :ref:`envoy_api_msg_route.VirtualHost`.
	Body                 *core.DataSource `protobuf:"bytes,2,opt,name=body,proto3" json:"body,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *DirectResponseAction) Reset()         { *m = DirectResponseAction{} }
func (m *DirectResponseAction) String() string { return proto.CompactTextString(m) }
func (*DirectResponseAction) ProtoMessage()    {}
func (*DirectResponseAction) Descriptor() ([]byte, []int) {
	return fileDescriptor_3f3197b7daaf8719, []int{9}
}
func (m *DirectResponseAction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DirectResponseAction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DirectResponseAction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DirectResponseAction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DirectResponseAction.Merge(m, src)
}
func (m *DirectResponseAction) XXX_Size() int {
	return m.Size()
}
func (m *DirectResponseAction) XXX_DiscardUnknown() {
	xxx_messageInfo_DirectResponseAction.DiscardUnknown(m)
}

var xxx_messageInfo_DirectResponseAction proto.InternalMessageInfo

func (m *DirectResponseAction) GetStatus() uint32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *DirectResponseAction) GetBody() *core.DataSource {
	if m != nil {
		return m.Body
	}
	return nil
}

type Decorator struct {
	// The operation name associated with the request matched to this route. If tracing is
	// enabled, this information will be used as the span name reported for this request.
	//
	// .. note::
	//
	//   For ingress (inbound) requests, or egress (outbound) responses, this value may be overridden
	//   by the :ref:`x-envoy-decorator-operation
	//   <config_http_filters_router_x-envoy-decorator-operation>` header.
	Operation            string   `protobuf:"bytes,1,opt,name=operation,proto3" json:"operation,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Decorator) Reset()         { *m = Decorator{} }
func (m *Decorator) String() string { return proto.CompactTextString(m) }
func (*Decorator) ProtoMessage()    {}
func (*Decorator) Descriptor() ([]byte, []int) {
	return fileDescriptor_3f3197b7daaf8719, []int{10}
}
func (m *Decorator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Decorator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Decorator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Decorator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Decorator.Merge(m, src)
}
func (m *Decorator) XXX_Size() int {
	return m.Size()
}
func (m *Decorator) XXX_DiscardUnknown() {
	xxx_messageInfo_Decorator.DiscardUnknown(m)
}

var xxx_messageInfo_Decorator proto.InternalMessageInfo

func (m *Decorator) GetOperation() string {
	if m != nil {
		return m.Operation
	}
	return ""
}

type Tracing struct {
	// Target percentage of requests managed by this HTTP connection manager that will be force
	// traced if the :ref:`x-client-trace-id <config_http_conn_man_headers_x-client-trace-id>`
	// header is set. This field is a direct analog for the runtime variable
	// 'tracing.client_sampling' in the :ref:`HTTP Connection Manager
	// <config_http_conn_man_runtime>`.
	// Default: 100%
	ClientSampling *v3alpha1.FractionalPercent `protobuf:"bytes,1,opt,name=client_sampling,json=clientSampling,proto3" json:"client_sampling,omitempty"`
	// Target percentage of requests managed by this HTTP connection manager that will be randomly
	// selected for trace generation, if not requested by the client or not forced. This field is
	// a direct analog for the runtime variable 'tracing.random_sampling' in the
	// :ref:`HTTP Connection Manager <config_http_conn_man_runtime>`.
	// Default: 100%
	RandomSampling *v3alpha1.FractionalPercent `protobuf:"bytes,2,opt,name=random_sampling,json=randomSampling,proto3" json:"random_sampling,omitempty"`
	// Target percentage of requests managed by this HTTP connection manager that will be traced
	// after all other sampling checks have been applied (client-directed, force tracing, random
	// sampling). This field functions as an upper limit on the total configured sampling rate. For
	// instance, setting client_sampling to 100% but overall_sampling to 1% will result in only 1%
	// of client requests with the appropriate headers to be force traced. This field is a direct
	// analog for the runtime variable 'tracing.global_enabled' in the
	// :ref:`HTTP Connection Manager <config_http_conn_man_runtime>`.
	// Default: 100%
	OverallSampling      *v3alpha1.FractionalPercent `protobuf:"bytes,3,opt,name=overall_sampling,json=overallSampling,proto3" json:"overall_sampling,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *Tracing) Reset()         { *m = Tracing{} }
func (m *Tracing) String() string { return proto.CompactTextString(m) }
func (*Tracing) ProtoMessage()    {}
func (*Tracing) Descriptor() ([]byte, []int) {
	return fileDescriptor_3f3197b7daaf8719, []int{11}
}
func (m *Tracing) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tracing) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tracing.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tracing) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tracing.Merge(m, src)
}
func (m *Tracing) XXX_Size() int {
	return m.Size()
}
func (m *Tracing) XXX_DiscardUnknown() {
	xxx_messageInfo_Tracing.DiscardUnknown(m)
}

var xxx_messageInfo_Tracing proto.InternalMessageInfo

func (m *Tracing) GetClientSampling() *v3alpha1.FractionalPercent {
	if m != nil {
		return m.ClientSampling
	}
	return nil
}

func (m *Tracing) GetRandomSampling() *v3alpha1.FractionalPercent {
	if m != nil {
		return m.RandomSampling
	}
	return nil
}

func (m *Tracing) GetOverallSampling() *v3alpha1.FractionalPercent {
	if m != nil {
		return m.OverallSampling
	}
	return nil
}

// A virtual cluster is a way of specifying a regex matching rule against
// certain important endpoints such that statistics are generated explicitly for
// the matched requests. The reason this is useful is that when doing
// prefix/path matching Envoy does not always know what the application
// considers to be an endpoint. Thus, it’s impossible for Envoy to generically
// emit per endpoint statistics. However, often systems have highly critical
// endpoints that they wish to get “perfect” statistics on. Virtual cluster
// statistics are perfect in the sense that they are emitted on the downstream
// side such that they include network level failures.
//
// Documentation for :ref:`virtual cluster statistics <config_http_filters_router_stats>`.
//
// .. note::
//
//    Virtual clusters are a useful tool, but we do not recommend setting up a virtual cluster for
//    every application endpoint. This is both not easily maintainable and as well the matching and
//    statistics output are not free.
type VirtualCluster struct {
	// Specifies a list of header matchers to use for matching requests. Each specified header must
	// match. The pseudo-headers `:path` and `:method` can be used to match the request path and
	// method, respectively.
	Headers []*HeaderMatcher `protobuf:"bytes,4,rep,name=headers,proto3" json:"headers,omitempty"`
	// Specifies the name of the virtual cluster. The virtual cluster name as well
	// as the virtual host name are used when emitting statistics. The statistics are emitted by the
	// router filter and are documented :ref:`here <config_http_filters_router_stats>`.
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VirtualCluster) Reset()         { *m = VirtualCluster{} }
func (m *VirtualCluster) String() string { return proto.CompactTextString(m) }
func (*VirtualCluster) ProtoMessage()    {}
func (*VirtualCluster) Descriptor() ([]byte, []int) {
	return fileDescriptor_3f3197b7daaf8719, []int{12}
}
func (m *VirtualCluster) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VirtualCluster) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VirtualCluster.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VirtualCluster) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VirtualCluster.Merge(m, src)
}
func (m *VirtualCluster) XXX_Size() int {
	return m.Size()
}
func (m *VirtualCluster) XXX_DiscardUnknown() {
	xxx_messageInfo_VirtualCluster.DiscardUnknown(m)
}

var xxx_messageInfo_VirtualCluster proto.InternalMessageInfo

func (m *VirtualCluster) GetHeaders() []*HeaderMatcher {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *VirtualCluster) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Global rate limiting :ref:`architecture overview <arch_overview_rate_limit>`.
type RateLimit struct {
	// Refers to the stage set in the filter. The rate limit configuration only
	// applies to filters with the same stage number. The default stage number is
	// 0.
	//
	// .. note::
	//
	//   The filter supports a range of 0 - 10 inclusively for stage numbers.
	Stage *types.UInt32Value `protobuf:"bytes,1,opt,name=stage,proto3" json:"stage,omitempty"`
	// The key to be set in runtime to disable this rate limit configuration.
	DisableKey string `protobuf:"bytes,2,opt,name=disable_key,json=disableKey,proto3" json:"disable_key,omitempty"`
	// A list of actions that are to be applied for this rate limit configuration.
	// Order matters as the actions are processed sequentially and the descriptor
	// is composed by appending descriptor entries in that sequence. If an action
	// cannot append a descriptor entry, no descriptor is generated for the
	// configuration. See :ref:`composing actions
	// <config_http_filters_rate_limit_composing_actions>` for additional documentation.
	Actions              []*RateLimit_Action `protobuf:"bytes,3,rep,name=actions,proto3" json:"actions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *RateLimit) Reset()         { *m = RateLimit{} }
func (m *RateLimit) String() string { return proto.CompactTextString(m) }
func (*RateLimit) ProtoMessage()    {}
func (*RateLimit) Descriptor() ([]byte, []int) {
	return fileDescriptor_3f3197b7daaf8719, []int{13}
}
func (m *RateLimit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RateLimit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RateLimit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RateLimit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RateLimit.Merge(m, src)
}
func (m *RateLimit) XXX_Size() int {
	return m.Size()
}
func (m *RateLimit) XXX_DiscardUnknown() {
	xxx_messageInfo_RateLimit.DiscardUnknown(m)
}

var xxx_messageInfo_RateLimit proto.InternalMessageInfo

func (m *RateLimit) GetStage() *types.UInt32Value {
	if m != nil {
		return m.Stage
	}
	return nil
}

func (m *RateLimit) GetDisableKey() string {
	if m != nil {
		return m.DisableKey
	}
	return ""
}

func (m *RateLimit) GetActions() []*RateLimit_Action {
	if m != nil {
		return m.Actions
	}
	return nil
}

// [#next-free-field: 7]
type RateLimit_Action struct {
	// Types that are valid to be assigned to ActionSpecifier:
	//	*RateLimit_Action_SourceCluster_
	//	*RateLimit_Action_DestinationCluster_
	//	*RateLimit_Action_RequestHeaders_
	//	*RateLimit_Action_RemoteAddress_
	//	*RateLimit_Action_GenericKey_
	//	*RateLimit_Action_HeaderValueMatch_
	ActionSpecifier      isRateLimit_Action_ActionSpecifier `protobuf_oneof:"action_specifier"`
	XXX_NoUnkeyedLiteral struct{}                           `json:"-"`
	XXX_unrecognized     []byte                             `json:"-"`
	XXX_sizecache        int32                              `json:"-"`
}

func (m *RateLimit_Action) Reset()         { *m = RateLimit_Action{} }
func (m *RateLimit_Action) String() string { return proto.CompactTextString(m) }
func (*RateLimit_Action) ProtoMessage()    {}
func (*RateLimit_Action) Descriptor() ([]byte, []int) {
	return fileDescriptor_3f3197b7daaf8719, []int{13, 0}
}
func (m *RateLimit_Action) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RateLimit_Action) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RateLimit_Action.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RateLimit_Action) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RateLimit_Action.Merge(m, src)
}
func (m *RateLimit_Action) XXX_Size() int {
	return m.Size()
}
func (m *RateLimit_Action) XXX_DiscardUnknown() {
	xxx_messageInfo_RateLimit_Action.DiscardUnknown(m)
}

var xxx_messageInfo_RateLimit_Action proto.InternalMessageInfo

type isRateLimit_Action_ActionSpecifier interface {
	isRateLimit_Action_ActionSpecifier()
	MarshalTo([]byte) (int, error)
	Size() int
}

type RateLimit_Action_SourceCluster_ struct {
	SourceCluster *RateLimit_Action_SourceCluster `protobuf:"bytes,1,opt,name=source_cluster,json=sourceCluster,proto3,oneof"`
}
type RateLimit_Action_DestinationCluster_ struct {
	DestinationCluster *RateLimit_Action_DestinationCluster `protobuf:"bytes,2,opt,name=destination_cluster,json=destinationCluster,proto3,oneof"`
}
type RateLimit_Action_RequestHeaders_ struct {
	RequestHeaders *RateLimit_Action_RequestHeaders `protobuf:"bytes,3,opt,name=request_headers,json=requestHeaders,proto3,oneof"`
}
type RateLimit_Action_RemoteAddress_ struct {
	RemoteAddress *RateLimit_Action_RemoteAddress `protobuf:"bytes,4,opt,name=remote_address,json=remoteAddress,proto3,oneof"`
}
type RateLimit_Action_GenericKey_ struct {
	GenericKey *RateLimit_Action_GenericKey `protobuf:"bytes,5,opt,name=generic_key,json=genericKey,proto3,oneof"`
}
type RateLimit_Action_HeaderValueMatch_ struct {
	HeaderValueMatch *RateLimit_Action_HeaderValueMatch `protobuf:"bytes,6,opt,name=header_value_match,json=headerValueMatch,proto3,oneof"`
}

func (*RateLimit_Action_SourceCluster_) isRateLimit_Action_ActionSpecifier()      {}
func (*RateLimit_Action_DestinationCluster_) isRateLimit_Action_ActionSpecifier() {}
func (*RateLimit_Action_RequestHeaders_) isRateLimit_Action_ActionSpecifier()     {}
func (*RateLimit_Action_RemoteAddress_) isRateLimit_Action_ActionSpecifier()      {}
func (*RateLimit_Action_GenericKey_) isRateLimit_Action_ActionSpecifier()         {}
func (*RateLimit_Action_HeaderValueMatch_) isRateLimit_Action_ActionSpecifier()   {}

func (m *RateLimit_Action) GetActionSpecifier() isRateLimit_Action_ActionSpecifier {
	if m != nil {
		return m.ActionSpecifier
	}
	return nil
}

func (m *RateLimit_Action) GetSourceCluster() *RateLimit_Action_SourceCluster {
	if x, ok := m.GetActionSpecifier().(*RateLimit_Action_SourceCluster_); ok {
		return x.SourceCluster
	}
	return nil
}

func (m *RateLimit_Action) GetDestinationCluster() *RateLimit_Action_DestinationCluster {
	if x, ok := m.GetActionSpecifier().(*RateLimit_Action_DestinationCluster_); ok {
		return x.DestinationCluster
	}
	return nil
}

func (m *RateLimit_Action) GetRequestHeaders() *RateLimit_Action_RequestHeaders {
	if x, ok := m.GetActionSpecifier().(*RateLimit_Action_RequestHeaders_); ok {
		return x.RequestHeaders
	}
	return nil
}

func (m *RateLimit_Action) GetRemoteAddress() *RateLimit_Action_RemoteAddress {
	if x, ok := m.GetActionSpecifier().(*RateLimit_Action_RemoteAddress_); ok {
		return x.RemoteAddress
	}
	return nil
}

func (m *RateLimit_Action) GetGenericKey() *RateLimit_Action_GenericKey {
	if x, ok := m.GetActionSpecifier().(*RateLimit_Action_GenericKey_); ok {
		return x.GenericKey
	}
	return nil
}

func (m *RateLimit_Action) GetHeaderValueMatch() *RateLimit_Action_HeaderValueMatch {
	if x, ok := m.GetActionSpecifier().(*RateLimit_Action_HeaderValueMatch_); ok {
		return x.HeaderValueMatch
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*RateLimit_Action) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*RateLimit_Action_SourceCluster_)(nil),
		(*RateLimit_Action_DestinationCluster_)(nil),
		(*RateLimit_Action_RequestHeaders_)(nil),
		(*RateLimit_Action_RemoteAddress_)(nil),
		(*RateLimit_Action_GenericKey_)(nil),
		(*RateLimit_Action_HeaderValueMatch_)(nil),
	}
}

// The following descriptor entry is appended to the descriptor:
//
// .. code-block:: cpp
//
//   ("source_cluster", "<local service cluster>")
//
// <local service cluster> is derived from the :option:`--service-cluster` option.
type RateLimit_Action_SourceCluster struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RateLimit_Action_SourceCluster) Reset()         { *m = RateLimit_Action_SourceCluster{} }
func (m *RateLimit_Action_SourceCluster) String() string { return proto.CompactTextString(m) }
func (*RateLimit_Action_SourceCluster) ProtoMessage()    {}
func (*RateLimit_Action_SourceCluster) Descriptor() ([]byte, []int) {
	return fileDescriptor_3f3197b7daaf8719, []int{13, 0, 0}
}
func (m *RateLimit_Action_SourceCluster) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RateLimit_Action_SourceCluster) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RateLimit_Action_SourceCluster.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RateLimit_Action_SourceCluster) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RateLimit_Action_SourceCluster.Merge(m, src)
}
func (m *RateLimit_Action_SourceCluster) XXX_Size() int {
	return m.Size()
}
func (m *RateLimit_Action_SourceCluster) XXX_DiscardUnknown() {
	xxx_messageInfo_RateLimit_Action_SourceCluster.DiscardUnknown(m)
}

var xxx_messageInfo_RateLimit_Action_SourceCluster proto.InternalMessageInfo

// The following descriptor entry is appended to the descriptor:
//
// .. code-block:: cpp
//
//   ("destination_cluster", "<routed target cluster>")
//
// Once a request matches against a route table rule, a routed cluster is determined by one of
// the following :ref:`route table configuration <envoy_api_msg_api.v3alpha.RouteConfiguration>`
// settings:
//
// * :ref:`cluster <envoy_api_field_api.v3alpha.route.RouteAction.cluster>` indicates the
// upstream cluster
//   to route to.
// * :ref:`weighted_clusters <envoy_api_field_api.v3alpha.route.RouteAction.weighted_clusters>`
//   chooses a cluster randomly from a set of clusters with attributed weight.
// * :ref:`cluster_header <envoy_api_field_api.v3alpha.route.RouteAction.cluster_header>`
// indicates which
//   header in the request contains the target cluster.
type RateLimit_Action_DestinationCluster struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RateLimit_Action_DestinationCluster) Reset()         { *m = RateLimit_Action_DestinationCluster{} }
func (m *RateLimit_Action_DestinationCluster) String() string { return proto.CompactTextString(m) }
func (*RateLimit_Action_DestinationCluster) ProtoMessage()    {}
func (*RateLimit_Action_DestinationCluster) Descriptor() ([]byte, []int) {
	return fileDescriptor_3f3197b7daaf8719, []int{13, 0, 1}
}
func (m *RateLimit_Action_DestinationCluster) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RateLimit_Action_DestinationCluster) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RateLimit_Action_DestinationCluster.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RateLimit_Action_DestinationCluster) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RateLimit_Action_DestinationCluster.Merge(m, src)
}
func (m *RateLimit_Action_DestinationCluster) XXX_Size() int {
	return m.Size()
}
func (m *RateLimit_Action_DestinationCluster) XXX_DiscardUnknown() {
	xxx_messageInfo_RateLimit_Action_DestinationCluster.DiscardUnknown(m)
}

var xxx_messageInfo_RateLimit_Action_DestinationCluster proto.InternalMessageInfo

// The following descriptor entry is appended when a header contains a key that matches the
// *header_name*:
//
// .. code-block:: cpp
//
//   ("<descriptor_key>", "<header_value_queried_from_header>")
type RateLimit_Action_RequestHeaders struct {
	// The header name to be queried from the request headers. The header’s
	// value is used to populate the value of the descriptor entry for the
	// descriptor_key.
	HeaderName string `protobuf:"bytes,1,opt,name=header_name,json=headerName,proto3" json:"header_name,omitempty"`
	// The key to use in the descriptor entry.
	DescriptorKey        string   `protobuf:"bytes,2,opt,name=descriptor_key,json=descriptorKey,proto3" json:"descriptor_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RateLimit_Action_RequestHeaders) Reset()         { *m = RateLimit_Action_RequestHeaders{} }
func (m *RateLimit_Action_RequestHeaders) String() string { return proto.CompactTextString(m) }
func (*RateLimit_Action_RequestHeaders) ProtoMessage()    {}
func (*RateLimit_Action_RequestHeaders) Descriptor() ([]byte, []int) {
	return fileDescriptor_3f3197b7daaf8719, []int{13, 0, 2}
}
func (m *RateLimit_Action_RequestHeaders) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RateLimit_Action_RequestHeaders) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RateLimit_Action_RequestHeaders.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RateLimit_Action_RequestHeaders) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RateLimit_Action_RequestHeaders.Merge(m, src)
}
func (m *RateLimit_Action_RequestHeaders) XXX_Size() int {
	return m.Size()
}
func (m *RateLimit_Action_RequestHeaders) XXX_DiscardUnknown() {
	xxx_messageInfo_RateLimit_Action_RequestHeaders.DiscardUnknown(m)
}

var xxx_messageInfo_RateLimit_Action_RequestHeaders proto.InternalMessageInfo

func (m *RateLimit_Action_RequestHeaders) GetHeaderName() string {
	if m != nil {
		return m.HeaderName
	}
	return ""
}

func (m *RateLimit_Action_RequestHeaders) GetDescriptorKey() string {
	if m != nil {
		return m.DescriptorKey
	}
	return ""
}

// The following descriptor entry is appended to the descriptor and is populated using the
// trusted address from :ref:`x-forwarded-for <config_http_conn_man_headers_x-forwarded-for>`:
//
// .. code-block:: cpp
//
//   ("remote_address", "<trusted address from x-forwarded-for>")
type RateLimit_Action_RemoteAddress struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RateLimit_Action_RemoteAddress) Reset()         { *m = RateLimit_Action_RemoteAddress{} }
func (m *RateLimit_Action_RemoteAddress) String() string { return proto.CompactTextString(m) }
func (*RateLimit_Action_RemoteAddress) ProtoMessage()    {}
func (*RateLimit_Action_RemoteAddress) Descriptor() ([]byte, []int) {
	return fileDescriptor_3f3197b7daaf8719, []int{13, 0, 3}
}
func (m *RateLimit_Action_RemoteAddress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RateLimit_Action_RemoteAddress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RateLimit_Action_RemoteAddress.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RateLimit_Action_RemoteAddress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RateLimit_Action_RemoteAddress.Merge(m, src)
}
func (m *RateLimit_Action_RemoteAddress) XXX_Size() int {
	return m.Size()
}
func (m *RateLimit_Action_RemoteAddress) XXX_DiscardUnknown() {
	xxx_messageInfo_RateLimit_Action_RemoteAddress.DiscardUnknown(m)
}

var xxx_messageInfo_RateLimit_Action_RemoteAddress proto.InternalMessageInfo

// The following descriptor entry is appended to the descriptor:
//
// .. code-block:: cpp
//
//   ("generic_key", "<descriptor_value>")
type RateLimit_Action_GenericKey struct {
	// The value to use in the descriptor entry.
	DescriptorValue      string   `protobuf:"bytes,1,opt,name=descriptor_value,json=descriptorValue,proto3" json:"descriptor_value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RateLimit_Action_GenericKey) Reset()         { *m = RateLimit_Action_GenericKey{} }
func (m *RateLimit_Action_GenericKey) String() string { return proto.CompactTextString(m) }
func (*RateLimit_Action_GenericKey) ProtoMessage()    {}
func (*RateLimit_Action_GenericKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_3f3197b7daaf8719, []int{13, 0, 4}
}
func (m *RateLimit_Action_GenericKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RateLimit_Action_GenericKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RateLimit_Action_GenericKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RateLimit_Action_GenericKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RateLimit_Action_GenericKey.Merge(m, src)
}
func (m *RateLimit_Action_GenericKey) XXX_Size() int {
	return m.Size()
}
func (m *RateLimit_Action_GenericKey) XXX_DiscardUnknown() {
	xxx_messageInfo_RateLimit_Action_GenericKey.DiscardUnknown(m)
}

var xxx_messageInfo_RateLimit_Action_GenericKey proto.InternalMessageInfo

func (m *RateLimit_Action_GenericKey) GetDescriptorValue() string {
	if m != nil {
		return m.DescriptorValue
	}
	return ""
}

// The following descriptor entry is appended to the descriptor:
//
// .. code-block:: cpp
//
//   ("header_match", "<descriptor_value>")
type RateLimit_Action_HeaderValueMatch struct {
	// The value to use in the descriptor entry.
	DescriptorValue string `protobuf:"bytes,1,opt,name=descriptor_value,json=descriptorValue,proto3" json:"descriptor_value,omitempty"`
	// If set to true, the action will append a descriptor entry when the
	// request matches the headers. If set to false, the action will append a
	// descriptor entry when the request does not match the headers. The
	// default value is true.
	ExpectMatch *types.BoolValue `protobuf:"bytes,2,opt,name=expect_match,json=expectMatch,proto3" json:"expect_match,omitempty"`
	// Specifies a set of headers that the rate limit action should match
	// on. The action will check the request’s headers against all the
	// specified headers in the config. A match will happen if all the
	// headers in the config are present in the request with the same values
	// (or based on presence if the value field is not in the config).
	Headers              []*HeaderMatcher `protobuf:"bytes,3,rep,name=headers,proto3" json:"headers,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *RateLimit_Action_HeaderValueMatch) Reset()         { *m = RateLimit_Action_HeaderValueMatch{} }
func (m *RateLimit_Action_HeaderValueMatch) String() string { return proto.CompactTextString(m) }
func (*RateLimit_Action_HeaderValueMatch) ProtoMessage()    {}
func (*RateLimit_Action_HeaderValueMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_3f3197b7daaf8719, []int{13, 0, 5}
}
func (m *RateLimit_Action_HeaderValueMatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RateLimit_Action_HeaderValueMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RateLimit_Action_HeaderValueMatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RateLimit_Action_HeaderValueMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RateLimit_Action_HeaderValueMatch.Merge(m, src)
}
func (m *RateLimit_Action_HeaderValueMatch) XXX_Size() int {
	return m.Size()
}
func (m *RateLimit_Action_HeaderValueMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_RateLimit_Action_HeaderValueMatch.DiscardUnknown(m)
}

var xxx_messageInfo_RateLimit_Action_HeaderValueMatch proto.InternalMessageInfo

func (m *RateLimit_Action_HeaderValueMatch) GetDescriptorValue() string {
	if m != nil {
		return m.DescriptorValue
	}
	return ""
}

func (m *RateLimit_Action_HeaderValueMatch) GetExpectMatch() *types.BoolValue {
	if m != nil {
		return m.ExpectMatch
	}
	return nil
}

func (m *RateLimit_Action_HeaderValueMatch) GetHeaders() []*HeaderMatcher {
	if m != nil {
		return m.Headers
	}
	return nil
}

// .. attention::
//
//   Internally, Envoy always uses the HTTP/2 *:authority* header to represent the HTTP/1 *Host*
//   header. Thus, if attempting to match on *Host*, match on *:authority* instead.
//
// .. attention::
//
//   To route on HTTP method, use the special HTTP/2 *:method* header. This works for both
//   HTTP/1 and HTTP/2 as Envoy normalizes headers. E.g.,
//
//   .. code-block:: json
//
//     {
//       "name": ":method",
//       "exact_match": "POST"
//     }
//
// .. attention::
//   In the absence of any header match specifier, match will default to :ref:`present_match
//   <envoy_api_field_api.v3alpha.route.HeaderMatcher.present_match>`. i.e, a request that has the
//   :ref:`name <envoy_api_field_api.v3alpha.route.HeaderMatcher.name>` header will match,
//   regardless of the header's value.
//
//  [#next-major-version: HeaderMatcher should be refactored to use StringMatcher.]
// [#next-free-field: 12]
type HeaderMatcher struct {
	// Specifies the name of the header in the request.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Specifies how the header match will be performed to route the request.
	//
	// Types that are valid to be assigned to HeaderMatchSpecifier:
	//	*HeaderMatcher_ExactMatch
	//	*HeaderMatcher_SafeRegexMatch
	//	*HeaderMatcher_RangeMatch
	//	*HeaderMatcher_PresentMatch
	//	*HeaderMatcher_PrefixMatch
	//	*HeaderMatcher_SuffixMatch
	HeaderMatchSpecifier isHeaderMatcher_HeaderMatchSpecifier `protobuf_oneof:"header_match_specifier"`
	// If specified, the match result will be inverted before checking. Defaults to false.
	//
	// Examples:
	//
	// * The regex ``\d{3}`` does not match the value *1234*, so it will match when inverted.
	// * The range [-10,0) will match the value -1, so it will not match when inverted.
	InvertMatch          bool     `protobuf:"varint,8,opt,name=invert_match,json=invertMatch,proto3" json:"invert_match,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HeaderMatcher) Reset()         { *m = HeaderMatcher{} }
func (m *HeaderMatcher) String() string { return proto.CompactTextString(m) }
func (*HeaderMatcher) ProtoMessage()    {}
func (*HeaderMatcher) Descriptor() ([]byte, []int) {
	return fileDescriptor_3f3197b7daaf8719, []int{14}
}
func (m *HeaderMatcher) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HeaderMatcher) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HeaderMatcher.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HeaderMatcher) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeaderMatcher.Merge(m, src)
}
func (m *HeaderMatcher) XXX_Size() int {
	return m.Size()
}
func (m *HeaderMatcher) XXX_DiscardUnknown() {
	xxx_messageInfo_HeaderMatcher.DiscardUnknown(m)
}

var xxx_messageInfo_HeaderMatcher proto.InternalMessageInfo

type isHeaderMatcher_HeaderMatchSpecifier interface {
	isHeaderMatcher_HeaderMatchSpecifier()
	MarshalTo([]byte) (int, error)
	Size() int
}

type HeaderMatcher_ExactMatch struct {
	ExactMatch string `protobuf:"bytes,4,opt,name=exact_match,json=exactMatch,proto3,oneof"`
}
type HeaderMatcher_SafeRegexMatch struct {
	SafeRegexMatch *v3alpha.RegexMatcher `protobuf:"bytes,11,opt,name=safe_regex_match,json=safeRegexMatch,proto3,oneof"`
}
type HeaderMatcher_RangeMatch struct {
	RangeMatch *v3alpha1.Int64Range `protobuf:"bytes,6,opt,name=range_match,json=rangeMatch,proto3,oneof"`
}
type HeaderMatcher_PresentMatch struct {
	PresentMatch bool `protobuf:"varint,7,opt,name=present_match,json=presentMatch,proto3,oneof"`
}
type HeaderMatcher_PrefixMatch struct {
	PrefixMatch string `protobuf:"bytes,9,opt,name=prefix_match,json=prefixMatch,proto3,oneof"`
}
type HeaderMatcher_SuffixMatch struct {
	SuffixMatch string `protobuf:"bytes,10,opt,name=suffix_match,json=suffixMatch,proto3,oneof"`
}

func (*HeaderMatcher_ExactMatch) isHeaderMatcher_HeaderMatchSpecifier()     {}
func (*HeaderMatcher_SafeRegexMatch) isHeaderMatcher_HeaderMatchSpecifier() {}
func (*HeaderMatcher_RangeMatch) isHeaderMatcher_HeaderMatchSpecifier()     {}
func (*HeaderMatcher_PresentMatch) isHeaderMatcher_HeaderMatchSpecifier()   {}
func (*HeaderMatcher_PrefixMatch) isHeaderMatcher_HeaderMatchSpecifier()    {}
func (*HeaderMatcher_SuffixMatch) isHeaderMatcher_HeaderMatchSpecifier()    {}

func (m *HeaderMatcher) GetHeaderMatchSpecifier() isHeaderMatcher_HeaderMatchSpecifier {
	if m != nil {
		return m.HeaderMatchSpecifier
	}
	return nil
}

func (m *HeaderMatcher) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *HeaderMatcher) GetExactMatch() string {
	if x, ok := m.GetHeaderMatchSpecifier().(*HeaderMatcher_ExactMatch); ok {
		return x.ExactMatch
	}
	return ""
}

func (m *HeaderMatcher) GetSafeRegexMatch() *v3alpha.RegexMatcher {
	if x, ok := m.GetHeaderMatchSpecifier().(*HeaderMatcher_SafeRegexMatch); ok {
		return x.SafeRegexMatch
	}
	return nil
}

func (m *HeaderMatcher) GetRangeMatch() *v3alpha1.Int64Range {
	if x, ok := m.GetHeaderMatchSpecifier().(*HeaderMatcher_RangeMatch); ok {
		return x.RangeMatch
	}
	return nil
}

func (m *HeaderMatcher) GetPresentMatch() bool {
	if x, ok := m.GetHeaderMatchSpecifier().(*HeaderMatcher_PresentMatch); ok {
		return x.PresentMatch
	}
	return false
}

func (m *HeaderMatcher) GetPrefixMatch() string {
	if x, ok := m.GetHeaderMatchSpecifier().(*HeaderMatcher_PrefixMatch); ok {
		return x.PrefixMatch
	}
	return ""
}

func (m *HeaderMatcher) GetSuffixMatch() string {
	if x, ok := m.GetHeaderMatchSpecifier().(*HeaderMatcher_SuffixMatch); ok {
		return x.SuffixMatch
	}
	return ""
}

func (m *HeaderMatcher) GetInvertMatch() bool {
	if m != nil {
		return m.InvertMatch
	}
	return false
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*HeaderMatcher) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*HeaderMatcher_ExactMatch)(nil),
		(*HeaderMatcher_SafeRegexMatch)(nil),
		(*HeaderMatcher_RangeMatch)(nil),
		(*HeaderMatcher_PresentMatch)(nil),
		(*HeaderMatcher_PrefixMatch)(nil),
		(*HeaderMatcher_SuffixMatch)(nil),
	}
}

// Query parameter matching treats the query string of a request's :path header
// as an ampersand-separated list of keys and/or key=value elements.
// [#next-free-field: 7]
type QueryParameterMatcher struct {
	// Specifies the name of a key that must be present in the requested
	// *path*'s query string.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Types that are valid to be assigned to QueryParameterMatchSpecifier:
	//	*QueryParameterMatcher_StringMatch
	//	*QueryParameterMatcher_PresentMatch
	QueryParameterMatchSpecifier isQueryParameterMatcher_QueryParameterMatchSpecifier `protobuf_oneof:"query_parameter_match_specifier"`
	XXX_NoUnkeyedLiteral         struct{}                                             `json:"-"`
	XXX_unrecognized             []byte                                               `json:"-"`
	XXX_sizecache                int32                                                `json:"-"`
}

func (m *QueryParameterMatcher) Reset()         { *m = QueryParameterMatcher{} }
func (m *QueryParameterMatcher) String() string { return proto.CompactTextString(m) }
func (*QueryParameterMatcher) ProtoMessage()    {}
func (*QueryParameterMatcher) Descriptor() ([]byte, []int) {
	return fileDescriptor_3f3197b7daaf8719, []int{15}
}
func (m *QueryParameterMatcher) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryParameterMatcher) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryParameterMatcher.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryParameterMatcher) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryParameterMatcher.Merge(m, src)
}
func (m *QueryParameterMatcher) XXX_Size() int {
	return m.Size()
}
func (m *QueryParameterMatcher) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryParameterMatcher.DiscardUnknown(m)
}

var xxx_messageInfo_QueryParameterMatcher proto.InternalMessageInfo

type isQueryParameterMatcher_QueryParameterMatchSpecifier interface {
	isQueryParameterMatcher_QueryParameterMatchSpecifier()
	MarshalTo([]byte) (int, error)
	Size() int
}

type QueryParameterMatcher_StringMatch struct {
	StringMatch *v3alpha.StringMatcher `protobuf:"bytes,5,opt,name=string_match,json=stringMatch,proto3,oneof"`
}
type QueryParameterMatcher_PresentMatch struct {
	PresentMatch bool `protobuf:"varint,6,opt,name=present_match,json=presentMatch,proto3,oneof"`
}

func (*QueryParameterMatcher_StringMatch) isQueryParameterMatcher_QueryParameterMatchSpecifier()  {}
func (*QueryParameterMatcher_PresentMatch) isQueryParameterMatcher_QueryParameterMatchSpecifier() {}

func (m *QueryParameterMatcher) GetQueryParameterMatchSpecifier() isQueryParameterMatcher_QueryParameterMatchSpecifier {
	if m != nil {
		return m.QueryParameterMatchSpecifier
	}
	return nil
}

func (m *QueryParameterMatcher) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *QueryParameterMatcher) GetStringMatch() *v3alpha.StringMatcher {
	if x, ok := m.GetQueryParameterMatchSpecifier().(*QueryParameterMatcher_StringMatch); ok {
		return x.StringMatch
	}
	return nil
}

func (m *QueryParameterMatcher) GetPresentMatch() bool {
	if x, ok := m.GetQueryParameterMatchSpecifier().(*QueryParameterMatcher_PresentMatch); ok {
		return x.PresentMatch
	}
	return false
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*QueryParameterMatcher) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*QueryParameterMatcher_StringMatch)(nil),
		(*QueryParameterMatcher_PresentMatch)(nil),
	}
}

func init() {
	proto.RegisterEnum("envoy.api.v3alpha.route.VirtualHost_TlsRequirementType", VirtualHost_TlsRequirementType_name, VirtualHost_TlsRequirementType_value)
	proto.RegisterEnum("envoy.api.v3alpha.route.RouteAction_ClusterNotFoundResponseCode", RouteAction_ClusterNotFoundResponseCode_name, RouteAction_ClusterNotFoundResponseCode_value)
	proto.RegisterEnum("envoy.api.v3alpha.route.RouteAction_InternalRedirectAction", RouteAction_InternalRedirectAction_name, RouteAction_InternalRedirectAction_value)
	proto.RegisterEnum("envoy.api.v3alpha.route.RedirectAction_RedirectResponseCode", RedirectAction_RedirectResponseCode_name, RedirectAction_RedirectResponseCode_value)
	proto.RegisterType((*VirtualHost)(nil), "envoy.api.v3alpha.route.VirtualHost")
	proto.RegisterMapType((map[string]*types.Any)(nil), "envoy.api.v3alpha.route.VirtualHost.TypedPerFilterConfigEntry")
	proto.RegisterType((*Route)(nil), "envoy.api.v3alpha.route.Route")
	proto.RegisterMapType((map[string]*types.Any)(nil), "envoy.api.v3alpha.route.Route.TypedPerFilterConfigEntry")
	proto.RegisterType((*WeightedCluster)(nil), "envoy.api.v3alpha.route.WeightedCluster")
	proto.RegisterType((*WeightedCluster_ClusterWeight)(nil), "envoy.api.v3alpha.route.WeightedCluster.ClusterWeight")
	proto.RegisterMapType((map[string]*types.Any)(nil), "envoy.api.v3alpha.route.WeightedCluster.ClusterWeight.TypedPerFilterConfigEntry")
	proto.RegisterType((*RouteMatch)(nil), "envoy.api.v3alpha.route.RouteMatch")
	proto.RegisterType((*RouteMatch_GrpcRouteMatchOptions)(nil), "envoy.api.v3alpha.route.RouteMatch.GrpcRouteMatchOptions")
	proto.RegisterType((*RouteMatch_TlsContextMatchOptions)(nil), "envoy.api.v3alpha.route.RouteMatch.TlsContextMatchOptions")
	proto.RegisterType((*CorsPolicy)(nil), "envoy.api.v3alpha.route.CorsPolicy")
	proto.RegisterType((*RouteAction)(nil), "envoy.api.v3alpha.route.RouteAction")
	proto.RegisterType((*RouteAction_RequestMirrorPolicy)(nil), "envoy.api.v3alpha.route.RouteAction.RequestMirrorPolicy")
	proto.RegisterType((*RouteAction_HashPolicy)(nil), "envoy.api.v3alpha.route.RouteAction.HashPolicy")
	proto.RegisterType((*RouteAction_HashPolicy_Header)(nil), "envoy.api.v3alpha.route.RouteAction.HashPolicy.Header")
	proto.RegisterType((*RouteAction_HashPolicy_Cookie)(nil), "envoy.api.v3alpha.route.RouteAction.HashPolicy.Cookie")
	proto.RegisterType((*RouteAction_HashPolicy_ConnectionProperties)(nil), "envoy.api.v3alpha.route.RouteAction.HashPolicy.ConnectionProperties")
	proto.RegisterType((*RouteAction_UpgradeConfig)(nil), "envoy.api.v3alpha.route.RouteAction.UpgradeConfig")
	proto.RegisterType((*RetryPolicy)(nil), "envoy.api.v3alpha.route.RetryPolicy")
	proto.RegisterType((*RetryPolicy_RetryPriority)(nil), "envoy.api.v3alpha.route.RetryPolicy.RetryPriority")
	proto.RegisterType((*RetryPolicy_RetryHostPredicate)(nil), "envoy.api.v3alpha.route.RetryPolicy.RetryHostPredicate")
	proto.RegisterType((*RetryPolicy_RetryBackOff)(nil), "envoy.api.v3alpha.route.RetryPolicy.RetryBackOff")
	proto.RegisterType((*HedgePolicy)(nil), "envoy.api.v3alpha.route.HedgePolicy")
	proto.RegisterType((*RedirectAction)(nil), "envoy.api.v3alpha.route.RedirectAction")
	proto.RegisterType((*DirectResponseAction)(nil), "envoy.api.v3alpha.route.DirectResponseAction")
	proto.RegisterType((*Decorator)(nil), "envoy.api.v3alpha.route.Decorator")
	proto.RegisterType((*Tracing)(nil), "envoy.api.v3alpha.route.Tracing")
	proto.RegisterType((*VirtualCluster)(nil), "envoy.api.v3alpha.route.VirtualCluster")
	proto.RegisterType((*RateLimit)(nil), "envoy.api.v3alpha.route.RateLimit")
	proto.RegisterType((*RateLimit_Action)(nil), "envoy.api.v3alpha.route.RateLimit.Action")
	proto.RegisterType((*RateLimit_Action_SourceCluster)(nil), "envoy.api.v3alpha.route.RateLimit.Action.SourceCluster")
	proto.RegisterType((*RateLimit_Action_DestinationCluster)(nil), "envoy.api.v3alpha.route.RateLimit.Action.DestinationCluster")
	proto.RegisterType((*RateLimit_Action_RequestHeaders)(nil), "envoy.api.v3alpha.route.RateLimit.Action.RequestHeaders")
	proto.RegisterType((*RateLimit_Action_RemoteAddress)(nil), "envoy.api.v3alpha.route.RateLimit.Action.RemoteAddress")
	proto.RegisterType((*RateLimit_Action_GenericKey)(nil), "envoy.api.v3alpha.route.RateLimit.Action.GenericKey")
	proto.RegisterType((*RateLimit_Action_HeaderValueMatch)(nil), "envoy.api.v3alpha.route.RateLimit.Action.HeaderValueMatch")
	proto.RegisterType((*HeaderMatcher)(nil), "envoy.api.v3alpha.route.HeaderMatcher")
	proto.RegisterType((*QueryParameterMatcher)(nil), "envoy.api.v3alpha.route.QueryParameterMatcher")
}

func init() {
	proto.RegisterFile("envoy/api/v3alpha/route/route.proto", fileDescriptor_3f3197b7daaf8719)
}

var fileDescriptor_3f3197b7daaf8719 = []byte{
	// 3950 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x5a, 0xdb, 0x6f, 0x23, 0xc9,
	0x5a, 0x4f, 0xc7, 0x8e, 0x2f, 0x9f, 0x2f, 0xe9, 0xd4, 0x64, 0x12, 0xc7, 0xbb, 0x3b, 0x9b, 0xf1,
	0xec, 0x9c, 0x99, 0x1d, 0x20, 0x73, 0x98, 0x19, 0xcd, 0x5e, 0xce, 0x2c, 0x5a, 0x3b, 0xf1, 0x8e,
	0x93, 0xcd, 0xc5, 0x54, 0x32, 0xb3, 0x3b, 0x67, 0x05, 0x7d, 0x3a, 0xdd, 0x15, 0xbb, 0x19, 0xbb,
	0xbb, 0xb7, 0xba, 0x9c, 0x89, 0xc5, 0x0b, 0x42, 0x02, 0x74, 0x40, 0xe2, 0x61, 0x25, 0xfe, 0x05,
	0x1e, 0xf6, 0x95, 0x17, 0x40, 0x42, 0x3a, 0xe2, 0x01, 0x21, 0x21, 0x24, 0x5e, 0x90, 0x78, 0x44,
	0xfb, 0xc4, 0x79, 0xe5, 0x05, 0x21, 0x78, 0x40, 0x75, 0xe9, 0x6e, 0x5f, 0x63, 0x27, 0xc0, 0x82,
	0xce, 0x4b, 0xe2, 0xae, 0xfa, 0x7d, 0xbf, 0xaa, 0xae, 0xfa, 0xea, 0xab, 0x5f, 0x7d, 0xd5, 0x70,
	0x87, 0xb8, 0xe7, 0x5e, 0xff, 0xa1, 0xe9, 0x3b, 0x0f, 0xcf, 0x1f, 0x9b, 0x1d, 0xbf, 0x6d, 0x3e,
	0xa4, 0x5e, 0x8f, 0x11, 0xf9, 0x77, 0xcb, 0xa7, 0x1e, 0xf3, 0xd0, 0xba, 0x00, 0x6d, 0x99, 0xbe,
	0xb3, 0xa5, 0x40, 0x5b, 0xa2, 0xba, 0x7c, 0x7b, 0xdc, 0xda, 0xf2, 0x28, 0x79, 0x78, 0x6a, 0x06,
	0xca, 0xb6, 0xfc, 0x03, 0x09, 0x61, 0x7d, 0x9f, 0x3c, 0xec, 0x9a, 0xcc, 0x6a, 0x13, 0x1a, 0xb7,
	0x44, 0x5a, 0xe4, 0x42, 0xe1, 0xee, 0x5d, 0x82, 0x0b, 0x18, 0x75, 0xdc, 0x96, 0x02, 0x6e, 0x0e,
	0x00, 0x43, 0x80, 0x4f, 0xa8, 0x45, 0x5c, 0xa6, 0x10, 0xb7, 0x26, 0x20, 0xa8, 0xe9, 0xb6, 0xc2,
	0x2e, 0x6d, 0xb4, 0x3c, 0xaf, 0xd5, 0x21, 0x0f, 0xc5, 0xd3, 0x69, 0xef, 0xec, 0xa1, 0xe9, 0xf6,
	0x43, 0xd3, 0xd1, 0x2a, 0xbb, 0x47, 0x4d, 0xe6, 0x78, 0xae, 0xaa, 0x7f, 0x7b, 0xb4, 0x3e, 0x60,
	0xb4, 0x67, 0xb1, 0x69, 0xd6, 0x6f, 0xa8, 0xe9, 0xfb, 0x84, 0x06, 0xaa, 0x7e, 0xfd, 0xdc, 0xec,
	0x38, 0xb6, 0xc9, 0xc8, 0xc3, 0xf0, 0x87, 0xac, 0xa8, 0xfc, 0x2b, 0x40, 0xee, 0xa5, 0x43, 0x59,
	0xcf, 0xec, 0x34, 0xbc, 0x80, 0xa1, 0x77, 0x20, 0xe9, 0x9a, 0x5d, 0x52, 0xd2, 0x36, 0xb5, 0xfb,
	0xd9, 0x5a, 0xf6, 0x2f, 0x7f, 0xfe, 0xb3, 0x44, 0x92, 0x2e, 0x6e, 0x6a, 0x58, 0x14, 0xa3, 0xf7,
	0x20, 0x6d, 0x7b, 0x5d, 0xd3, 0x71, 0x83, 0xd2, 0xe2, 0x66, 0xe2, 0x7e, 0xb6, 0x06, 0x1c, 0xb1,
	0xf4, 0x8d, 0xb6, 0x98, 0xd1, 0x70, 0x58, 0x85, 0x9e, 0x42, 0x4a, 0xcc, 0x52, 0x50, 0x4a, 0x6c,
	0x26, 0xee, 0xe7, 0x1e, 0xdd, 0xda, 0x9a, 0x32, 0x8d, 0x5b, 0x98, 0xff, 0xc5, 0x0a, 0x8d, 0xbe,
	0x84, 0x1c, 0x25, 0x5f, 0xf7, 0x1c, 0x4a, 0x0c, 0xd6, 0x09, 0x4a, 0xc9, 0x4d, 0xed, 0x7e, 0xf1,
	0xd1, 0x07, 0x53, 0x8d, 0x07, 0xfa, 0xbd, 0x75, 0xd2, 0x09, 0xb0, 0x34, 0xed, 0x12, 0x97, 0x9d,
	0xf4, 0x7d, 0x82, 0x41, 0x71, 0x9d, 0x74, 0x02, 0x84, 0x41, 0x3f, 0x97, 0x68, 0xc3, 0xea, 0xf4,
	0x02, 0x46, 0x68, 0x50, 0x5a, 0x12, 0x7d, 0xbb, 0x37, 0x8b, 0x7e, 0x5b, 0xe2, 0xf1, 0xf2, 0xf9,
	0xd0, 0x73, 0x80, 0xb6, 0x21, 0x47, 0x4d, 0x46, 0x8c, 0x8e, 0xd3, 0x75, 0x58, 0x50, 0x4a, 0x09,
	0xba, 0xca, 0xf4, 0x57, 0x35, 0x19, 0xd9, 0xe7, 0x50, 0x0c, 0x34, 0xfc, 0x19, 0xa0, 0xd7, 0xb0,
	0xc6, 0xbb, 0x49, 0x02, 0x66, 0xb4, 0x89, 0x69, 0x13, 0x1a, 0x18, 0xcc, 0x33, 0x4c, 0xdb, 0x2e,
	0xa5, 0x05, 0xdf, 0xfb, 0x13, 0xf8, 0xb8, 0xa3, 0x6f, 0x35, 0x04, 0xfa, 0xa5, 0xd9, 0xe9, 0x91,
	0x23, 0x9f, 0xfb, 0x49, 0x2d, 0xc7, 0xa7, 0x22, 0xf5, 0x8d, 0x96, 0xd0, 0xff, 0x25, 0x8d, 0x6f,
	0x28, 0x56, 0x09, 0x0b, 0x4e, 0xbc, 0xaa, 0x6d, 0xa3, 0x8f, 0x60, 0x63, 0x42, 0x63, 0x94, 0x74,
	0xbd, 0x73, 0x52, 0x2a, 0xf0, 0xf9, 0xc4, 0x6b, 0xa3, 0x76, 0x58, 0xd4, 0xa2, 0x2e, 0xac, 0x53,
	0x12, 0xf8, 0x9e, 0x1b, 0x90, 0xd1, 0x8e, 0xc2, 0x7f, 0xab, 0xa3, 0xab, 0x21, 0xed, 0x50, 0x4f,
	0x7f, 0x04, 0xe5, 0x49, 0xcd, 0xa9, 0xae, 0xe6, 0x44, 0x57, 0xd7, 0xc7, 0x2c, 0x55, 0x5f, 0x3f,
	0x80, 0xa4, 0xe5, 0xd1, 0xa0, 0x94, 0xd9, 0xd4, 0xee, 0xe7, 0x1e, 0xdd, 0x99, 0x3a, 0x23, 0xdb,
	0x1e, 0x0d, 0x9a, 0x5e, 0xc7, 0xb1, 0xfa, 0x58, 0x18, 0xa0, 0x1e, 0xac, 0xf3, 0xa5, 0x6b, 0x1b,
	0x3e, 0xa1, 0xc6, 0x99, 0xd3, 0x61, 0x84, 0x1a, 0x96, 0xe7, 0x9e, 0x39, 0xad, 0xd2, 0xb2, 0x78,
	0xc9, 0x5f, 0x9b, 0xcf, 0x17, 0x39, 0x47, 0x93, 0xd0, 0xcf, 0x04, 0xc3, 0xb6, 0x20, 0xa8, 0xbb,
	0x8c, 0xf6, 0xf1, 0x2a, 0x9b, 0x50, 0x85, 0xaa, 0xf0, 0x8e, 0xe3, 0x5a, 0x9d, 0x9e, 0x4d, 0x8c,
	0x70, 0x7a, 0x4c, 0xc6, 0x48, 0xd7, 0x67, 0x86, 0xe5, 0xf5, 0x5c, 0x56, 0x2a, 0x6e, 0x6a, 0xf7,
	0x33, 0xb8, 0xac, 0x40, 0x58, 0x62, 0xaa, 0x12, 0xb2, 0xcd, 0x11, 0xe8, 0x39, 0xe4, 0x29, 0x61,
	0xb4, 0x6f, 0xf8, 0xe2, 0x7d, 0x4a, 0xba, 0x78, 0xf5, 0xf7, 0xa6, 0x3b, 0x23, 0x07, 0xab, 0x77,
	0xcf, 0xd1, 0xf8, 0x81, 0x13, 0xb5, 0x89, 0xdd, 0x22, 0x21, 0xd1, 0xca, 0x0c, 0xa2, 0x06, 0x07,
	0x87, 0x44, 0xed, 0xf8, 0x01, 0xfd, 0x04, 0x6e, 0xf1, 0x51, 0x0c, 0x5f, 0xe8, 0xb4, 0x77, 0x76,
	0x46, 0xa8, 0x5c, 0x2b, 0xc6, 0x69, 0x9f, 0xc7, 0x06, 0x24, 0xa8, 0xdf, 0xde, 0x92, 0xa1, 0x6b,
	0x2b, 0x0c, 0x5d, 0x5b, 0x2f, 0x76, 0x5d, 0xf6, 0xf8, 0x91, 0x70, 0x18, 0x5c, 0xf6, 0x09, 0x55,
	0xef, 0x5b, 0x13, 0x0c, 0x62, 0xd9, 0xd4, 0xb8, 0x7d, 0xf9, 0x37, 0x60, 0x63, 0xea, 0x48, 0x23,
	0x1d, 0x12, 0xaf, 0x49, 0x5f, 0x86, 0x31, 0xcc, 0x7f, 0xa2, 0x07, 0xb0, 0x74, 0xce, 0x39, 0x4b,
	0x8b, 0xa2, 0xdd, 0xd5, 0xb1, 0x76, 0xab, 0x6e, 0x1f, 0x4b, 0xc8, 0xc7, 0x8b, 0x1f, 0x6a, 0x95,
	0x8f, 0x01, 0x8d, 0x07, 0x15, 0x94, 0x81, 0xe4, 0xe1, 0xd1, 0x61, 0x5d, 0x5f, 0x40, 0x2b, 0x50,
	0xa8, 0x7f, 0x79, 0x52, 0xc7, 0x87, 0xd5, 0x7d, 0xe3, 0xe8, 0x70, 0xff, 0x95, 0xae, 0xa1, 0x34,
	0x24, 0xaa, 0xfb, 0xfb, 0xfa, 0xe2, 0x5e, 0x32, 0x93, 0xd5, 0x61, 0x2f, 0x99, 0xc9, 0xeb, 0x05,
	0xbc, 0x32, 0xe6, 0x4c, 0x95, 0x3f, 0xcb, 0xc2, 0x92, 0x88, 0x7c, 0x08, 0xa9, 0x70, 0x5b, 0x14,
	0xfd, 0x94, 0x31, 0xb6, 0x0e, 0x4b, 0x62, 0x1b, 0x12, 0x9d, 0xbf, 0xcc, 0x7f, 0x05, 0xc5, 0x01,
	0x87, 0xaa, 0x30, 0xfc, 0x87, 0xda, 0xa2, 0xae, 0x61, 0x69, 0x8d, 0x9e, 0xc1, 0x92, 0x80, 0xa9,
	0xf7, 0x7d, 0xef, 0x72, 0x9a, 0xaa, 0xc5, 0x97, 0x66, 0x63, 0x01, 0x4b, 0x23, 0x54, 0x87, 0x0c,
	0x25, 0xb6, 0x43, 0x89, 0xc5, 0x4a, 0x09, 0x41, 0x70, 0xef, 0x12, 0x67, 0x92, 0xc0, 0x88, 0x23,
	0x32, 0x45, 0x5f, 0xc2, 0xb2, 0xfc, 0x65, 0x84, 0x8b, 0xb5, 0x94, 0x16, 0x6c, 0xbf, 0x32, 0x95,
	0x6d, 0x47, 0xe0, 0xb1, 0x82, 0x47, 0x9c, 0x45, 0x7b, 0xa8, 0x1c, 0x3d, 0x83, 0x4c, 0x97, 0x30,
	0xd3, 0x36, 0x99, 0x29, 0x36, 0x8a, 0xdc, 0xa3, 0xcd, 0x69, 0x11, 0xe8, 0x40, 0xe1, 0x70, 0x64,
	0x81, 0x3e, 0x85, 0xac, 0x4d, 0x2c, 0x8f, 0x9a, 0xcc, 0xa3, 0xa5, 0x25, 0x61, 0x3e, 0x3d, 0x72,
	0xef, 0x84, 0x48, 0x1c, 0x1b, 0x21, 0x6f, 0x7a, 0xac, 0x28, 0x88, 0x58, 0xf1, 0xe1, 0xe5, 0x03,
	0x7e, 0xe5, 0x28, 0x31, 0x7d, 0xa7, 0xc8, 0x7e, 0xcf, 0x3b, 0x45, 0xfe, 0x17, 0x66, 0xa7, 0xf8,
	0x18, 0xd2, 0x8c, 0x9a, 0x96, 0xe3, 0xf2, 0x00, 0x3f, 0xcd, 0x87, 0xe4, 0xa4, 0x9d, 0x48, 0x1c,
	0x0e, 0x0d, 0xe6, 0x08, 0x70, 0xfa, 0xff, 0xeb, 0x00, 0x57, 0x5b, 0x86, 0x94, 0x29, 0x56, 0x17,
	0x5a, 0xfa, 0xf3, 0x9f, 0xff, 0x2c, 0xa1, 0xed, 0x25, 0x33, 0x29, 0x3d, 0xbd, 0x97, 0xcc, 0x64,
	0xf4, 0xec, 0xa4, 0xa8, 0xf5, 0x6f, 0x69, 0x58, 0xfe, 0x82, 0x38, 0xad, 0x36, 0x23, 0xb6, 0x12,
	0x41, 0xe8, 0x37, 0x21, 0x13, 0xe9, 0x29, 0x4d, 0xcc, 0xee, 0xd3, 0xa9, 0x23, 0x38, 0x62, 0xbb,
	0xa5, 0xfe, 0xcb, 0xe2, 0x21, 0x21, 0x19, 0x71, 0xa2, 0x3d, 0xc8, 0x33, 0x8f, 0x99, 0x1d, 0xe3,
	0x8d, 0x40, 0xa9, 0x50, 0x74, 0xe9, 0x90, 0x2a, 0xd1, 0xfa, 0x60, 0xf1, 0xbe, 0x86, 0x73, 0xc2,
	0x58, 0xb6, 0x80, 0x7e, 0x19, 0x10, 0xed, 0xb9, 0xcc, 0xe9, 0x12, 0xe3, 0x35, 0xe9, 0x1b, 0x3e,
	0x25, 0x67, 0xce, 0x85, 0x18, 0xac, 0x2c, 0xd6, 0x55, 0xcd, 0xe7, 0xa4, 0xdf, 0x14, 0xe5, 0xe5,
	0x9f, 0xa6, 0xa0, 0x30, 0xd4, 0xc3, 0x59, 0xd2, 0xf8, 0x09, 0xa4, 0x54, 0x27, 0x17, 0xe7, 0x98,
	0x77, 0x85, 0x45, 0xcf, 0xa1, 0x18, 0x06, 0x25, 0x43, 0x46, 0xfd, 0xc4, 0x9c, 0xc1, 0xac, 0x10,
	0xda, 0x89, 0x1d, 0xe0, 0x92, 0xf0, 0x90, 0xfc, 0x9e, 0xc3, 0x43, 0xf6, 0xba, 0xe1, 0x61, 0xe9,
	0x7b, 0x0f, 0x0f, 0xa9, 0xcb, 0xc3, 0xc3, 0x1f, 0x68, 0xd3, 0x83, 0xbc, 0x8c, 0x65, 0xcd, 0xeb,
	0x79, 0xfb, 0x55, 0x83, 0xff, 0xff, 0x72, 0x28, 0xd8, 0x4b, 0x66, 0xd2, 0x7a, 0x66, 0xfa, 0xca,
	0xff, 0x93, 0x14, 0x40, 0x2c, 0x36, 0x50, 0x09, 0x52, 0x6a, 0xf1, 0x88, 0x26, 0x1b, 0x0b, 0x58,
	0x3d, 0xa3, 0x55, 0x48, 0xfa, 0x26, 0x6b, 0xcb, 0x45, 0xd5, 0x58, 0xc0, 0xe2, 0x09, 0xbd, 0x00,
	0x08, 0xcc, 0x33, 0x2e, 0x6e, 0x5b, 0xe4, 0xa2, 0x04, 0xa2, 0x4b, 0xf7, 0xd5, 0xc0, 0xf1, 0xb7,
	0xdd, 0x52, 0xa7, 0xee, 0x68, 0x04, 0x31, 0x07, 0x1e, 0xc8, 0xc2, 0x41, 0x69, 0xd3, 0x58, 0xc0,
	0x59, 0xce, 0x24, 0xea, 0x51, 0x15, 0x8a, 0x96, 0x19, 0x10, 0x23, 0x20, 0x6e, 0xe0, 0x30, 0xe7,
	0x9c, 0x28, 0x1d, 0x50, 0x1e, 0x7b, 0xdb, 0x9a, 0xe7, 0x75, 0xe4, 0xb2, 0x2b, 0x70, 0x8b, 0xe3,
	0xd0, 0x00, 0x7d, 0x05, 0xe1, 0xc2, 0x37, 0xce, 0xa8, 0x0c, 0x86, 0xa5, 0xac, 0x20, 0xf9, 0xe1,
	0x34, 0x2f, 0xc4, 0x12, 0xff, 0x99, 0x82, 0x9b, 0x9d, 0xa6, 0xcc, 0x00, 0xe0, 0x65, 0x3a, 0x5c,
	0x83, 0x3e, 0x85, 0xb4, 0xf2, 0x38, 0x75, 0x36, 0xfc, 0xc1, 0x25, 0x2a, 0x9a, 0xe3, 0xd4, 0x1b,
	0xe3, 0xd0, 0x0c, 0xbd, 0x02, 0xfd, 0xeb, 0x1e, 0xe1, 0xaa, 0xde, 0xa4, 0x66, 0x97, 0x88, 0x28,
	0x2b, 0x8f, 0x85, 0x5b, 0x53, 0xa9, 0x7e, 0x9d, 0x1b, 0x34, 0x43, 0x7c, 0x48, 0xb9, 0xfc, 0xf5,
	0x50, 0x71, 0x80, 0x0e, 0x20, 0xd9, 0xa2, 0xbe, 0xa5, 0xce, 0x48, 0x1f, 0xcd, 0xa1, 0x31, 0xb7,
	0x9e, 0x53, 0xdf, 0x8a, 0x1f, 0xe5, 0x12, 0x0c, 0xb0, 0xa0, 0x41, 0x5f, 0x41, 0x8e, 0x75, 0x02,
	0xee, 0x2f, 0x8c, 0x5c, 0xb0, 0x52, 0x4e, 0xb0, 0x7e, 0x3c, 0x0f, 0xeb, 0x49, 0x27, 0xd8, 0x96,
	0x56, 0x43, 0xb4, 0xc0, 0xa2, 0xf2, 0xf2, 0x3a, 0xdc, 0x9c, 0xd8, 0x76, 0x19, 0xc3, 0xda, 0x64,
	0x73, 0xf4, 0x21, 0x64, 0x7d, 0x4a, 0x02, 0xe2, 0x32, 0x62, 0x2b, 0x1d, 0x7d, 0x99, 0x5b, 0xc4,
	0xe0, 0xda, 0x3a, 0x14, 0xb9, 0xd3, 0x1a, 0x81, 0x4f, 0x2c, 0xe7, 0xcc, 0x21, 0x34, 0xde, 0x1d,
	0x97, 0xf4, 0xd4, 0x5e, 0x32, 0x93, 0xd0, 0x93, 0x78, 0x49, 0xb8, 0x72, 0xe5, 0xef, 0x92, 0x00,
	0xf1, 0x21, 0x12, 0xd9, 0xb0, 0x61, 0x76, 0x3a, 0xde, 0x1b, 0xc3, 0xa3, 0x4e, 0xcb, 0x71, 0x0d,
	0x99, 0x3c, 0x52, 0x61, 0x3d, 0x37, 0x14, 0xdc, 0x26, 0xba, 0xfd, 0xb1, 0xc0, 0x87, 0x53, 0xb6,
	0x26, 0xb8, 0x8e, 0x04, 0xd5, 0x40, 0x0d, 0xba, 0x03, 0x05, 0xd9, 0x4a, 0x97, 0xb0, 0xb6, 0x67,
	0x07, 0x6a, 0x07, 0xcb, 0x8b, 0xc2, 0x03, 0x59, 0x16, 0x83, 0x42, 0x0f, 0x4c, 0x0c, 0x80, 0x54,
	0x98, 0x43, 0x77, 0xa1, 0x48, 0x2e, 0x7c, 0x2f, 0x8e, 0x8c, 0x62, 0x01, 0x65, 0x71, 0x41, 0x96,
	0x86, 0xb0, 0x75, 0x48, 0x77, 0xcd, 0x0b, 0xc3, 0x6c, 0x11, 0xa1, 0x94, 0xb3, 0x38, 0xd5, 0x35,
	0x2f, 0xaa, 0x2d, 0x82, 0x9e, 0xc3, 0x8a, 0x6c, 0xc4, 0xa2, 0xc4, 0x26, 0x2e, 0x73, 0xcc, 0x0e,
	0x77, 0xf5, 0x59, 0x83, 0xad, 0x0b, 0xa3, 0xed, 0xd8, 0x06, 0xbd, 0x82, 0xa2, 0x0a, 0x38, 0xc4,
	0x35, 0x4f, 0x3b, 0xc4, 0xbe, 0xee, 0x22, 0x6c, 0x2c, 0xe0, 0x82, 0x64, 0xaa, 0x4b, 0x22, 0xf4,
	0x05, 0x14, 0x83, 0xb6, 0x69, 0x7b, 0x6f, 0x22, 0x6a, 0xb8, 0xe6, 0xfa, 0x2e, 0x48, 0x1e, 0x45,
	0x5c, 0xbb, 0x01, 0x2b, 0x8a, 0x31, 0x76, 0x95, 0xbd, 0x64, 0x46, 0x13, 0xa7, 0xbf, 0x8c, 0x9e,
	0x95, 0x31, 0x55, 0x8d, 0xb8, 0xf2, 0x08, 0x8c, 0x86, 0xfc, 0x43, 0x38, 0x11, 0x4e, 0x2b, 0x9a,
	0xca, 0x4f, 0xd7, 0x20, 0x37, 0x70, 0x16, 0x43, 0x77, 0x21, 0xad, 0x74, 0xd0, 0x98, 0xe4, 0x68,
	0x2c, 0xe0, 0xb0, 0x0e, 0x3d, 0x82, 0xa2, 0xfa, 0xa9, 0xa6, 0x51, 0x3a, 0xc4, 0x30, 0xba, 0xa0,
	0x20, 0x72, 0x4e, 0xd1, 0x17, 0xb0, 0xf2, 0x46, 0xed, 0x4f, 0x71, 0x3e, 0x2c, 0x31, 0x14, 0x98,
	0x67, 0xee, 0x68, 0x8d, 0x05, 0xac, 0xbf, 0x19, 0x2e, 0x0a, 0xd0, 0x37, 0x1a, 0xbc, 0x1b, 0xf6,
	0xc6, 0xf5, 0x98, 0x71, 0xe6, 0xf5, 0x5c, 0x3b, 0x3a, 0xfb, 0x19, 0x96, 0x67, 0x93, 0xd2, 0xaa,
	0x48, 0xeb, 0x7d, 0x3a, 0xcf, 0x79, 0x34, 0xdc, 0x35, 0x0f, 0x3d, 0xf6, 0x19, 0x67, 0x0a, 0x4f,
	0x7f, 0xdb, 0x9e, 0x4d, 0xd4, 0xc6, 0xf0, 0xbb, 0xe2, 0xcc, 0xfb, 0x96, 0x35, 0x1d, 0x38, 0x41,
	0x63, 0x25, 0xaf, 0xa7, 0xb1, 0xee, 0x42, 0x51, 0x6e, 0x74, 0x06, 0x25, 0x6f, 0xa8, 0xc3, 0xc2,
	0x05, 0x51, 0x90, 0xa5, 0x58, 0x16, 0xa2, 0x3b, 0x90, 0x6f, 0x7b, 0x01, 0x8b, 0x40, 0x29, 0xb1,
	0x1b, 0x6a, 0x38, 0xc7, 0x4b, 0x43, 0x50, 0x03, 0x56, 0xcc, 0x1e, 0xf3, 0x8c, 0x21, 0x64, 0x7a,
	0xd6, 0xe2, 0x69, 0x68, 0x78, 0x99, 0x9b, 0x35, 0x06, 0x98, 0x3e, 0x82, 0xd2, 0x18, 0x53, 0xe8,
	0x0a, 0xef, 0xa8, 0xa6, 0x6f, 0x8e, 0x18, 0x29, 0x3f, 0x78, 0x0c, 0x69, 0xee, 0xec, 0x5e, 0x8f,
	0xa9, 0x8d, 0x60, 0x63, 0xac, 0xe9, 0x1d, 0x95, 0x86, 0xc6, 0x21, 0x12, 0x3d, 0x83, 0xbc, 0x63,
	0x77, 0x88, 0x11, 0x5a, 0x96, 0x66, 0x59, 0xe6, 0x38, 0xfc, 0x44, 0x59, 0x8f, 0x66, 0xaa, 0xb2,
	0xd7, 0xcd, 0x54, 0x75, 0xe0, 0x66, 0xa8, 0x41, 0xbb, 0x0e, 0xa5, 0x1e, 0x0d, 0x19, 0xe5, 0x02,
	0xff, 0x70, 0x2e, 0xff, 0x52, 0x47, 0xaf, 0x03, 0x41, 0xa0, 0x5a, 0x09, 0x15, 0xef, 0x60, 0x21,
	0x3a, 0x82, 0x8c, 0x4f, 0x1d, 0x8f, 0x3a, 0xac, 0x2f, 0x76, 0xb7, 0xe2, 0xc4, 0x7c, 0x88, 0x8c,
	0x20, 0x5e, 0x8f, 0x39, 0x6e, 0xab, 0xa9, 0xe0, 0x43, 0x7e, 0x1a, 0x91, 0x8c, 0x66, 0x8f, 0x0b,
	0xd7, 0xca, 0x1e, 0x1f, 0xc1, 0x5a, 0x98, 0x39, 0x3c, 0x6f, 0x1b, 0x83, 0x7c, 0xc5, 0x99, 0x61,
	0xf8, 0x86, 0xb2, 0x7c, 0xd9, 0xc6, 0x31, 0x61, 0x13, 0x72, 0x6d, 0x33, 0x68, 0x87, 0x43, 0x29,
	0xb3, 0x9e, 0x0f, 0xe7, 0x1a, 0xca, 0x86, 0x19, 0xb4, 0xd5, 0x08, 0x42, 0x3b, 0xfa, 0x1d, 0x25,
	0x63, 0x57, 0xae, 0x9a, 0x8c, 0xdd, 0x06, 0x9d, 0x6f, 0x3b, 0x5c, 0x5e, 0x44, 0xae, 0xb6, 0x3e,
	0xcb, 0xd5, 0x8a, 0x5d, 0xf3, 0x82, 0x6b, 0x85, 0xd0, 0xdb, 0x76, 0xe1, 0xc6, 0x20, 0x81, 0xe1,
	0x9d, 0x9d, 0x05, 0x84, 0x95, 0xde, 0x9e, 0xc5, 0xb3, 0xd2, 0x8a, 0x49, 0x8e, 0x84, 0x0d, 0xfa,
	0x0a, 0x96, 0x7b, 0x7e, 0x8b, 0x9a, 0x36, 0x51, 0xb2, 0x38, 0x28, 0x6d, 0x88, 0xe1, 0x79, 0x34,
	0xd7, 0xf0, 0xbc, 0x90, 0xb6, 0x52, 0xb7, 0xe3, 0x62, 0x6f, 0xf0, 0x31, 0x40, 0x3d, 0x28, 0x39,
	0x2e, 0x23, 0xd4, 0x35, 0x3b, 0x46, 0x98, 0x3c, 0x33, 0x94, 0x20, 0x2d, 0x0b, 0x77, 0xfb, 0xd1,
	0x5c, 0xad, 0xec, 0x2a, 0x92, 0xe1, 0x94, 0x1c, 0x5e, 0x73, 0x26, 0x96, 0x8f, 0x65, 0x7b, 0xdf,
	0xba, 0x66, 0xb6, 0xb7, 0xfc, 0xad, 0x06, 0x37, 0x26, 0xac, 0x25, 0x74, 0x67, 0xfa, 0x1e, 0x16,
	0xef, 0x60, 0x93, 0x54, 0x78, 0xe2, 0x7f, 0x48, 0x85, 0xef, 0x25, 0x33, 0x8b, 0x7a, 0x02, 0xe7,
	0x06, 0x4e, 0xfe, 0xe5, 0xbf, 0x48, 0x02, 0xc4, 0xde, 0x8a, 0x9a, 0x90, 0x52, 0xd1, 0x52, 0x0a,
	0xc5, 0xa7, 0x57, 0x74, 0x77, 0xa5, 0xde, 0xf9, 0x31, 0x48, 0xf2, 0x70, 0x46, 0xcb, 0xf3, 0x5e,
	0x3b, 0xe1, 0xf9, 0xeb, 0xca, 0x8c, 0xdb, 0xc2, 0x9a, 0x33, 0x4a, 0x1e, 0xf4, 0xdb, 0x70, 0xd3,
	0xf2, 0x5c, 0x97, 0x08, 0xa4, 0xe1, 0x53, 0xcf, 0x27, 0x94, 0x39, 0x24, 0xdc, 0xb4, 0x77, 0xae,
	0xde, 0x40, 0x48, 0xd6, 0x8c, 0xb8, 0x1a, 0x0b, 0x78, 0xd5, 0x9a, 0x50, 0x8e, 0xca, 0x90, 0x61,
	0x84, 0x76, 0x1d, 0xd7, 0xec, 0x88, 0x9d, 0x33, 0x83, 0xa3, 0xe7, 0xf2, 0x13, 0x48, 0xa9, 0xbd,
	0xe4, 0x01, 0xe4, 0xe4, 0xeb, 0x1b, 0x93, 0xb3, 0x24, 0x20, 0x6b, 0x0f, 0xcd, 0x2e, 0x29, 0xb7,
	0x21, 0x25, 0x5f, 0x71, 0x56, 0x52, 0xe5, 0x97, 0x20, 0xc1, 0x58, 0x47, 0x0d, 0xe3, 0x25, 0xeb,
	0x95, 0xa3, 0x10, 0x52, 0xa7, 0x4f, 0xa9, 0x75, 0xc5, 0xef, 0xf2, 0x63, 0x58, 0x9d, 0xf4, 0xae,
	0xe8, 0x2d, 0xc8, 0x06, 0x5e, 0x8f, 0x5a, 0xc4, 0x70, 0x7c, 0xd1, 0x78, 0x06, 0x67, 0x64, 0xc1,
	0xae, 0x5f, 0xdb, 0x00, 0x5d, 0x2e, 0x88, 0xb1, 0x53, 0x40, 0xb9, 0x0d, 0x85, 0xa1, 0x95, 0x8c,
	0x6e, 0x43, 0x3e, 0x0c, 0x0b, 0x5c, 0xd4, 0xab, 0x53, 0x78, 0x4e, 0x95, 0x89, 0x3b, 0x83, 0x27,
	0x10, 0x6a, 0x3c, 0xf5, 0x22, 0x97, 0x85, 0xe5, 0x48, 0x0e, 0xd6, 0xe1, 0xad, 0x4b, 0xd4, 0x0f,
	0x5a, 0x87, 0x1b, 0xc7, 0x75, 0xfc, 0x72, 0x77, 0xbb, 0x6e, 0xbc, 0x38, 0xac, 0xbe, 0xac, 0xee,
	0xee, 0x57, 0x6b, 0xfb, 0x75, 0x7d, 0x01, 0x15, 0x20, 0x7b, 0x78, 0x74, 0x62, 0x7c, 0x76, 0xf4,
	0xe2, 0x70, 0x47, 0xd7, 0x2a, 0x3f, 0x86, 0xb5, 0xc9, 0x41, 0x01, 0x55, 0xe0, 0x56, 0xb3, 0x7a,
	0x7c, 0x6c, 0x9c, 0x34, 0xf0, 0xd1, 0x8b, 0xe7, 0x0d, 0x63, 0xf7, 0x50, 0xdd, 0x66, 0xe0, 0xfa,
	0xce, 0x2e, 0xae, 0x6f, 0x9f, 0xe8, 0x0b, 0xe8, 0x6d, 0x28, 0x35, 0xaa, 0x87, 0x3b, 0xfb, 0xf5,
	0x09, 0xb5, 0x5a, 0xad, 0x0c, 0x2b, 0xa1, 0xd8, 0x1b, 0x1d, 0xa8, 0x5a, 0x09, 0xd6, 0x86, 0x04,
	0xc9, 0xa0, 0x48, 0xce, 0xeb, 0x85, 0xbd, 0x64, 0x06, 0xe9, 0x37, 0xf6, 0x92, 0x99, 0x1b, 0xfa,
	0xea, 0x5e, 0x32, 0xa3, 0xeb, 0x2b, 0x7b, 0xc9, 0xcc, 0x9a, 0xbe, 0xbe, 0x97, 0xcc, 0xdc, 0xd4,
	0xd7, 0x2a, 0x7f, 0x9d, 0x85, 0xdc, 0xc0, 0xce, 0x8f, 0x36, 0x20, 0x23, 0x55, 0x83, 0xe7, 0xaa,
	0x11, 0x4e, 0x8b, 0xe7, 0x23, 0x17, 0x7d, 0x02, 0x39, 0xb7, 0xd7, 0x35, 0xf8, 0x23, 0x5f, 0x10,
	0xf3, 0x24, 0xdf, 0xc0, 0xed, 0x75, 0xb1, 0xc4, 0xa3, 0x2a, 0x2c, 0xfb, 0x84, 0x1a, 0x9c, 0x3b,
	0xdc, 0x65, 0x12, 0xb3, 0xbc, 0xad, 0xe0, 0x13, 0x7a, 0x42, 0xfb, 0xe1, 0x26, 0xf3, 0x0a, 0x8a,
	0x4a, 0xd2, 0x84, 0x0a, 0x41, 0xea, 0xcb, 0x47, 0xf3, 0x88, 0x1a, 0xf5, 0x5b, 0x59, 0xe2, 0x02,
	0x1d, 0x7c, 0x44, 0x0e, 0xac, 0x4a, 0x6a, 0x31, 0x96, 0x3e, 0xdf, 0x1a, 0x2c, 0x53, 0xe8, 0x4e,
	0xbe, 0xf3, 0x7c, 0x30, 0x7f, 0x03, 0x5c, 0xfb, 0x35, 0x43, 0x73, 0x8c, 0xe8, 0x58, 0x19, 0x6a,
	0xc0, 0x6d, 0xd1, 0x48, 0x40, 0x3a, 0x2a, 0xcc, 0xc8, 0x96, 0xc5, 0xd9, 0x4f, 0xde, 0x35, 0xca,
	0xd3, 0x5d, 0x02, 0xbf, 0xc3, 0x81, 0xc7, 0x21, 0x4e, 0xf0, 0x1f, 0x98, 0x17, 0xea, 0x42, 0x32,
	0x40, 0x4f, 0x60, 0x4d, 0xcc, 0x06, 0xf7, 0x63, 0x23, 0x60, 0x26, 0xeb, 0x05, 0x42, 0xf9, 0xcb,
	0xe4, 0x45, 0x01, 0xaf, 0x46, 0xb5, 0xc7, 0xa2, 0x92, 0xfb, 0x73, 0xc0, 0x4f, 0x6a, 0xb2, 0xc1,
	0x53, 0xd3, 0x7a, 0xcd, 0x37, 0x6a, 0x25, 0x49, 0x7f, 0x75, 0xfe, 0x97, 0xac, 0x99, 0xd6, 0xeb,
	0xa3, 0xb3, 0x33, 0x2c, 0x15, 0xa6, 0x7a, 0x42, 0xc7, 0xb0, 0x12, 0x77, 0x27, 0x3c, 0xe9, 0x66,
	0xaf, 0x94, 0x91, 0xd1, 0x23, 0x82, 0xf0, 0x50, 0x7c, 0x0a, 0x1b, 0x31, 0xe9, 0x48, 0x2e, 0x54,
	0xe5, 0x06, 0xe7, 0x25, 0x5f, 0x8f, 0x88, 0xf0, 0x50, 0xca, 0xb4, 0xfc, 0xfb, 0x1a, 0x14, 0x86,
	0xbc, 0x63, 0x56, 0xb4, 0xfc, 0x08, 0xf2, 0x32, 0x5d, 0xa9, 0x72, 0x94, 0x89, 0xe9, 0xd9, 0xbf,
	0xc6, 0x02, 0xce, 0x09, 0xac, 0x0c, 0x63, 0xb5, 0x02, 0xe4, 0xa4, 0x91, 0x88, 0x62, 0x6a, 0xd7,
	0x4c, 0xc9, 0xa2, 0xf2, 0x1f, 0x69, 0x80, 0xc6, 0xbd, 0xe8, 0xff, 0xaa, 0x37, 0x7f, 0xaa, 0x41,
	0x7e, 0x70, 0xba, 0xd1, 0x3e, 0x14, 0x4e, 0xcd, 0x80, 0x18, 0x42, 0xe4, 0x9c, 0x9b, 0x1d, 0xb5,
	0x8f, 0x4f, 0x5f, 0xc0, 0xb5, 0x3c, 0xef, 0x6b, 0xfa, 0x5b, 0x2d, 0x99, 0xd1, 0x1e, 0x2c, 0xe0,
	0x3c, 0xb7, 0xde, 0x55, 0xc6, 0xa8, 0x01, 0x79, 0xee, 0xf2, 0x11, 0xd9, 0xac, 0xbd, 0x47, 0xe9,
	0xfb, 0x6f, 0xb5, 0xc5, 0x07, 0x0b, 0x38, 0xd7, 0x35, 0x2f, 0x42, 0xa6, 0xca, 0x7f, 0x6a, 0x90,
	0x1b, 0x50, 0x4c, 0x08, 0x83, 0xee, 0xb8, 0x0e, 0x73, 0x84, 0xc6, 0x13, 0x33, 0x1d, 0xa8, 0xae,
	0xce, 0x7d, 0xa1, 0xb1, 0xac, 0x08, 0x94, 0xa7, 0x04, 0xc8, 0x84, 0x0d, 0xd3, 0xb6, 0x1d, 0x29,
	0x82, 0x22, 0x47, 0xb4, 0xda, 0xa6, 0x6b, 0x85, 0xea, 0xe3, 0xee, 0x60, 0xce, 0x29, 0x74, 0xc4,
	0x71, 0xe5, 0xb4, 0x1e, 0xf3, 0x28, 0xf6, 0x6d, 0xc1, 0x82, 0x9e, 0x42, 0x49, 0x8a, 0x44, 0xae,
	0x3c, 0x26, 0x84, 0xca, 0x0c, 0x5e, 0x15, 0xf5, 0x47, 0x6e, 0x73, 0x30, 0x2c, 0x56, 0xfe, 0x2a,
	0x09, 0xc5, 0x91, 0x2d, 0xe7, 0x1e, 0x14, 0xdb, 0x8c, 0xf9, 0x41, 0xa4, 0x71, 0xa5, 0x9e, 0x68,
	0x2c, 0xe0, 0x82, 0x28, 0x0f, 0xe1, 0xe8, 0x7d, 0x58, 0x0e, 0xac, 0x36, 0xe9, 0x92, 0x18, 0x99,
	0x56, 0x39, 0xe5, 0xa2, 0xac, 0x88, 0xa0, 0x77, 0xa0, 0xa0, 0x36, 0x1a, 0x05, 0x94, 0xfb, 0x43,
	0x5e, 0x1e, 0xb6, 0x63, 0x90, 0xef, 0xd1, 0x01, 0x10, 0x8f, 0x2d, 0x05, 0x9c, 0xe7, 0x85, 0x11,
	0xe8, 0x2e, 0x14, 0x44, 0xea, 0x2f, 0x02, 0x2d, 0xaa, 0xd3, 0x73, 0x9e, 0x17, 0x47, 0xb0, 0x7b,
	0x93, 0xb3, 0x00, 0x0d, 0x6d, 0x34, 0x0f, 0xd0, 0x85, 0xc2, 0x70, 0xe6, 0x23, 0x21, 0x94, 0xfc,
	0xb3, 0x39, 0x2f, 0xd2, 0xa3, 0xc7, 0xa9, 0x59, 0x8f, 0x3c, 0x1d, 0x54, 0x04, 0xef, 0x42, 0x2e,
	0x60, 0xd4, 0xf1, 0x0d, 0x91, 0xeb, 0x15, 0xa1, 0x3a, 0x83, 0x41, 0x14, 0x89, 0xa4, 0x70, 0xe5,
	0x0d, 0xac, 0x4e, 0xa2, 0x44, 0x37, 0x61, 0xe5, 0xe0, 0xe8, 0x65, 0x7d, 0xc7, 0x68, 0xd6, 0xf1,
	0x41, 0xf5, 0xb0, 0x7e, 0x78, 0xb2, 0xff, 0x4a, 0x5f, 0x40, 0x59, 0x58, 0x52, 0x22, 0x82, 0x6b,
	0x8a, 0xe3, 0x7a, 0xdd, 0x38, 0x3a, 0x69, 0xd4, 0xb1, 0xbe, 0x88, 0xd6, 0x00, 0x9d, 0xd4, 0x0f,
	0x9a, 0x47, 0xb8, 0x8a, 0x5f, 0xc5, 0x7a, 0x20, 0xc1, 0xcb, 0x23, 0x8a, 0xb8, 0x3c, 0x59, 0x2b,
	0x43, 0x29, 0x9a, 0xcd, 0x11, 0x35, 0xc0, 0x75, 0x82, 0x1a, 0xf4, 0x91, 0x9a, 0x0a, 0x83, 0xd5,
	0x49, 0xdf, 0x02, 0xa0, 0xf7, 0x20, 0x25, 0x37, 0x15, 0x31, 0xd3, 0x05, 0xb5, 0x98, 0x1f, 0x2c,
	0xe9, 0xff, 0x94, 0xbc, 0x6f, 0x63, 0x55, 0x87, 0x9e, 0x42, 0xf2, 0xd4, 0xb3, 0xfb, 0x6a, 0x0d,
	0x54, 0xa6, 0x1d, 0x24, 0x76, 0x4c, 0x66, 0x1e, 0x0b, 0xdd, 0x87, 0x05, 0xbe, 0xf2, 0x04, 0xb2,
	0xd1, 0x7d, 0x3f, 0xba, 0x07, 0x59, 0xae, 0x18, 0xc5, 0x3a, 0x1f, 0x0f, 0x73, 0x71, 0x5d, 0xe5,
	0x3f, 0x34, 0x48, 0xab, 0x1b, 0x62, 0x74, 0x08, 0xcb, 0x56, 0xc7, 0x21, 0x2e, 0x33, 0x02, 0xb3,
	0xeb, 0x77, 0x1c, 0xb7, 0xa5, 0x56, 0xf9, 0x9c, 0x0b, 0xb1, 0x28, 0xad, 0x8f, 0x95, 0x31, 0xe7,
	0xa3, 0xa6, 0x6b, 0x7b, 0xdd, 0x98, 0xef, 0x4a, 0x0b, 0xbb, 0x28, 0xad, 0x23, 0xbe, 0x26, 0xe8,
	0xde, 0x39, 0xa1, 0x66, 0xa7, 0x13, 0x13, 0x26, 0xae, 0x42, 0xb8, 0xac, 0xcc, 0x43, 0xc6, 0xca,
	0x1f, 0x6b, 0x50, 0x1c, 0xfe, 0x5a, 0x6e, 0xf0, 0xf2, 0x23, 0x79, 0xbd, 0xcb, 0x8f, 0x70, 0x77,
	0x59, 0x9c, 0xb8, 0xbb, 0x44, 0xa9, 0xd6, 0x84, 0x9e, 0xc4, 0x69, 0x9f, 0x0b, 0x14, 0xea, 0xe2,
	0x94, 0xcc, 0x89, 0x57, 0x7e, 0x0f, 0x20, 0x1b, 0x65, 0x35, 0xd0, 0x27, 0xb0, 0x14, 0x30, 0xb3,
	0x45, 0xae, 0x14, 0x6c, 0x4b, 0x80, 0xa5, 0x15, 0x5f, 0x57, 0xb6, 0x13, 0x88, 0x8d, 0xfe, 0x35,
	0xe9, 0xab, 0x74, 0x3b, 0xa8, 0xa2, 0xcf, 0x49, 0x1f, 0x1d, 0x41, 0x5a, 0x0e, 0x51, 0xf8, 0xbd,
	0xe3, 0xfb, 0xb3, 0xd3, 0x38, 0x5b, 0xd2, 0x99, 0x87, 0xbf, 0x9f, 0x54, 0x2c, 0xe5, 0xbf, 0xc9,
	0x40, 0x4a, 0x39, 0xfb, 0x4f, 0xa0, 0xa8, 0xce, 0x29, 0x83, 0xe7, 0xe8, 0x4b, 0xa5, 0xdf, 0x48,
	0x13, 0x5b, 0xd2, 0xbd, 0xe3, 0xac, 0x6d, 0x21, 0x18, 0x2c, 0x40, 0x1e, 0xdc, 0xb0, 0x49, 0xc0,
	0x1c, 0x57, 0x78, 0x72, 0xd4, 0x8c, 0x74, 0xb1, 0x67, 0xf3, 0x37, 0xb3, 0x13, 0x93, 0xc4, 0x6d,
	0x21, 0x7b, 0xac, 0x14, 0x59, 0xb0, 0x3c, 0x2a, 0x98, 0x12, 0xb3, 0x52, 0x76, 0xa3, 0x8d, 0x0d,
	0x2b, 0x25, 0xbe, 0x2b, 0x0c, 0x5f, 0x37, 0xf3, 0x71, 0xa3, 0xa4, 0xeb, 0x31, 0x62, 0x98, 0xb6,
	0x4d, 0x49, 0x10, 0x28, 0x4d, 0xfe, 0xc1, 0x55, 0xda, 0xe0, 0xf6, 0x55, 0x69, 0xce, 0xc7, 0x8d,
	0x0e, 0x16, 0xa0, 0x2f, 0x20, 0xd7, 0x22, 0x2e, 0xa1, 0x8e, 0x25, 0xdc, 0x42, 0x7e, 0x44, 0xf4,
	0x64, 0x7e, 0xfa, 0xe7, 0xd2, 0xf8, 0x73, 0xc2, 0xd5, 0x0f, 0xb4, 0xa2, 0x27, 0xf4, 0x5b, 0x80,
	0xd4, 0x41, 0x5a, 0x5c, 0xd0, 0xaa, 0x94, 0x75, 0x6a, 0xd6, 0x95, 0xda, 0x28, 0xff, 0xc0, 0x75,
	0xb9, 0x58, 0x5b, 0x8d, 0x05, 0xac, 0xb7, 0x47, 0xca, 0xca, 0xcb, 0x50, 0x18, 0x72, 0x8f, 0xf2,
	0x2a, 0xa0, 0xf1, 0x89, 0x2c, 0xbb, 0x7c, 0x27, 0x1f, 0x1a, 0xdf, 0x2b, 0x9c, 0xf6, 0xd1, 0x0f,
	0xa1, 0x68, 0x93, 0xc0, 0xa2, 0x8e, 0xcf, 0x3c, 0x1a, 0xaf, 0xa1, 0x41, 0x78, 0x21, 0x06, 0x7c,
	0x4e, 0xfa, 0xbc, 0x5b, 0x43, 0xa3, 0x5f, 0xae, 0x01, 0xc4, 0xe3, 0x85, 0x9e, 0x80, 0x3e, 0x40,
	0x28, 0x6f, 0xba, 0xc7, 0x7a, 0xb0, 0x1c, 0x43, 0xc4, 0x0b, 0x97, 0xff, 0x51, 0x03, 0x7d, 0x74,
	0x50, 0xae, 0x47, 0x85, 0x3e, 0x81, 0x3c, 0xb9, 0xf0, 0x89, 0xc5, 0xd4, 0xe4, 0xcc, 0x3e, 0xd6,
	0xe7, 0x24, 0x5e, 0x36, 0xba, 0x1f, 0x07, 0xc7, 0xc4, 0x55, 0x82, 0xe3, 0x70, 0xb4, 0x50, 0x14,
	0xb5, 0x0d, 0xd0, 0x65, 0xe0, 0x18, 0x3b, 0x84, 0x57, 0xfe, 0x3e, 0x01, 0x85, 0x21, 0x86, 0x59,
	0x9a, 0xfd, 0x36, 0xe4, 0xc8, 0x85, 0x19, 0xbd, 0x57, 0x52, 0x69, 0x2e, 0x10, 0x85, 0xb2, 0xf3,
	0x27, 0xa0, 0xc7, 0xb7, 0xf9, 0xd1, 0xe5, 0xe6, 0x95, 0xee, 0xf4, 0x85, 0x8a, 0x0b, 0xef, 0xf1,
	0x25, 0x6b, 0x15, 0x72, 0xe2, 0x43, 0xf9, 0x21, 0x6f, 0xbf, 0x35, 0x69, 0x3f, 0xda, 0x75, 0xd9,
	0xd3, 0x27, 0x98, 0x63, 0x79, 0xc7, 0x84, 0x51, 0x78, 0x3b, 0x53, 0x50, 0xd7, 0xb8, 0x8a, 0x24,
	0xad, 0xb4, 0x65, 0x5e, 0x15, 0x4b, 0xd8, 0x16, 0xe4, 0x95, 0x7c, 0x93, 0xa8, 0xec, 0xf8, 0x6d,
	0x59, 0x4e, 0x02, 0x22, 0x7c, 0xd0, 0x3b, 0x8b, 0xf1, 0x30, 0x01, 0x2f, 0x01, 0x12, 0x7f, 0x1b,
	0xf2, 0x8e, 0x7b, 0x4e, 0x68, 0xd8, 0x8b, 0x8c, 0xd0, 0x61, 0x39, 0x59, 0x26, 0xbf, 0xd6, 0x2c,
	0xc1, 0x9a, 0x5a, 0x3c, 0x02, 0x32, 0x94, 0x1b, 0x59, 0xd4, 0x13, 0x72, 0x57, 0x93, 0x17, 0xce,
	0x38, 0x37, 0x30, 0xce, 0x95, 0x7f, 0xd7, 0xe0, 0xe6, 0xc4, 0x0b, 0x7e, 0xb4, 0x39, 0x34, 0xaf,
	0x52, 0x12, 0x51, 0x1e, 0x93, 0x7e, 0x27, 0xa3, 0xa6, 0xf6, 0xc7, 0x90, 0x1f, 0xba, 0x90, 0x96,
	0x01, 0x6b, 0xfe, 0x0b, 0xe9, 0x91, 0x0f, 0x31, 0x72, 0xc1, 0xc0, 0x9d, 0xf4, 0xd8, 0xd0, 0xa7,
	0x26, 0x0d, 0x7d, 0xed, 0x36, 0xbc, 0x3b, 0xf2, 0x3d, 0xc3, 0x84, 0x01, 0x90, 0xaf, 0x9e, 0xd4,
	0x97, 0xd4, 0x07, 0x2a, 0xea, 0xb2, 0xbd, 0x56, 0xfd, 0xdb, 0xef, 0x6e, 0x69, 0xff, 0xf0, 0xdd,
	0x2d, 0xed, 0x9f, 0xbf, 0xbb, 0xa5, 0xc1, 0x5d, 0xc7, 0x93, 0x3d, 0xf7, 0xa9, 0x77, 0xd1, 0x9f,
	0xb6, 0x7c, 0x6a, 0xf2, 0xb3, 0x95, 0x26, 0x5f, 0x8f, 0x4d, 0xed, 0x34, 0x25, 0x16, 0xe6, 0xe3,
	0xff, 0x0a, 0x00, 0x00, 0xff, 0xff, 0xe6, 0xa5, 0xc5, 0x8c, 0x7b, 0x32, 0x00, 0x00,
}

func (m *VirtualHost) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VirtualHost) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VirtualHost) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PerRequestBufferLimitBytes != nil {
		{
			size, err := m.PerRequestBufferLimitBytes.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.HedgePolicy != nil {
		{
			size, err := m.HedgePolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.RetryPolicy != nil {
		{
			size, err := m.RetryPolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.TypedPerFilterConfig) > 0 {
		for k := range m.TypedPerFilterConfig {
			v := m.TypedPerFilterConfig[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintRoute(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintRoute(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintRoute(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x7a
		}
	}
	if m.IncludeRequestAttemptCount {
		i--
		if m.IncludeRequestAttemptCount {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if len(m.RequestHeadersToRemove) > 0 {
		for iNdEx := len(m.RequestHeadersToRemove) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RequestHeadersToRemove[iNdEx])
			copy(dAtA[i:], m.RequestHeadersToRemove[iNdEx])
			i = encodeVarintRoute(dAtA, i, uint64(len(m.RequestHeadersToRemove[iNdEx])))
			i--
			dAtA[i] = 0x6a
		}
	}
	if len(m.ResponseHeadersToRemove) > 0 {
		for iNdEx := len(m.ResponseHeadersToRemove) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ResponseHeadersToRemove[iNdEx])
			copy(dAtA[i:], m.ResponseHeadersToRemove[iNdEx])
			i = encodeVarintRoute(dAtA, i, uint64(len(m.ResponseHeadersToRemove[iNdEx])))
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.ResponseHeadersToAdd) > 0 {
		for iNdEx := len(m.ResponseHeadersToAdd) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ResponseHeadersToAdd[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRoute(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if m.Cors != nil {
		{
			size, err := m.Cors.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.RequestHeadersToAdd) > 0 {
		for iNdEx := len(m.RequestHeadersToAdd) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RequestHeadersToAdd[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRoute(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.RateLimits) > 0 {
		for iNdEx := len(m.RateLimits) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RateLimits[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRoute(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.VirtualClusters) > 0 {
		for iNdEx := len(m.VirtualClusters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VirtualClusters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRoute(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.RequireTls != 0 {
		i = encodeVarintRoute(dAtA, i, uint64(m.RequireTls))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Routes) > 0 {
		for iNdEx := len(m.Routes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Routes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRoute(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Domains) > 0 {
		for iNdEx := len(m.Domains) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Domains[iNdEx])
			copy(dAtA[i:], m.Domains[iNdEx])
			i = encodeVarintRoute(dAtA, i, uint64(len(m.Domains[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintRoute(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Route) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Route) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Route) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PerRequestBufferLimitBytes != nil {
		{
			size, err := m.PerRequestBufferLimitBytes.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.Tracing != nil {
		{
			size, err := m.Tracing.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintRoute(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.TypedPerFilterConfig) > 0 {
		for k := range m.TypedPerFilterConfig {
			v := m.TypedPerFilterConfig[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintRoute(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintRoute(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintRoute(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6a
		}
	}
	if len(m.RequestHeadersToRemove) > 0 {
		for iNdEx := len(m.RequestHeadersToRemove) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RequestHeadersToRemove[iNdEx])
			copy(dAtA[i:], m.RequestHeadersToRemove[iNdEx])
			i = encodeVarintRoute(dAtA, i, uint64(len(m.RequestHeadersToRemove[iNdEx])))
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.ResponseHeadersToRemove) > 0 {
		for iNdEx := len(m.ResponseHeadersToRemove) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ResponseHeadersToRemove[iNdEx])
			copy(dAtA[i:], m.ResponseHeadersToRemove[iNdEx])
			i = encodeVarintRoute(dAtA, i, uint64(len(m.ResponseHeadersToRemove[iNdEx])))
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.ResponseHeadersToAdd) > 0 {
		for iNdEx := len(m.ResponseHeadersToAdd) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ResponseHeadersToAdd[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRoute(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.RequestHeadersToAdd) > 0 {
		for iNdEx := len(m.RequestHeadersToAdd) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RequestHeadersToAdd[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRoute(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.Action != nil {
		{
			size := m.Action.Size()
			i -= size
			if _, err := m.Action.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Decorator != nil {
		{
			size, err := m.Decorator.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Match != nil {
		{
			size, err := m.Match.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Route_Route) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Route_Route) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Route != nil {
		{
			size, err := m.Route.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Route_Redirect) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Route_Redirect) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Redirect != nil {
		{
			size, err := m.Redirect.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Route_DirectResponse) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Route_DirectResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DirectResponse != nil {
		{
			size, err := m.DirectResponse.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *WeightedCluster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WeightedCluster) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WeightedCluster) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TotalWeight != nil {
		{
			size, err := m.TotalWeight.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.RuntimeKeyPrefix) > 0 {
		i -= len(m.RuntimeKeyPrefix)
		copy(dAtA[i:], m.RuntimeKeyPrefix)
		i = encodeVarintRoute(dAtA, i, uint64(len(m.RuntimeKeyPrefix)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Clusters) > 0 {
		for iNdEx := len(m.Clusters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Clusters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRoute(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *WeightedCluster_ClusterWeight) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WeightedCluster_ClusterWeight) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WeightedCluster_ClusterWeight) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.TypedPerFilterConfig) > 0 {
		for k := range m.TypedPerFilterConfig {
			v := m.TypedPerFilterConfig[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintRoute(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintRoute(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintRoute(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.RequestHeadersToRemove) > 0 {
		for iNdEx := len(m.RequestHeadersToRemove) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RequestHeadersToRemove[iNdEx])
			copy(dAtA[i:], m.RequestHeadersToRemove[iNdEx])
			i = encodeVarintRoute(dAtA, i, uint64(len(m.RequestHeadersToRemove[iNdEx])))
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.ResponseHeadersToRemove) > 0 {
		for iNdEx := len(m.ResponseHeadersToRemove) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ResponseHeadersToRemove[iNdEx])
			copy(dAtA[i:], m.ResponseHeadersToRemove[iNdEx])
			i = encodeVarintRoute(dAtA, i, uint64(len(m.ResponseHeadersToRemove[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.ResponseHeadersToAdd) > 0 {
		for iNdEx := len(m.ResponseHeadersToAdd) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ResponseHeadersToAdd[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRoute(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.RequestHeadersToAdd) > 0 {
		for iNdEx := len(m.RequestHeadersToAdd) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RequestHeadersToAdd[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRoute(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.MetadataMatch != nil {
		{
			size, err := m.MetadataMatch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Weight != nil {
		{
			size, err := m.Weight.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintRoute(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RouteMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteMatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TlsContext != nil {
		{
			size, err := m.TlsContext.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.PathSpecifier != nil {
		{
			size := m.PathSpecifier.Size()
			i -= size
			if _, err := m.PathSpecifier.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.RuntimeFraction != nil {
		{
			size, err := m.RuntimeFraction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.Grpc != nil {
		{
			size, err := m.Grpc.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.QueryParameters) > 0 {
		for iNdEx := len(m.QueryParameters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.QueryParameters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRoute(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Headers) > 0 {
		for iNdEx := len(m.Headers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Headers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRoute(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.CaseSensitive != nil {
		{
			size, err := m.CaseSensitive.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}

func (m *RouteMatch_Prefix) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *RouteMatch_Prefix) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Prefix)
	copy(dAtA[i:], m.Prefix)
	i = encodeVarintRoute(dAtA, i, uint64(len(m.Prefix)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}
func (m *RouteMatch_Path) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *RouteMatch_Path) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Path)
	copy(dAtA[i:], m.Path)
	i = encodeVarintRoute(dAtA, i, uint64(len(m.Path)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *RouteMatch_SafeRegex) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *RouteMatch_SafeRegex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SafeRegex != nil {
		{
			size, err := m.SafeRegex.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *RouteMatch_GrpcRouteMatchOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteMatch_GrpcRouteMatchOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteMatch_GrpcRouteMatchOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *RouteMatch_TlsContextMatchOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteMatch_TlsContextMatchOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteMatch_TlsContextMatchOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Presented != nil {
		{
			size, err := m.Presented.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CorsPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CorsPolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CorsPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AllowOriginStringMatch) > 0 {
		for iNdEx := len(m.AllowOriginStringMatch) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AllowOriginStringMatch[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRoute(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if m.ShadowEnabled != nil {
		{
			size, err := m.ShadowEnabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.EnabledSpecifier != nil {
		{
			size := m.EnabledSpecifier.Size()
			i -= size
			if _, err := m.EnabledSpecifier.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.AllowCredentials != nil {
		{
			size, err := m.AllowCredentials.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.MaxAge) > 0 {
		i -= len(m.MaxAge)
		copy(dAtA[i:], m.MaxAge)
		i = encodeVarintRoute(dAtA, i, uint64(len(m.MaxAge)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ExposeHeaders) > 0 {
		i -= len(m.ExposeHeaders)
		copy(dAtA[i:], m.ExposeHeaders)
		i = encodeVarintRoute(dAtA, i, uint64(len(m.ExposeHeaders)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AllowHeaders) > 0 {
		i -= len(m.AllowHeaders)
		copy(dAtA[i:], m.AllowHeaders)
		i = encodeVarintRoute(dAtA, i, uint64(len(m.AllowHeaders)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AllowMethods) > 0 {
		i -= len(m.AllowMethods)
		copy(dAtA[i:], m.AllowMethods)
		i = encodeVarintRoute(dAtA, i, uint64(len(m.AllowMethods)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *CorsPolicy_FilterEnabled) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *CorsPolicy_FilterEnabled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.FilterEnabled != nil {
		{
			size, err := m.FilterEnabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *RouteAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteAction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteAction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.HostRewriteSpecifier != nil {
		{
			size := m.HostRewriteSpecifier.Size()
			i -= size
			if _, err := m.HostRewriteSpecifier.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.GrpcTimeoutOffset != nil {
		{
			size, err := m.GrpcTimeoutOffset.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	if m.HedgePolicy != nil {
		{
			size, err := m.HedgePolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	if m.InternalRedirectAction != 0 {
		i = encodeVarintRoute(dAtA, i, uint64(m.InternalRedirectAction))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if len(m.UpgradeConfigs) > 0 {
		for iNdEx := len(m.UpgradeConfigs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UpgradeConfigs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRoute(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xca
		}
	}
	if m.IdleTimeout != nil {
		{
			size, err := m.IdleTimeout.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.MaxGrpcTimeout != nil {
		{
			size, err := m.MaxGrpcTimeout.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if m.ClusterNotFoundResponseCode != 0 {
		i = encodeVarintRoute(dAtA, i, uint64(m.ClusterNotFoundResponseCode))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.Cors != nil {
		{
			size, err := m.Cors.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.HashPolicy) > 0 {
		for iNdEx := len(m.HashPolicy) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.HashPolicy[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRoute(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x7a
		}
	}
	if m.IncludeVhRateLimits != nil {
		{
			size, err := m.IncludeVhRateLimits.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if len(m.RateLimits) > 0 {
		for iNdEx := len(m.RateLimits) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RateLimits[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRoute(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	if m.Priority != 0 {
		i = encodeVarintRoute(dAtA, i, uint64(m.Priority))
		i--
		dAtA[i] = 0x58
	}
	if m.RequestMirrorPolicy != nil {
		{
			size, err := m.RequestMirrorPolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.RetryPolicy != nil {
		{
			size, err := m.RetryPolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.Timeout != nil {
		{
			size, err := m.Timeout.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.PrefixRewrite) > 0 {
		i -= len(m.PrefixRewrite)
		copy(dAtA[i:], m.PrefixRewrite)
		i = encodeVarintRoute(dAtA, i, uint64(len(m.PrefixRewrite)))
		i--
		dAtA[i] = 0x2a
	}
	if m.MetadataMatch != nil {
		{
			size, err := m.MetadataMatch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.ClusterSpecifier != nil {
		{
			size := m.ClusterSpecifier.Size()
			i -= size
			if _, err := m.ClusterSpecifier.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *RouteAction_Cluster) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *RouteAction_Cluster) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Cluster)
	copy(dAtA[i:], m.Cluster)
	i = encodeVarintRoute(dAtA, i, uint64(len(m.Cluster)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}
func (m *RouteAction_ClusterHeader) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *RouteAction_ClusterHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ClusterHeader)
	copy(dAtA[i:], m.ClusterHeader)
	i = encodeVarintRoute(dAtA, i, uint64(len(m.ClusterHeader)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *RouteAction_WeightedClusters) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *RouteAction_WeightedClusters) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.WeightedClusters != nil {
		{
			size, err := m.WeightedClusters.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *RouteAction_HostRewrite) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *RouteAction_HostRewrite) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.HostRewrite)
	copy(dAtA[i:], m.HostRewrite)
	i = encodeVarintRoute(dAtA, i, uint64(len(m.HostRewrite)))
	i--
	dAtA[i] = 0x32
	return len(dAtA) - i, nil
}
func (m *RouteAction_AutoHostRewrite) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *RouteAction_AutoHostRewrite) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AutoHostRewrite != nil {
		{
			size, err := m.AutoHostRewrite.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *RouteAction_AutoHostRewriteHeader) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *RouteAction_AutoHostRewriteHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.AutoHostRewriteHeader)
	copy(dAtA[i:], m.AutoHostRewriteHeader)
	i = encodeVarintRoute(dAtA, i, uint64(len(m.AutoHostRewriteHeader)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xea
	return len(dAtA) - i, nil
}
func (m *RouteAction_RequestMirrorPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteAction_RequestMirrorPolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteAction_RequestMirrorPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RuntimeFraction != nil {
		{
			size, err := m.RuntimeFraction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Cluster) > 0 {
		i -= len(m.Cluster)
		copy(dAtA[i:], m.Cluster)
		i = encodeVarintRoute(dAtA, i, uint64(len(m.Cluster)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RouteAction_HashPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteAction_HashPolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteAction_HashPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Terminal {
		i--
		if m.Terminal {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.PolicySpecifier != nil {
		{
			size := m.PolicySpecifier.Size()
			i -= size
			if _, err := m.PolicySpecifier.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *RouteAction_HashPolicy_Header_) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *RouteAction_HashPolicy_Header_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *RouteAction_HashPolicy_Cookie_) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *RouteAction_HashPolicy_Cookie_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Cookie != nil {
		{
			size, err := m.Cookie.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *RouteAction_HashPolicy_ConnectionProperties_) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *RouteAction_HashPolicy_ConnectionProperties_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ConnectionProperties != nil {
		{
			size, err := m.ConnectionProperties.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *RouteAction_HashPolicy_Header) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteAction_HashPolicy_Header) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteAction_HashPolicy_Header) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.HeaderName) > 0 {
		i -= len(m.HeaderName)
		copy(dAtA[i:], m.HeaderName)
		i = encodeVarintRoute(dAtA, i, uint64(len(m.HeaderName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RouteAction_HashPolicy_Cookie) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteAction_HashPolicy_Cookie) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteAction_HashPolicy_Cookie) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintRoute(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Ttl != nil {
		{
			size, err := m.Ttl.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintRoute(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RouteAction_HashPolicy_ConnectionProperties) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteAction_HashPolicy_ConnectionProperties) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteAction_HashPolicy_ConnectionProperties) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SourceIp {
		i--
		if m.SourceIp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RouteAction_UpgradeConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteAction_UpgradeConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteAction_UpgradeConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Enabled != nil {
		{
			size, err := m.Enabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.UpgradeType) > 0 {
		i -= len(m.UpgradeType)
		copy(dAtA[i:], m.UpgradeType)
		i = encodeVarintRoute(dAtA, i, uint64(len(m.UpgradeType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RetryPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RetryPolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RetryPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RetriableRequestHeaders) > 0 {
		for iNdEx := len(m.RetriableRequestHeaders) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RetriableRequestHeaders[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRoute(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.RetriableHeaders) > 0 {
		for iNdEx := len(m.RetriableHeaders) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RetriableHeaders[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRoute(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.RetryBackOff != nil {
		{
			size, err := m.RetryBackOff.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.RetriableStatusCodes) > 0 {
		dAtA48 := make([]byte, len(m.RetriableStatusCodes)*10)
		var j47 int
		for _, num := range m.RetriableStatusCodes {
			for num >= 1<<7 {
				dAtA48[j47] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j47++
			}
			dAtA48[j47] = uint8(num)
			j47++
		}
		i -= j47
		copy(dAtA[i:], dAtA48[:j47])
		i = encodeVarintRoute(dAtA, i, uint64(j47))
		i--
		dAtA[i] = 0x3a
	}
	if m.HostSelectionRetryMaxAttempts != 0 {
		i = encodeVarintRoute(dAtA, i, uint64(m.HostSelectionRetryMaxAttempts))
		i--
		dAtA[i] = 0x30
	}
	if len(m.RetryHostPredicate) > 0 {
		for iNdEx := len(m.RetryHostPredicate) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RetryHostPredicate[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRoute(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.RetryPriority != nil {
		{
			size, err := m.RetryPriority.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.PerTryTimeout != nil {
		{
			size, err := m.PerTryTimeout.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.NumRetries != nil {
		{
			size, err := m.NumRetries.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.RetryOn) > 0 {
		i -= len(m.RetryOn)
		copy(dAtA[i:], m.RetryOn)
		i = encodeVarintRoute(dAtA, i, uint64(len(m.RetryOn)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RetryPolicy_RetryPriority) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RetryPolicy_RetryPriority) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RetryPolicy_RetryPriority) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ConfigType != nil {
		{
			size := m.ConfigType.Size()
			i -= size
			if _, err := m.ConfigType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintRoute(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RetryPolicy_RetryPriority_TypedConfig) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *RetryPolicy_RetryPriority_TypedConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TypedConfig != nil {
		{
			size, err := m.TypedConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *RetryPolicy_RetryHostPredicate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RetryPolicy_RetryHostPredicate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RetryPolicy_RetryHostPredicate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ConfigType != nil {
		{
			size := m.ConfigType.Size()
			i -= size
			if _, err := m.ConfigType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintRoute(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RetryPolicy_RetryHostPredicate_TypedConfig) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *RetryPolicy_RetryHostPredicate_TypedConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TypedConfig != nil {
		{
			size, err := m.TypedConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *RetryPolicy_RetryBackOff) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RetryPolicy_RetryBackOff) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RetryPolicy_RetryBackOff) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MaxInterval != nil {
		{
			size, err := m.MaxInterval.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.BaseInterval != nil {
		{
			size, err := m.BaseInterval.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HedgePolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HedgePolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HedgePolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.HedgeOnPerTryTimeout {
		i--
		if m.HedgeOnPerTryTimeout {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.AdditionalRequestChance != nil {
		{
			size, err := m.AdditionalRequestChance.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.InitialRequests != nil {
		{
			size, err := m.InitialRequests.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RedirectAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RedirectAction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RedirectAction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PortRedirect != 0 {
		i = encodeVarintRoute(dAtA, i, uint64(m.PortRedirect))
		i--
		dAtA[i] = 0x40
	}
	if m.SchemeRewriteSpecifier != nil {
		{
			size := m.SchemeRewriteSpecifier.Size()
			i -= size
			if _, err := m.SchemeRewriteSpecifier.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.StripQuery {
		i--
		if m.StripQuery {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.PathRewriteSpecifier != nil {
		{
			size := m.PathRewriteSpecifier.Size()
			i -= size
			if _, err := m.PathRewriteSpecifier.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.ResponseCode != 0 {
		i = encodeVarintRoute(dAtA, i, uint64(m.ResponseCode))
		i--
		dAtA[i] = 0x18
	}
	if len(m.HostRedirect) > 0 {
		i -= len(m.HostRedirect)
		copy(dAtA[i:], m.HostRedirect)
		i = encodeVarintRoute(dAtA, i, uint64(len(m.HostRedirect)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RedirectAction_PathRedirect) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *RedirectAction_PathRedirect) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.PathRedirect)
	copy(dAtA[i:], m.PathRedirect)
	i = encodeVarintRoute(dAtA, i, uint64(len(m.PathRedirect)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *RedirectAction_HttpsRedirect) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *RedirectAction_HttpsRedirect) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.HttpsRedirect {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x20
	return len(dAtA) - i, nil
}
func (m *RedirectAction_PrefixRewrite) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *RedirectAction_PrefixRewrite) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.PrefixRewrite)
	copy(dAtA[i:], m.PrefixRewrite)
	i = encodeVarintRoute(dAtA, i, uint64(len(m.PrefixRewrite)))
	i--
	dAtA[i] = 0x2a
	return len(dAtA) - i, nil
}
func (m *RedirectAction_SchemeRedirect) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *RedirectAction_SchemeRedirect) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.SchemeRedirect)
	copy(dAtA[i:], m.SchemeRedirect)
	i = encodeVarintRoute(dAtA, i, uint64(len(m.SchemeRedirect)))
	i--
	dAtA[i] = 0x3a
	return len(dAtA) - i, nil
}
func (m *DirectResponseAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DirectResponseAction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DirectResponseAction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Body != nil {
		{
			size, err := m.Body.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintRoute(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Decorator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Decorator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Decorator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Operation) > 0 {
		i -= len(m.Operation)
		copy(dAtA[i:], m.Operation)
		i = encodeVarintRoute(dAtA, i, uint64(len(m.Operation)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Tracing) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tracing) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tracing) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.OverallSampling != nil {
		{
			size, err := m.OverallSampling.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.RandomSampling != nil {
		{
			size, err := m.RandomSampling.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ClientSampling != nil {
		{
			size, err := m.ClientSampling.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VirtualCluster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VirtualCluster) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VirtualCluster) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Headers) > 0 {
		for iNdEx := len(m.Headers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Headers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRoute(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintRoute(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *RateLimit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RateLimit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RateLimit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Actions) > 0 {
		for iNdEx := len(m.Actions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Actions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRoute(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.DisableKey) > 0 {
		i -= len(m.DisableKey)
		copy(dAtA[i:], m.DisableKey)
		i = encodeVarintRoute(dAtA, i, uint64(len(m.DisableKey)))
		i--
		dAtA[i] = 0x12
	}
	if m.Stage != nil {
		{
			size, err := m.Stage.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RateLimit_Action) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RateLimit_Action) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RateLimit_Action) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ActionSpecifier != nil {
		{
			size := m.ActionSpecifier.Size()
			i -= size
			if _, err := m.ActionSpecifier.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *RateLimit_Action_SourceCluster_) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *RateLimit_Action_SourceCluster_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SourceCluster != nil {
		{
			size, err := m.SourceCluster.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *RateLimit_Action_DestinationCluster_) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *RateLimit_Action_DestinationCluster_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DestinationCluster != nil {
		{
			size, err := m.DestinationCluster.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *RateLimit_Action_RequestHeaders_) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *RateLimit_Action_RequestHeaders_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RequestHeaders != nil {
		{
			size, err := m.RequestHeaders.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *RateLimit_Action_RemoteAddress_) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *RateLimit_Action_RemoteAddress_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RemoteAddress != nil {
		{
			size, err := m.RemoteAddress.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *RateLimit_Action_GenericKey_) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *RateLimit_Action_GenericKey_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.GenericKey != nil {
		{
			size, err := m.GenericKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *RateLimit_Action_HeaderValueMatch_) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *RateLimit_Action_HeaderValueMatch_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.HeaderValueMatch != nil {
		{
			size, err := m.HeaderValueMatch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *RateLimit_Action_SourceCluster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RateLimit_Action_SourceCluster) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RateLimit_Action_SourceCluster) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *RateLimit_Action_DestinationCluster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RateLimit_Action_DestinationCluster) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RateLimit_Action_DestinationCluster) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *RateLimit_Action_RequestHeaders) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RateLimit_Action_RequestHeaders) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RateLimit_Action_RequestHeaders) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DescriptorKey) > 0 {
		i -= len(m.DescriptorKey)
		copy(dAtA[i:], m.DescriptorKey)
		i = encodeVarintRoute(dAtA, i, uint64(len(m.DescriptorKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.HeaderName) > 0 {
		i -= len(m.HeaderName)
		copy(dAtA[i:], m.HeaderName)
		i = encodeVarintRoute(dAtA, i, uint64(len(m.HeaderName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RateLimit_Action_RemoteAddress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RateLimit_Action_RemoteAddress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RateLimit_Action_RemoteAddress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *RateLimit_Action_GenericKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RateLimit_Action_GenericKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RateLimit_Action_GenericKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DescriptorValue) > 0 {
		i -= len(m.DescriptorValue)
		copy(dAtA[i:], m.DescriptorValue)
		i = encodeVarintRoute(dAtA, i, uint64(len(m.DescriptorValue)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RateLimit_Action_HeaderValueMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RateLimit_Action_HeaderValueMatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RateLimit_Action_HeaderValueMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Headers) > 0 {
		for iNdEx := len(m.Headers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Headers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRoute(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.ExpectMatch != nil {
		{
			size, err := m.ExpectMatch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.DescriptorValue) > 0 {
		i -= len(m.DescriptorValue)
		copy(dAtA[i:], m.DescriptorValue)
		i = encodeVarintRoute(dAtA, i, uint64(len(m.DescriptorValue)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HeaderMatcher) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeaderMatcher) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeaderMatcher) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.HeaderMatchSpecifier != nil {
		{
			size := m.HeaderMatchSpecifier.Size()
			i -= size
			if _, err := m.HeaderMatchSpecifier.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.InvertMatch {
		i--
		if m.InvertMatch {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintRoute(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HeaderMatcher_ExactMatch) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *HeaderMatcher_ExactMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ExactMatch)
	copy(dAtA[i:], m.ExactMatch)
	i = encodeVarintRoute(dAtA, i, uint64(len(m.ExactMatch)))
	i--
	dAtA[i] = 0x22
	return len(dAtA) - i, nil
}
func (m *HeaderMatcher_RangeMatch) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *HeaderMatcher_RangeMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RangeMatch != nil {
		{
			size, err := m.RangeMatch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *HeaderMatcher_PresentMatch) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *HeaderMatcher_PresentMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.PresentMatch {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x38
	return len(dAtA) - i, nil
}
func (m *HeaderMatcher_PrefixMatch) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *HeaderMatcher_PrefixMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.PrefixMatch)
	copy(dAtA[i:], m.PrefixMatch)
	i = encodeVarintRoute(dAtA, i, uint64(len(m.PrefixMatch)))
	i--
	dAtA[i] = 0x4a
	return len(dAtA) - i, nil
}
func (m *HeaderMatcher_SuffixMatch) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *HeaderMatcher_SuffixMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.SuffixMatch)
	copy(dAtA[i:], m.SuffixMatch)
	i = encodeVarintRoute(dAtA, i, uint64(len(m.SuffixMatch)))
	i--
	dAtA[i] = 0x52
	return len(dAtA) - i, nil
}
func (m *HeaderMatcher_SafeRegexMatch) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *HeaderMatcher_SafeRegexMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SafeRegexMatch != nil {
		{
			size, err := m.SafeRegexMatch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *QueryParameterMatcher) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryParameterMatcher) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryParameterMatcher) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.QueryParameterMatchSpecifier != nil {
		{
			size := m.QueryParameterMatchSpecifier.Size()
			i -= size
			if _, err := m.QueryParameterMatchSpecifier.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintRoute(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryParameterMatcher_StringMatch) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *QueryParameterMatcher_StringMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.StringMatch != nil {
		{
			size, err := m.StringMatch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *QueryParameterMatcher_PresentMatch) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *QueryParameterMatcher_PresentMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.PresentMatch {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x30
	return len(dAtA) - i, nil
}
func encodeVarintRoute(dAtA []byte, offset int, v uint64) int {
	offset -= sovRoute(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *VirtualHost) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	if len(m.Domains) > 0 {
		for _, s := range m.Domains {
			l = len(s)
			n += 1 + l + sovRoute(uint64(l))
		}
	}
	if len(m.Routes) > 0 {
		for _, e := range m.Routes {
			l = e.Size()
			n += 1 + l + sovRoute(uint64(l))
		}
	}
	if m.RequireTls != 0 {
		n += 1 + sovRoute(uint64(m.RequireTls))
	}
	if len(m.VirtualClusters) > 0 {
		for _, e := range m.VirtualClusters {
			l = e.Size()
			n += 1 + l + sovRoute(uint64(l))
		}
	}
	if len(m.RateLimits) > 0 {
		for _, e := range m.RateLimits {
			l = e.Size()
			n += 1 + l + sovRoute(uint64(l))
		}
	}
	if len(m.RequestHeadersToAdd) > 0 {
		for _, e := range m.RequestHeadersToAdd {
			l = e.Size()
			n += 1 + l + sovRoute(uint64(l))
		}
	}
	if m.Cors != nil {
		l = m.Cors.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if len(m.ResponseHeadersToAdd) > 0 {
		for _, e := range m.ResponseHeadersToAdd {
			l = e.Size()
			n += 1 + l + sovRoute(uint64(l))
		}
	}
	if len(m.ResponseHeadersToRemove) > 0 {
		for _, s := range m.ResponseHeadersToRemove {
			l = len(s)
			n += 1 + l + sovRoute(uint64(l))
		}
	}
	if len(m.RequestHeadersToRemove) > 0 {
		for _, s := range m.RequestHeadersToRemove {
			l = len(s)
			n += 1 + l + sovRoute(uint64(l))
		}
	}
	if m.IncludeRequestAttemptCount {
		n += 2
	}
	if len(m.TypedPerFilterConfig) > 0 {
		for k, v := range m.TypedPerFilterConfig {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovRoute(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovRoute(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovRoute(uint64(mapEntrySize))
		}
	}
	if m.RetryPolicy != nil {
		l = m.RetryPolicy.Size()
		n += 2 + l + sovRoute(uint64(l))
	}
	if m.HedgePolicy != nil {
		l = m.HedgePolicy.Size()
		n += 2 + l + sovRoute(uint64(l))
	}
	if m.PerRequestBufferLimitBytes != nil {
		l = m.PerRequestBufferLimitBytes.Size()
		n += 2 + l + sovRoute(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Route) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Match != nil {
		l = m.Match.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.Action != nil {
		n += m.Action.Size()
	}
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.Decorator != nil {
		l = m.Decorator.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if len(m.RequestHeadersToAdd) > 0 {
		for _, e := range m.RequestHeadersToAdd {
			l = e.Size()
			n += 1 + l + sovRoute(uint64(l))
		}
	}
	if len(m.ResponseHeadersToAdd) > 0 {
		for _, e := range m.ResponseHeadersToAdd {
			l = e.Size()
			n += 1 + l + sovRoute(uint64(l))
		}
	}
	if len(m.ResponseHeadersToRemove) > 0 {
		for _, s := range m.ResponseHeadersToRemove {
			l = len(s)
			n += 1 + l + sovRoute(uint64(l))
		}
	}
	if len(m.RequestHeadersToRemove) > 0 {
		for _, s := range m.RequestHeadersToRemove {
			l = len(s)
			n += 1 + l + sovRoute(uint64(l))
		}
	}
	if len(m.TypedPerFilterConfig) > 0 {
		for k, v := range m.TypedPerFilterConfig {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovRoute(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovRoute(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovRoute(uint64(mapEntrySize))
		}
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.Tracing != nil {
		l = m.Tracing.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.PerRequestBufferLimitBytes != nil {
		l = m.PerRequestBufferLimitBytes.Size()
		n += 2 + l + sovRoute(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Route_Route) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Route != nil {
		l = m.Route.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	return n
}
func (m *Route_Redirect) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Redirect != nil {
		l = m.Redirect.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	return n
}
func (m *Route_DirectResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DirectResponse != nil {
		l = m.DirectResponse.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	return n
}
func (m *WeightedCluster) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Clusters) > 0 {
		for _, e := range m.Clusters {
			l = e.Size()
			n += 1 + l + sovRoute(uint64(l))
		}
	}
	l = len(m.RuntimeKeyPrefix)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.TotalWeight != nil {
		l = m.TotalWeight.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WeightedCluster_ClusterWeight) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.Weight != nil {
		l = m.Weight.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.MetadataMatch != nil {
		l = m.MetadataMatch.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if len(m.RequestHeadersToAdd) > 0 {
		for _, e := range m.RequestHeadersToAdd {
			l = e.Size()
			n += 1 + l + sovRoute(uint64(l))
		}
	}
	if len(m.ResponseHeadersToAdd) > 0 {
		for _, e := range m.ResponseHeadersToAdd {
			l = e.Size()
			n += 1 + l + sovRoute(uint64(l))
		}
	}
	if len(m.ResponseHeadersToRemove) > 0 {
		for _, s := range m.ResponseHeadersToRemove {
			l = len(s)
			n += 1 + l + sovRoute(uint64(l))
		}
	}
	if len(m.RequestHeadersToRemove) > 0 {
		for _, s := range m.RequestHeadersToRemove {
			l = len(s)
			n += 1 + l + sovRoute(uint64(l))
		}
	}
	if len(m.TypedPerFilterConfig) > 0 {
		for k, v := range m.TypedPerFilterConfig {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovRoute(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovRoute(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovRoute(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RouteMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PathSpecifier != nil {
		n += m.PathSpecifier.Size()
	}
	if m.CaseSensitive != nil {
		l = m.CaseSensitive.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if len(m.Headers) > 0 {
		for _, e := range m.Headers {
			l = e.Size()
			n += 1 + l + sovRoute(uint64(l))
		}
	}
	if len(m.QueryParameters) > 0 {
		for _, e := range m.QueryParameters {
			l = e.Size()
			n += 1 + l + sovRoute(uint64(l))
		}
	}
	if m.Grpc != nil {
		l = m.Grpc.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.RuntimeFraction != nil {
		l = m.RuntimeFraction.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.TlsContext != nil {
		l = m.TlsContext.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RouteMatch_Prefix) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Prefix)
	n += 1 + l + sovRoute(uint64(l))
	return n
}
func (m *RouteMatch_Path) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Path)
	n += 1 + l + sovRoute(uint64(l))
	return n
}
func (m *RouteMatch_SafeRegex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SafeRegex != nil {
		l = m.SafeRegex.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	return n
}
func (m *RouteMatch_GrpcRouteMatchOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RouteMatch_TlsContextMatchOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Presented != nil {
		l = m.Presented.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CorsPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AllowMethods)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	l = len(m.AllowHeaders)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	l = len(m.ExposeHeaders)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	l = len(m.MaxAge)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.AllowCredentials != nil {
		l = m.AllowCredentials.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.EnabledSpecifier != nil {
		n += m.EnabledSpecifier.Size()
	}
	if m.ShadowEnabled != nil {
		l = m.ShadowEnabled.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if len(m.AllowOriginStringMatch) > 0 {
		for _, e := range m.AllowOriginStringMatch {
			l = e.Size()
			n += 1 + l + sovRoute(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CorsPolicy_FilterEnabled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FilterEnabled != nil {
		l = m.FilterEnabled.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	return n
}
func (m *RouteAction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClusterSpecifier != nil {
		n += m.ClusterSpecifier.Size()
	}
	if m.MetadataMatch != nil {
		l = m.MetadataMatch.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	l = len(m.PrefixRewrite)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.HostRewriteSpecifier != nil {
		n += m.HostRewriteSpecifier.Size()
	}
	if m.Timeout != nil {
		l = m.Timeout.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.RetryPolicy != nil {
		l = m.RetryPolicy.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.RequestMirrorPolicy != nil {
		l = m.RequestMirrorPolicy.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.Priority != 0 {
		n += 1 + sovRoute(uint64(m.Priority))
	}
	if len(m.RateLimits) > 0 {
		for _, e := range m.RateLimits {
			l = e.Size()
			n += 1 + l + sovRoute(uint64(l))
		}
	}
	if m.IncludeVhRateLimits != nil {
		l = m.IncludeVhRateLimits.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if len(m.HashPolicy) > 0 {
		for _, e := range m.HashPolicy {
			l = e.Size()
			n += 1 + l + sovRoute(uint64(l))
		}
	}
	if m.Cors != nil {
		l = m.Cors.Size()
		n += 2 + l + sovRoute(uint64(l))
	}
	if m.ClusterNotFoundResponseCode != 0 {
		n += 2 + sovRoute(uint64(m.ClusterNotFoundResponseCode))
	}
	if m.MaxGrpcTimeout != nil {
		l = m.MaxGrpcTimeout.Size()
		n += 2 + l + sovRoute(uint64(l))
	}
	if m.IdleTimeout != nil {
		l = m.IdleTimeout.Size()
		n += 2 + l + sovRoute(uint64(l))
	}
	if len(m.UpgradeConfigs) > 0 {
		for _, e := range m.UpgradeConfigs {
			l = e.Size()
			n += 2 + l + sovRoute(uint64(l))
		}
	}
	if m.InternalRedirectAction != 0 {
		n += 2 + sovRoute(uint64(m.InternalRedirectAction))
	}
	if m.HedgePolicy != nil {
		l = m.HedgePolicy.Size()
		n += 2 + l + sovRoute(uint64(l))
	}
	if m.GrpcTimeoutOffset != nil {
		l = m.GrpcTimeoutOffset.Size()
		n += 2 + l + sovRoute(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RouteAction_Cluster) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Cluster)
	n += 1 + l + sovRoute(uint64(l))
	return n
}
func (m *RouteAction_ClusterHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClusterHeader)
	n += 1 + l + sovRoute(uint64(l))
	return n
}
func (m *RouteAction_WeightedClusters) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WeightedClusters != nil {
		l = m.WeightedClusters.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	return n
}
func (m *RouteAction_HostRewrite) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HostRewrite)
	n += 1 + l + sovRoute(uint64(l))
	return n
}
func (m *RouteAction_AutoHostRewrite) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AutoHostRewrite != nil {
		l = m.AutoHostRewrite.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	return n
}
func (m *RouteAction_AutoHostRewriteHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AutoHostRewriteHeader)
	n += 2 + l + sovRoute(uint64(l))
	return n
}
func (m *RouteAction_RequestMirrorPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Cluster)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.RuntimeFraction != nil {
		l = m.RuntimeFraction.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RouteAction_HashPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PolicySpecifier != nil {
		n += m.PolicySpecifier.Size()
	}
	if m.Terminal {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RouteAction_HashPolicy_Header_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	return n
}
func (m *RouteAction_HashPolicy_Cookie_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cookie != nil {
		l = m.Cookie.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	return n
}
func (m *RouteAction_HashPolicy_ConnectionProperties_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConnectionProperties != nil {
		l = m.ConnectionProperties.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	return n
}
func (m *RouteAction_HashPolicy_Header) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HeaderName)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RouteAction_HashPolicy_Cookie) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.Ttl != nil {
		l = m.Ttl.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RouteAction_HashPolicy_ConnectionProperties) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SourceIp {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RouteAction_UpgradeConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UpgradeType)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.Enabled != nil {
		l = m.Enabled.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RetryPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RetryOn)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.NumRetries != nil {
		l = m.NumRetries.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.PerTryTimeout != nil {
		l = m.PerTryTimeout.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.RetryPriority != nil {
		l = m.RetryPriority.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if len(m.RetryHostPredicate) > 0 {
		for _, e := range m.RetryHostPredicate {
			l = e.Size()
			n += 1 + l + sovRoute(uint64(l))
		}
	}
	if m.HostSelectionRetryMaxAttempts != 0 {
		n += 1 + sovRoute(uint64(m.HostSelectionRetryMaxAttempts))
	}
	if len(m.RetriableStatusCodes) > 0 {
		l = 0
		for _, e := range m.RetriableStatusCodes {
			l += sovRoute(uint64(e))
		}
		n += 1 + sovRoute(uint64(l)) + l
	}
	if m.RetryBackOff != nil {
		l = m.RetryBackOff.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if len(m.RetriableHeaders) > 0 {
		for _, e := range m.RetriableHeaders {
			l = e.Size()
			n += 1 + l + sovRoute(uint64(l))
		}
	}
	if len(m.RetriableRequestHeaders) > 0 {
		for _, e := range m.RetriableRequestHeaders {
			l = e.Size()
			n += 1 + l + sovRoute(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RetryPolicy_RetryPriority) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.ConfigType != nil {
		n += m.ConfigType.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RetryPolicy_RetryPriority_TypedConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypedConfig != nil {
		l = m.TypedConfig.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	return n
}
func (m *RetryPolicy_RetryHostPredicate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.ConfigType != nil {
		n += m.ConfigType.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RetryPolicy_RetryHostPredicate_TypedConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypedConfig != nil {
		l = m.TypedConfig.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	return n
}
func (m *RetryPolicy_RetryBackOff) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BaseInterval != nil {
		l = m.BaseInterval.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.MaxInterval != nil {
		l = m.MaxInterval.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HedgePolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InitialRequests != nil {
		l = m.InitialRequests.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.AdditionalRequestChance != nil {
		l = m.AdditionalRequestChance.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.HedgeOnPerTryTimeout {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RedirectAction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HostRedirect)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.PathRewriteSpecifier != nil {
		n += m.PathRewriteSpecifier.Size()
	}
	if m.ResponseCode != 0 {
		n += 1 + sovRoute(uint64(m.ResponseCode))
	}
	if m.SchemeRewriteSpecifier != nil {
		n += m.SchemeRewriteSpecifier.Size()
	}
	if m.StripQuery {
		n += 2
	}
	if m.PortRedirect != 0 {
		n += 1 + sovRoute(uint64(m.PortRedirect))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RedirectAction_PathRedirect) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PathRedirect)
	n += 1 + l + sovRoute(uint64(l))
	return n
}
func (m *RedirectAction_HttpsRedirect) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *RedirectAction_PrefixRewrite) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PrefixRewrite)
	n += 1 + l + sovRoute(uint64(l))
	return n
}
func (m *RedirectAction_SchemeRedirect) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SchemeRedirect)
	n += 1 + l + sovRoute(uint64(l))
	return n
}
func (m *DirectResponseAction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovRoute(uint64(m.Status))
	}
	if m.Body != nil {
		l = m.Body.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Decorator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Operation)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Tracing) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClientSampling != nil {
		l = m.ClientSampling.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.RandomSampling != nil {
		l = m.RandomSampling.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.OverallSampling != nil {
		l = m.OverallSampling.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VirtualCluster) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	if len(m.Headers) > 0 {
		for _, e := range m.Headers {
			l = e.Size()
			n += 1 + l + sovRoute(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RateLimit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Stage != nil {
		l = m.Stage.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	l = len(m.DisableKey)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	if len(m.Actions) > 0 {
		for _, e := range m.Actions {
			l = e.Size()
			n += 1 + l + sovRoute(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RateLimit_Action) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ActionSpecifier != nil {
		n += m.ActionSpecifier.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RateLimit_Action_SourceCluster_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SourceCluster != nil {
		l = m.SourceCluster.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	return n
}
func (m *RateLimit_Action_DestinationCluster_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DestinationCluster != nil {
		l = m.DestinationCluster.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	return n
}
func (m *RateLimit_Action_RequestHeaders_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestHeaders != nil {
		l = m.RequestHeaders.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	return n
}
func (m *RateLimit_Action_RemoteAddress_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RemoteAddress != nil {
		l = m.RemoteAddress.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	return n
}
func (m *RateLimit_Action_GenericKey_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GenericKey != nil {
		l = m.GenericKey.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	return n
}
func (m *RateLimit_Action_HeaderValueMatch_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HeaderValueMatch != nil {
		l = m.HeaderValueMatch.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	return n
}
func (m *RateLimit_Action_SourceCluster) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RateLimit_Action_DestinationCluster) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RateLimit_Action_RequestHeaders) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HeaderName)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	l = len(m.DescriptorKey)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RateLimit_Action_RemoteAddress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RateLimit_Action_GenericKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DescriptorValue)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RateLimit_Action_HeaderValueMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DescriptorValue)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.ExpectMatch != nil {
		l = m.ExpectMatch.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if len(m.Headers) > 0 {
		for _, e := range m.Headers {
			l = e.Size()
			n += 1 + l + sovRoute(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HeaderMatcher) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.HeaderMatchSpecifier != nil {
		n += m.HeaderMatchSpecifier.Size()
	}
	if m.InvertMatch {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HeaderMatcher_ExactMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ExactMatch)
	n += 1 + l + sovRoute(uint64(l))
	return n
}
func (m *HeaderMatcher_RangeMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RangeMatch != nil {
		l = m.RangeMatch.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	return n
}
func (m *HeaderMatcher_PresentMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *HeaderMatcher_PrefixMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PrefixMatch)
	n += 1 + l + sovRoute(uint64(l))
	return n
}
func (m *HeaderMatcher_SuffixMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SuffixMatch)
	n += 1 + l + sovRoute(uint64(l))
	return n
}
func (m *HeaderMatcher_SafeRegexMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SafeRegexMatch != nil {
		l = m.SafeRegexMatch.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	return n
}
func (m *QueryParameterMatcher) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.QueryParameterMatchSpecifier != nil {
		n += m.QueryParameterMatchSpecifier.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QueryParameterMatcher_StringMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StringMatch != nil {
		l = m.StringMatch.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	return n
}
func (m *QueryParameterMatcher_PresentMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}

func sovRoute(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozRoute(x uint64) (n int) {
	return sovRoute(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *VirtualHost) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VirtualHost: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VirtualHost: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domains", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domains = append(m.Domains, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Routes = append(m.Routes, &Route{})
			if err := m.Routes[len(m.Routes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireTls", wireType)
			}
			m.RequireTls = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequireTls |= VirtualHost_TlsRequirementType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualClusters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VirtualClusters = append(m.VirtualClusters, &VirtualCluster{})
			if err := m.VirtualClusters[len(m.VirtualClusters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateLimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RateLimits = append(m.RateLimits, &RateLimit{})
			if err := m.RateLimits[len(m.RateLimits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeadersToAdd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestHeadersToAdd = append(m.RequestHeadersToAdd, &core.HeaderValueOption{})
			if err := m.RequestHeadersToAdd[len(m.RequestHeadersToAdd)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cors == nil {
				m.Cors = &CorsPolicy{}
			}
			if err := m.Cors.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeadersToAdd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResponseHeadersToAdd = append(m.ResponseHeadersToAdd, &core.HeaderValueOption{})
			if err := m.ResponseHeadersToAdd[len(m.ResponseHeadersToAdd)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeadersToRemove", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResponseHeadersToRemove = append(m.ResponseHeadersToRemove, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeadersToRemove", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestHeadersToRemove = append(m.RequestHeadersToRemove, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeRequestAttemptCount", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IncludeRequestAttemptCount = bool(v != 0)
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypedPerFilterConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TypedPerFilterConfig == nil {
				m.TypedPerFilterConfig = make(map[string]*types.Any)
			}
			var mapkey string
			var mapvalue *types.Any
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRoute
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoute
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthRoute
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthRoute
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoute
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthRoute
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthRoute
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &types.Any{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRoute(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthRoute
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.TypedPerFilterConfig[mapkey] = mapvalue
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetryPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RetryPolicy == nil {
				m.RetryPolicy = &RetryPolicy{}
			}
			if err := m.RetryPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HedgePolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HedgePolicy == nil {
				m.HedgePolicy = &HedgePolicy{}
			}
			if err := m.HedgePolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerRequestBufferLimitBytes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PerRequestBufferLimitBytes == nil {
				m.PerRequestBufferLimitBytes = &types.UInt32Value{}
			}
			if err := m.PerRequestBufferLimitBytes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Route) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Route: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Route: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Match == nil {
				m.Match = &RouteMatch{}
			}
			if err := m.Match.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Route", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RouteAction{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Route_Route{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Redirect", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RedirectAction{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Route_Redirect{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &core.Metadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Decorator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Decorator == nil {
				m.Decorator = &Decorator{}
			}
			if err := m.Decorator.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirectResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DirectResponseAction{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Route_DirectResponse{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeadersToAdd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestHeadersToAdd = append(m.RequestHeadersToAdd, &core.HeaderValueOption{})
			if err := m.RequestHeadersToAdd[len(m.RequestHeadersToAdd)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeadersToAdd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResponseHeadersToAdd = append(m.ResponseHeadersToAdd, &core.HeaderValueOption{})
			if err := m.ResponseHeadersToAdd[len(m.ResponseHeadersToAdd)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeadersToRemove", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResponseHeadersToRemove = append(m.ResponseHeadersToRemove, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeadersToRemove", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestHeadersToRemove = append(m.RequestHeadersToRemove, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypedPerFilterConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TypedPerFilterConfig == nil {
				m.TypedPerFilterConfig = make(map[string]*types.Any)
			}
			var mapkey string
			var mapvalue *types.Any
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRoute
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoute
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthRoute
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthRoute
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoute
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthRoute
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthRoute
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &types.Any{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRoute(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthRoute
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.TypedPerFilterConfig[mapkey] = mapvalue
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tracing", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tracing == nil {
				m.Tracing = &Tracing{}
			}
			if err := m.Tracing.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerRequestBufferLimitBytes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PerRequestBufferLimitBytes == nil {
				m.PerRequestBufferLimitBytes = &types.UInt32Value{}
			}
			if err := m.PerRequestBufferLimitBytes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WeightedCluster) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WeightedCluster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WeightedCluster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clusters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Clusters = append(m.Clusters, &WeightedCluster_ClusterWeight{})
			if err := m.Clusters[len(m.Clusters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeKeyPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuntimeKeyPrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalWeight", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TotalWeight == nil {
				m.TotalWeight = &types.UInt32Value{}
			}
			if err := m.TotalWeight.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WeightedCluster_ClusterWeight) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterWeight: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterWeight: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Weight == nil {
				m.Weight = &types.UInt32Value{}
			}
			if err := m.Weight.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetadataMatch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MetadataMatch == nil {
				m.MetadataMatch = &core.Metadata{}
			}
			if err := m.MetadataMatch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeadersToAdd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestHeadersToAdd = append(m.RequestHeadersToAdd, &core.HeaderValueOption{})
			if err := m.RequestHeadersToAdd[len(m.RequestHeadersToAdd)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeadersToAdd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResponseHeadersToAdd = append(m.ResponseHeadersToAdd, &core.HeaderValueOption{})
			if err := m.ResponseHeadersToAdd[len(m.ResponseHeadersToAdd)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeadersToRemove", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResponseHeadersToRemove = append(m.ResponseHeadersToRemove, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeadersToRemove", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestHeadersToRemove = append(m.RequestHeadersToRemove, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypedPerFilterConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TypedPerFilterConfig == nil {
				m.TypedPerFilterConfig = make(map[string]*types.Any)
			}
			var mapkey string
			var mapvalue *types.Any
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRoute
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoute
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthRoute
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthRoute
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoute
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthRoute
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthRoute
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &types.Any{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRoute(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthRoute
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.TypedPerFilterConfig[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathSpecifier = &RouteMatch_Prefix{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathSpecifier = &RouteMatch_Path{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaseSensitive", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CaseSensitive == nil {
				m.CaseSensitive = &types.BoolValue{}
			}
			if err := m.CaseSensitive.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headers = append(m.Headers, &HeaderMatcher{})
			if err := m.Headers[len(m.Headers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryParameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueryParameters = append(m.QueryParameters, &QueryParameterMatcher{})
			if err := m.QueryParameters[len(m.QueryParameters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Grpc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Grpc == nil {
				m.Grpc = &RouteMatch_GrpcRouteMatchOptions{}
			}
			if err := m.Grpc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeFraction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RuntimeFraction == nil {
				m.RuntimeFraction = &core.RuntimeFractionalPercent{}
			}
			if err := m.RuntimeFraction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SafeRegex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v3alpha.RegexMatcher{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PathSpecifier = &RouteMatch_SafeRegex{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsContext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TlsContext == nil {
				m.TlsContext = &RouteMatch_TlsContextMatchOptions{}
			}
			if err := m.TlsContext.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteMatch_GrpcRouteMatchOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GrpcRouteMatchOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GrpcRouteMatchOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteMatch_TlsContextMatchOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TlsContextMatchOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TlsContextMatchOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Presented", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Presented == nil {
				m.Presented = &types.BoolValue{}
			}
			if err := m.Presented.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CorsPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CorsPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CorsPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowMethods", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowMethods = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowHeaders", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowHeaders = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExposeHeaders", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExposeHeaders = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxAge", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaxAge = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowCredentials", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AllowCredentials == nil {
				m.AllowCredentials = &types.BoolValue{}
			}
			if err := m.AllowCredentials.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilterEnabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &core.RuntimeFractionalPercent{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EnabledSpecifier = &CorsPolicy_FilterEnabled{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShadowEnabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShadowEnabled == nil {
				m.ShadowEnabled = &core.RuntimeFractionalPercent{}
			}
			if err := m.ShadowEnabled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowOriginStringMatch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowOriginStringMatch = append(m.AllowOriginStringMatch, &v3alpha.StringMatcher{})
			if err := m.AllowOriginStringMatch[len(m.AllowOriginStringMatch)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cluster", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterSpecifier = &RouteAction_Cluster{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterHeader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterSpecifier = &RouteAction_ClusterHeader{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeightedClusters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &WeightedCluster{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ClusterSpecifier = &RouteAction_WeightedClusters{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetadataMatch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MetadataMatch == nil {
				m.MetadataMatch = &core.Metadata{}
			}
			if err := m.MetadataMatch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixRewrite", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrefixRewrite = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostRewrite", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostRewriteSpecifier = &RouteAction_HostRewrite{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoHostRewrite", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.BoolValue{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.HostRewriteSpecifier = &RouteAction_AutoHostRewrite{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timeout == nil {
				m.Timeout = &types.Duration{}
			}
			if err := m.Timeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetryPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RetryPolicy == nil {
				m.RetryPolicy = &RetryPolicy{}
			}
			if err := m.RetryPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestMirrorPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RequestMirrorPolicy == nil {
				m.RequestMirrorPolicy = &RouteAction_RequestMirrorPolicy{}
			}
			if err := m.RequestMirrorPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= core.RoutingPriority(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateLimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RateLimits = append(m.RateLimits, &RateLimit{})
			if err := m.RateLimits[len(m.RateLimits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeVhRateLimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IncludeVhRateLimits == nil {
				m.IncludeVhRateLimits = &types.BoolValue{}
			}
			if err := m.IncludeVhRateLimits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HashPolicy = append(m.HashPolicy, &RouteAction_HashPolicy{})
			if err := m.HashPolicy[len(m.HashPolicy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cors == nil {
				m.Cors = &CorsPolicy{}
			}
			if err := m.Cors.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterNotFoundResponseCode", wireType)
			}
			m.ClusterNotFoundResponseCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterNotFoundResponseCode |= RouteAction_ClusterNotFoundResponseCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxGrpcTimeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxGrpcTimeout == nil {
				m.MaxGrpcTimeout = &types.Duration{}
			}
			if err := m.MaxGrpcTimeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdleTimeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdleTimeout == nil {
				m.IdleTimeout = &types.Duration{}
			}
			if err := m.IdleTimeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpgradeConfigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpgradeConfigs = append(m.UpgradeConfigs, &RouteAction_UpgradeConfig{})
			if err := m.UpgradeConfigs[len(m.UpgradeConfigs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalRedirectAction", wireType)
			}
			m.InternalRedirectAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InternalRedirectAction |= RouteAction_InternalRedirectAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HedgePolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HedgePolicy == nil {
				m.HedgePolicy = &HedgePolicy{}
			}
			if err := m.HedgePolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GrpcTimeoutOffset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GrpcTimeoutOffset == nil {
				m.GrpcTimeoutOffset = &types.Duration{}
			}
			if err := m.GrpcTimeoutOffset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoHostRewriteHeader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostRewriteSpecifier = &RouteAction_AutoHostRewriteHeader{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteAction_RequestMirrorPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestMirrorPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestMirrorPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cluster", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cluster = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeFraction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RuntimeFraction == nil {
				m.RuntimeFraction = &core.RuntimeFractionalPercent{}
			}
			if err := m.RuntimeFraction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteAction_HashPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HashPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HashPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RouteAction_HashPolicy_Header{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PolicySpecifier = &RouteAction_HashPolicy_Header_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cookie", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RouteAction_HashPolicy_Cookie{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PolicySpecifier = &RouteAction_HashPolicy_Cookie_{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionProperties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RouteAction_HashPolicy_ConnectionProperties{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PolicySpecifier = &RouteAction_HashPolicy_ConnectionProperties_{v}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Terminal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Terminal = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteAction_HashPolicy_Header) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Header: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Header: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeaderName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeaderName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteAction_HashPolicy_Cookie) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cookie: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cookie: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ttl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ttl == nil {
				m.Ttl = &types.Duration{}
			}
			if err := m.Ttl.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteAction_HashPolicy_ConnectionProperties) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnectionProperties: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnectionProperties: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceIp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SourceIp = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteAction_UpgradeConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpgradeConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpgradeConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpgradeType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpgradeType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Enabled == nil {
				m.Enabled = &types.BoolValue{}
			}
			if err := m.Enabled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RetryPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RetryPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RetryPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetryOn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RetryOn = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumRetries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NumRetries == nil {
				m.NumRetries = &types.UInt32Value{}
			}
			if err := m.NumRetries.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerTryTimeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PerTryTimeout == nil {
				m.PerTryTimeout = &types.Duration{}
			}
			if err := m.PerTryTimeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetryPriority", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RetryPriority == nil {
				m.RetryPriority = &RetryPolicy_RetryPriority{}
			}
			if err := m.RetryPriority.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetryHostPredicate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RetryHostPredicate = append(m.RetryHostPredicate, &RetryPolicy_RetryHostPredicate{})
			if err := m.RetryHostPredicate[len(m.RetryHostPredicate)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostSelectionRetryMaxAttempts", wireType)
			}
			m.HostSelectionRetryMaxAttempts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HostSelectionRetryMaxAttempts |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRoute
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RetriableStatusCodes = append(m.RetriableStatusCodes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRoute
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRoute
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthRoute
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RetriableStatusCodes) == 0 {
					m.RetriableStatusCodes = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoute
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RetriableStatusCodes = append(m.RetriableStatusCodes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RetriableStatusCodes", wireType)
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetryBackOff", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RetryBackOff == nil {
				m.RetryBackOff = &RetryPolicy_RetryBackOff{}
			}
			if err := m.RetryBackOff.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetriableHeaders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RetriableHeaders = append(m.RetriableHeaders, &HeaderMatcher{})
			if err := m.RetriableHeaders[len(m.RetriableHeaders)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetriableRequestHeaders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RetriableRequestHeaders = append(m.RetriableRequestHeaders, &HeaderMatcher{})
			if err := m.RetriableRequestHeaders[len(m.RetriableRequestHeaders)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RetryPolicy_RetryPriority) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RetryPriority: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RetryPriority: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypedConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.Any{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ConfigType = &RetryPolicy_RetryPriority_TypedConfig{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RetryPolicy_RetryHostPredicate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RetryHostPredicate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RetryHostPredicate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypedConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.Any{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ConfigType = &RetryPolicy_RetryHostPredicate_TypedConfig{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RetryPolicy_RetryBackOff) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RetryBackOff: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RetryBackOff: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseInterval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BaseInterval == nil {
				m.BaseInterval = &types.Duration{}
			}
			if err := m.BaseInterval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxInterval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxInterval == nil {
				m.MaxInterval = &types.Duration{}
			}
			if err := m.MaxInterval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HedgePolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HedgePolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HedgePolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialRequests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InitialRequests == nil {
				m.InitialRequests = &types.UInt32Value{}
			}
			if err := m.InitialRequests.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdditionalRequestChance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AdditionalRequestChance == nil {
				m.AdditionalRequestChance = &v3alpha1.FractionalPercent{}
			}
			if err := m.AdditionalRequestChance.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HedgeOnPerTryTimeout", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HedgeOnPerTryTimeout = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RedirectAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RedirectAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RedirectAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostRedirect", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostRedirect = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathRedirect", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathRewriteSpecifier = &RedirectAction_PathRedirect{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseCode", wireType)
			}
			m.ResponseCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResponseCode |= RedirectAction_RedirectResponseCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpsRedirect", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.SchemeRewriteSpecifier = &RedirectAction_HttpsRedirect{b}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixRewrite", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathRewriteSpecifier = &RedirectAction_PrefixRewrite{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StripQuery", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StripQuery = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemeRedirect", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SchemeRewriteSpecifier = &RedirectAction_SchemeRedirect{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortRedirect", wireType)
			}
			m.PortRedirect = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PortRedirect |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DirectResponseAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DirectResponseAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DirectResponseAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Body == nil {
				m.Body = &core.DataSource{}
			}
			if err := m.Body.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Decorator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Decorator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Decorator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tracing) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tracing: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tracing: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientSampling", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClientSampling == nil {
				m.ClientSampling = &v3alpha1.FractionalPercent{}
			}
			if err := m.ClientSampling.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RandomSampling", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RandomSampling == nil {
				m.RandomSampling = &v3alpha1.FractionalPercent{}
			}
			if err := m.RandomSampling.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverallSampling", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OverallSampling == nil {
				m.OverallSampling = &v3alpha1.FractionalPercent{}
			}
			if err := m.OverallSampling.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VirtualCluster) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VirtualCluster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VirtualCluster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headers = append(m.Headers, &HeaderMatcher{})
			if err := m.Headers[len(m.Headers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RateLimit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RateLimit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RateLimit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stage == nil {
				m.Stage = &types.UInt32Value{}
			}
			if err := m.Stage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisableKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Actions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Actions = append(m.Actions, &RateLimit_Action{})
			if err := m.Actions[len(m.Actions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RateLimit_Action) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Action: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Action: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceCluster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RateLimit_Action_SourceCluster{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionSpecifier = &RateLimit_Action_SourceCluster_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationCluster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RateLimit_Action_DestinationCluster{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionSpecifier = &RateLimit_Action_DestinationCluster_{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeaders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RateLimit_Action_RequestHeaders{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionSpecifier = &RateLimit_Action_RequestHeaders_{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RateLimit_Action_RemoteAddress{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionSpecifier = &RateLimit_Action_RemoteAddress_{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenericKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RateLimit_Action_GenericKey{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionSpecifier = &RateLimit_Action_GenericKey_{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeaderValueMatch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RateLimit_Action_HeaderValueMatch{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionSpecifier = &RateLimit_Action_HeaderValueMatch_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RateLimit_Action_SourceCluster) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SourceCluster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SourceCluster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RateLimit_Action_DestinationCluster) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DestinationCluster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DestinationCluster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RateLimit_Action_RequestHeaders) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestHeaders: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestHeaders: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeaderName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeaderName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DescriptorKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DescriptorKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RateLimit_Action_RemoteAddress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoteAddress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoteAddress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RateLimit_Action_GenericKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenericKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenericKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DescriptorValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DescriptorValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RateLimit_Action_HeaderValueMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeaderValueMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeaderValueMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DescriptorValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DescriptorValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectMatch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpectMatch == nil {
				m.ExpectMatch = &types.BoolValue{}
			}
			if err := m.ExpectMatch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headers = append(m.Headers, &HeaderMatcher{})
			if err := m.Headers[len(m.Headers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeaderMatcher) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeaderMatcher: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeaderMatcher: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExactMatch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeaderMatchSpecifier = &HeaderMatcher_ExactMatch{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeMatch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v3alpha1.Int64Range{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.HeaderMatchSpecifier = &HeaderMatcher_RangeMatch{v}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PresentMatch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.HeaderMatchSpecifier = &HeaderMatcher_PresentMatch{b}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertMatch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InvertMatch = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixMatch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeaderMatchSpecifier = &HeaderMatcher_PrefixMatch{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuffixMatch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeaderMatchSpecifier = &HeaderMatcher_SuffixMatch{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SafeRegexMatch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v3alpha.RegexMatcher{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.HeaderMatchSpecifier = &HeaderMatcher_SafeRegexMatch{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryParameterMatcher) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryParameterMatcher: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryParameterMatcher: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringMatch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v3alpha.StringMatcher{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.QueryParameterMatchSpecifier = &QueryParameterMatcher_StringMatch{v}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PresentMatch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.QueryParameterMatchSpecifier = &QueryParameterMatcher_PresentMatch{b}
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRoute(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthRoute
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthRoute
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowRoute
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipRoute(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthRoute
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthRoute = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRoute   = fmt.Errorf("proto: integer overflow")
)
